(*Generated by Sail from cheri.*)
Require Import Sail.Base.
Require Import Sail.Real.
Require Import cheri_types.
Require Import mips_extras.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition trace : bool := false.
Hint Unfold trace : sail.
Definition eq_unit (_ : unit) (_ : unit) : {_bool : bool & ArithFact (_bool)} := build_ex (true).

Definition neq_int (x : Z) (y : Z) : {_bool : bool & ArithFact (Bool.eqb (negb (x =? y)) _bool)} :=
   build_ex (negb (Z.eqb x y)).

Definition neq_bool (x : bool) (y : bool) : bool := negb (Bool.eqb x y).

Definition __id (x : Z) : {_retval : Z & ArithFact (_retval =? x)} := build_ex (x).

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if sumbool_of_bool (Z.geb n 0) then shl_int m n else shr_int m (Z.opp n).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if sumbool_of_bool (Z.geb n 0) then shr_int m n else shl_int m (Z.opp n).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if sumbool_of_bool (andb (Z.ltb n 0) (Z.gtb m 0)) then Z.sub (Z.quot (Z.add n 1) m) 1
   else if sumbool_of_bool (andb (Z.gtb n 0) (Z.ltb m 0)) then Z.sub (Z.quot (Z.sub n 1) m) 1
   else Z.quot n m.

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub n (Z.mul m (fdiv_int n m)).

Definition undefined_option {a : Type} (typ_a : a) : M (option a) :=
   (undefined_unit tt) >>= fun u_0 : unit =>
   let u_1 : a := typ_a in
   (internal_pick [Some u_1; None])
    : M (option a).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.



Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) `{ArithFact ((len >=? 0) && (v0 >=? 0))}
: mword len :=
   if sumbool_of_bool (Z.leb len (length_mword v)) then vector_truncate v len else zero_extend v len.

Definition sail_ones (n : Z) `{ArithFact (n >=? 0)} : mword n := not_vec (zeros n).

Definition slice_mask (n : Z) (i : Z) (l : Z) `{ArithFact (n >=? 0)} : mword n :=
   if sumbool_of_bool (Z.geb l n) then shiftl (sail_ones n) i
   else
     let one : bits n := sail_mask n ('b"1"  : bits 1) in
     shiftl (sub_vec (shiftl one l) one) i.

Definition concat_str_bits {n : Z} (str : string) (x : mword n) : string :=
   String.append str (string_of_bits x).

Definition concat_str_dec (str : string) (x : Z) : string := String.append str (dec_str x).



Definition cast_unit_vec (b : bitU) : mword 1 :=
   match b with | B0 => 'b"0"  : mword 1 | _ => 'b"1"  : mword 1 end.

Definition __MIPS_write (addr : mword 64) (width : Z) (data : mword (8 * width)) : M (unit) :=
   (write_ram 64 width (Ox"0000000000000000"  : mword 64) addr data) >> returnm tt.

Definition __MIPS_read (addr : mword 64) (width : Z) `{ArithFact (width >=? 0)}
: M (mword (8 * width)) :=
   (read_ram 64 width (Ox"0000000000000000"  : mword 64) addr)  : M (mword (8 * width)).

Definition zopz0zQzQ {n0 : Z} (bs : mword n0) (n : Z) `{ArithFact (n >=? 0)} : mword (n0 * n) :=
   replicate_bits bs n.

Definition undefined_exception '(tt : unit) : M (exception) :=
   (undefined_string tt) >>= fun u_0 : string =>
   (undefined_unit tt) >>= fun u_1 : unit =>
   (internal_pick
      [ISAException u_1;
      Error_not_implemented u_0;
      Error_misaligned_access u_1;
      Error_EBREAK u_1;
      Error_internal_error u_1])
    : M (exception).

Definition mips_sign_extend {n : Z} (m : Z) (v : mword n) `{ArithFact (m >=? n)} : mword m :=
   sign_extend v m.

Definition mips_zero_extend {n : Z} (m : Z) (v : mword n) `{ArithFact (m >=? n)} : mword m :=
   zero_extend v m.

Definition zeros_implicit (n : Z) (_ : unit) `{ArithFact (n >=? 0)} : mword n := zeros n.

Definition ones_implicit (n : Z) (_ : unit) `{ArithFact (n >=? 0)} : mword n := sail_ones n.

Definition zopz0zI_s {n : Z} (x : mword n) (y : mword n) `{ArithFact (n >? 0)} : bool :=
   Z.ltb (projT1 (sint x)) (projT1 (sint y)).

Definition zopz0zKzJ_s {n : Z} (x : mword n) (y : mword n) `{ArithFact (n >? 0)} : bool :=
   Z.geb (projT1 (sint x)) (projT1 (sint y)).

Definition zopz0zI_u {n : Z} (x : mword n) (y : mword n) `{ArithFact (n >=? 0)} : bool :=
   Z.ltb (projT1 (uint x)) (projT1 (uint y)).

Definition zopz0zKzJ_u {n : Z} (x : mword n) (y : mword n) `{ArithFact (n >=? 0)} : bool :=
   Z.geb (projT1 (uint x)) (projT1 (uint y)).

Definition bool_to_bits (x : bool) : mword 1 :=
   if sumbool_of_bool x then 'b"1"  : mword 1 else 'b"0"  : mword 1.

Definition bool_to_bit (x : bool) : bitU := if sumbool_of_bool x then B1 else B0.

Definition bit_to_bool (b : bitU) : bool := match b with | B1 => true | _ => false end.

Definition bits_to_bool (x : mword 1) : bool := bit_to_bool (access_vec_dec x 0).

Definition to_bits (l : Z) (n : Z) `{ArithFact (l >=? 0)} : mword l := get_slice_int l n 0.

Definition mask {m : Z} (n : Z) (bs : mword m) `{ArithFact ((m >=? n) && (n >? 0))} : mword n :=
   autocast (subrange_vec_dec bs (Z.sub n 1) 0).

Definition undefined_CauseReg '(tt : unit) : M (CauseReg) :=
   (undefined_bitvector 32) >>= fun w__0 : mword 32 =>
   returnm ({| CauseReg_CauseReg_chunk_0 := w__0 |}).

Definition Mk_CauseReg (v : mword 32) : CauseReg :=
   {| CauseReg_CauseReg_chunk_0 := (subrange_vec_dec v 31 0) |}.

Definition _get_CauseReg_bits (v : CauseReg) : mword 32 :=
   subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 31 0.

Definition _set_CauseReg_bits (r_ref : register_ref regstate register_value CauseReg) (v : mword 32)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CauseReg_CauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CauseReg_CauseReg_chunk_0) 31 0 (subrange_vec_dec v 31 0)) ]}
      : CauseReg in
   write_reg r_ref r
    : M (unit).

Definition _update_CauseReg_bits (v : CauseReg) (x : mword 32) : CauseReg :=
   {[ v with
     CauseReg_CauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 31 0 (subrange_vec_dec x 31 0)) ]}.

Definition _get_CauseReg_BD (v : CauseReg) : mword 1 :=
   subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 31 31.

Definition _set_CauseReg_BD (r_ref : register_ref regstate register_value CauseReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CauseReg_CauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CauseReg_CauseReg_chunk_0) 31 31 (subrange_vec_dec v 0 0)) ]}
      : CauseReg in
   write_reg r_ref r
    : M (unit).

Definition _update_CauseReg_BD (v : CauseReg) (x : mword 1) : CauseReg :=
   {[ v with
     CauseReg_CauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 31 31 (subrange_vec_dec x 0 0)) ]}.

Definition _get_CauseReg_CE (v : CauseReg) : mword 2 :=
   subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 29 28.

Definition _set_CauseReg_CE (r_ref : register_ref regstate register_value CauseReg) (v : mword 2)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CauseReg_CauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CauseReg_CauseReg_chunk_0) 29 28 (subrange_vec_dec v 1 0)) ]}
      : CauseReg in
   write_reg r_ref r
    : M (unit).

Definition _update_CauseReg_CE (v : CauseReg) (x : mword 2) : CauseReg :=
   {[ v with
     CauseReg_CauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 29 28 (subrange_vec_dec x 1 0)) ]}.

Definition _get_CauseReg_IV (v : CauseReg) : mword 1 :=
   subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 23 23.

Definition _set_CauseReg_IV (r_ref : register_ref regstate register_value CauseReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CauseReg_CauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CauseReg_CauseReg_chunk_0) 23 23 (subrange_vec_dec v 0 0)) ]}
      : CauseReg in
   write_reg r_ref r
    : M (unit).

Definition _update_CauseReg_IV (v : CauseReg) (x : mword 1) : CauseReg :=
   {[ v with
     CauseReg_CauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 23 23 (subrange_vec_dec x 0 0)) ]}.

Definition _get_CauseReg_WP (v : CauseReg) : mword 1 :=
   subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 22 22.

Definition _set_CauseReg_WP (r_ref : register_ref regstate register_value CauseReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CauseReg_CauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CauseReg_CauseReg_chunk_0) 22 22 (subrange_vec_dec v 0 0)) ]}
      : CauseReg in
   write_reg r_ref r
    : M (unit).

Definition _update_CauseReg_WP (v : CauseReg) (x : mword 1) : CauseReg :=
   {[ v with
     CauseReg_CauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 22 22 (subrange_vec_dec x 0 0)) ]}.

Definition _get_CauseReg_IP (v : CauseReg) : mword 8 :=
   subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 15 8.

Definition _set_CauseReg_IP (r_ref : register_ref regstate register_value CauseReg) (v : mword 8)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CauseReg_CauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CauseReg_CauseReg_chunk_0) 15 8 (subrange_vec_dec v 7 0)) ]}
      : CauseReg in
   write_reg r_ref r
    : M (unit).

Definition _update_CauseReg_IP (v : CauseReg) (x : mword 8) : CauseReg :=
   {[ v with
     CauseReg_CauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 15 8 (subrange_vec_dec x 7 0)) ]}.

Definition _get_CauseReg_ExcCode (v : CauseReg) : mword 5 :=
   subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 6 2.

Definition _set_CauseReg_ExcCode
(r_ref : register_ref regstate register_value CauseReg) (v : mword 5)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CauseReg_CauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CauseReg_CauseReg_chunk_0) 6 2 (subrange_vec_dec v 4 0)) ]}
      : CauseReg in
   write_reg r_ref r
    : M (unit).

Definition _update_CauseReg_ExcCode (v : CauseReg) (x : mword 5) : CauseReg :=
   {[ v with
     CauseReg_CauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CauseReg_CauseReg_chunk_0) 6 2 (subrange_vec_dec x 4 0)) ]}.

Definition undefined_TLBEntryLoReg '(tt : unit) : M (TLBEntryLoReg) :=
   (undefined_bitvector 64) >>= fun w__0 : mword 64 =>
   returnm ({| TLBEntryLoReg_TLBEntryLoReg_chunk_0 := w__0 |}).

Definition Mk_TLBEntryLoReg (v : mword 64) : TLBEntryLoReg :=
   {| TLBEntryLoReg_TLBEntryLoReg_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_TLBEntryLoReg_bits (v : TLBEntryLoReg) : mword 64 :=
   subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 63 0.

Definition _set_TLBEntryLoReg_bits
(r_ref : register_ref regstate register_value TLBEntryLoReg) (v : mword 64)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 63 0
            (subrange_vec_dec v 63 0)) ]}
      : TLBEntryLoReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryLoReg_bits (v : TLBEntryLoReg) (x : mword 64) : TLBEntryLoReg :=
   {[ v with
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 63 0
          (subrange_vec_dec x 63 0)) ]}.

Definition _get_TLBEntryLoReg_CapS (v : TLBEntryLoReg) : mword 1 :=
   subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 63 63.

Definition _set_TLBEntryLoReg_CapS
(r_ref : register_ref regstate register_value TLBEntryLoReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 63 63
            (subrange_vec_dec v 0 0)) ]}
      : TLBEntryLoReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryLoReg_CapS (v : TLBEntryLoReg) (x : mword 1) : TLBEntryLoReg :=
   {[ v with
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 63 63
          (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntryLoReg_CapL (v : TLBEntryLoReg) : mword 1 :=
   subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 62 62.

Definition _set_TLBEntryLoReg_CapL
(r_ref : register_ref regstate register_value TLBEntryLoReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 62 62
            (subrange_vec_dec v 0 0)) ]}
      : TLBEntryLoReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryLoReg_CapL (v : TLBEntryLoReg) (x : mword 1) : TLBEntryLoReg :=
   {[ v with
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 62 62
          (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntryLoReg_CapLG (v : TLBEntryLoReg) : mword 1 :=
   subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 61 61.

Definition _set_TLBEntryLoReg_CapLG
(r_ref : register_ref regstate register_value TLBEntryLoReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 61 61
            (subrange_vec_dec v 0 0)) ]}
      : TLBEntryLoReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryLoReg_CapLG (v : TLBEntryLoReg) (x : mword 1) : TLBEntryLoReg :=
   {[ v with
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 61 61
          (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntryLoReg_PFN (v : TLBEntryLoReg) : mword 24 :=
   subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 29 6.

Definition _set_TLBEntryLoReg_PFN
(r_ref : register_ref regstate register_value TLBEntryLoReg) (v : mword 24)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 29 6
            (subrange_vec_dec v 23 0)) ]}
      : TLBEntryLoReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryLoReg_PFN (v : TLBEntryLoReg) (x : mword 24) : TLBEntryLoReg :=
   {[ v with
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 29 6
          (subrange_vec_dec x 23 0)) ]}.

Definition _get_TLBEntryLoReg_C (v : TLBEntryLoReg) : mword 3 :=
   subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 5 3.

Definition _set_TLBEntryLoReg_C
(r_ref : register_ref regstate register_value TLBEntryLoReg) (v : mword 3)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 5 3
            (subrange_vec_dec v 2 0)) ]}
      : TLBEntryLoReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryLoReg_C (v : TLBEntryLoReg) (x : mword 3) : TLBEntryLoReg :=
   {[ v with
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 5 3 (subrange_vec_dec x 2 0)) ]}.

Definition _get_TLBEntryLoReg_D (v : TLBEntryLoReg) : mword 1 :=
   subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 2 2.

Definition _set_TLBEntryLoReg_D
(r_ref : register_ref regstate register_value TLBEntryLoReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 2 2
            (subrange_vec_dec v 0 0)) ]}
      : TLBEntryLoReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryLoReg_D (v : TLBEntryLoReg) (x : mword 1) : TLBEntryLoReg :=
   {[ v with
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 2 2 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntryLoReg_V (v : TLBEntryLoReg) : mword 1 :=
   subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 1 1.

Definition _set_TLBEntryLoReg_V
(r_ref : register_ref regstate register_value TLBEntryLoReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 1 1
            (subrange_vec_dec v 0 0)) ]}
      : TLBEntryLoReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryLoReg_V (v : TLBEntryLoReg) (x : mword 1) : TLBEntryLoReg :=
   {[ v with
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntryLoReg_G (v : TLBEntryLoReg) : mword 1 :=
   subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 0 0.

Definition _set_TLBEntryLoReg_G
(r_ref : register_ref regstate register_value TLBEntryLoReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 0 0
            (subrange_vec_dec v 0 0)) ]}
      : TLBEntryLoReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryLoReg_G (v : TLBEntryLoReg) (x : mword 1) : TLBEntryLoReg :=
   {[ v with
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryLoReg_TLBEntryLoReg_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition undefined_TLBEntryHiReg '(tt : unit) : M (TLBEntryHiReg) :=
   (undefined_bitvector 64) >>= fun w__0 : mword 64 =>
   returnm ({| TLBEntryHiReg_TLBEntryHiReg_chunk_0 := w__0 |}).

Definition Mk_TLBEntryHiReg (v : mword 64) : TLBEntryHiReg :=
   {| TLBEntryHiReg_TLBEntryHiReg_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_TLBEntryHiReg_bits (v : TLBEntryHiReg) : mword 64 :=
   subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 63 0.

Definition _set_TLBEntryHiReg_bits
(r_ref : register_ref regstate register_value TLBEntryHiReg) (v : mword 64)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 63 0
            (subrange_vec_dec v 63 0)) ]}
      : TLBEntryHiReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryHiReg_bits (v : TLBEntryHiReg) (x : mword 64) : TLBEntryHiReg :=
   {[ v with
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 63 0
          (subrange_vec_dec x 63 0)) ]}.

Definition _get_TLBEntryHiReg_R (v : TLBEntryHiReg) : mword 2 :=
   subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 63 62.

Definition _set_TLBEntryHiReg_R
(r_ref : register_ref regstate register_value TLBEntryHiReg) (v : mword 2)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 63 62
            (subrange_vec_dec v 1 0)) ]}
      : TLBEntryHiReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryHiReg_R (v : TLBEntryHiReg) (x : mword 2) : TLBEntryHiReg :=
   {[ v with
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 63 62
          (subrange_vec_dec x 1 0)) ]}.

Definition _get_TLBEntryHiReg_CLGK (v : TLBEntryHiReg) : mword 1 :=
   subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 61 61.

Definition _set_TLBEntryHiReg_CLGK
(r_ref : register_ref regstate register_value TLBEntryHiReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 61 61
            (subrange_vec_dec v 0 0)) ]}
      : TLBEntryHiReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryHiReg_CLGK (v : TLBEntryHiReg) (x : mword 1) : TLBEntryHiReg :=
   {[ v with
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 61 61
          (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntryHiReg_CLGS (v : TLBEntryHiReg) : mword 1 :=
   subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 60 60.

Definition _set_TLBEntryHiReg_CLGS
(r_ref : register_ref regstate register_value TLBEntryHiReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 60 60
            (subrange_vec_dec v 0 0)) ]}
      : TLBEntryHiReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryHiReg_CLGS (v : TLBEntryHiReg) (x : mword 1) : TLBEntryHiReg :=
   {[ v with
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 60 60
          (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntryHiReg_CLGU (v : TLBEntryHiReg) : mword 1 :=
   subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 59 59.

Definition _set_TLBEntryHiReg_CLGU
(r_ref : register_ref regstate register_value TLBEntryHiReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 59 59
            (subrange_vec_dec v 0 0)) ]}
      : TLBEntryHiReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryHiReg_CLGU (v : TLBEntryHiReg) (x : mword 1) : TLBEntryHiReg :=
   {[ v with
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 59 59
          (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntryHiReg_VPN2 (v : TLBEntryHiReg) : mword 27 :=
   subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 39 13.

Definition _set_TLBEntryHiReg_VPN2
(r_ref : register_ref regstate register_value TLBEntryHiReg) (v : mword 27)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 39 13
            (subrange_vec_dec v 26 0)) ]}
      : TLBEntryHiReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryHiReg_VPN2 (v : TLBEntryHiReg) (x : mword 27) : TLBEntryHiReg :=
   {[ v with
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 39 13
          (subrange_vec_dec x 26 0)) ]}.

Definition _get_TLBEntryHiReg_ASID (v : TLBEntryHiReg) : mword 8 :=
   subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 7 0.

Definition _set_TLBEntryHiReg_ASID
(r_ref : register_ref regstate register_value TLBEntryHiReg) (v : mword 8)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 7 0
            (subrange_vec_dec v 7 0)) ]}
      : TLBEntryHiReg in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntryHiReg_ASID (v : TLBEntryHiReg) (x : mword 8) : TLBEntryHiReg :=
   {[ v with
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntryHiReg_TLBEntryHiReg_chunk_0) 7 0 (subrange_vec_dec x 7 0)) ]}.

Definition undefined_ContextReg '(tt : unit) : M (ContextReg) :=
   (undefined_bitvector 64) >>= fun w__0 : mword 64 =>
   returnm ({| ContextReg_ContextReg_chunk_0 := w__0 |}).

Definition Mk_ContextReg (v : mword 64) : ContextReg :=
   {| ContextReg_ContextReg_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_ContextReg_bits (v : ContextReg) : mword 64 :=
   subrange_vec_dec v.(ContextReg_ContextReg_chunk_0) 63 0.

Definition _set_ContextReg_bits
(r_ref : register_ref regstate register_value ContextReg) (v : mword 64)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       ContextReg_ContextReg_chunk_0 :=
         (update_subrange_vec_dec r.(ContextReg_ContextReg_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : ContextReg in
   write_reg r_ref r
    : M (unit).

Definition _update_ContextReg_bits (v : ContextReg) (x : mword 64) : ContextReg :=
   {[ v with
     ContextReg_ContextReg_chunk_0 :=
       (update_subrange_vec_dec v.(ContextReg_ContextReg_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_ContextReg_PTEBase (v : ContextReg) : mword 41 :=
   subrange_vec_dec v.(ContextReg_ContextReg_chunk_0) 63 23.

Definition _set_ContextReg_PTEBase
(r_ref : register_ref regstate register_value ContextReg) (v : mword 41)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       ContextReg_ContextReg_chunk_0 :=
         (update_subrange_vec_dec r.(ContextReg_ContextReg_chunk_0) 63 23 (subrange_vec_dec v 40 0)) ]}
      : ContextReg in
   write_reg r_ref r
    : M (unit).

Definition _update_ContextReg_PTEBase (v : ContextReg) (x : mword 41) : ContextReg :=
   {[ v with
     ContextReg_ContextReg_chunk_0 :=
       (update_subrange_vec_dec v.(ContextReg_ContextReg_chunk_0) 63 23 (subrange_vec_dec x 40 0)) ]}.

Definition _get_ContextReg_BadVPN2 (v : ContextReg) : mword 19 :=
   subrange_vec_dec v.(ContextReg_ContextReg_chunk_0) 22 4.

Definition _set_ContextReg_BadVPN2
(r_ref : register_ref regstate register_value ContextReg) (v : mword 19)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       ContextReg_ContextReg_chunk_0 :=
         (update_subrange_vec_dec r.(ContextReg_ContextReg_chunk_0) 22 4 (subrange_vec_dec v 18 0)) ]}
      : ContextReg in
   write_reg r_ref r
    : M (unit).

Definition _update_ContextReg_BadVPN2 (v : ContextReg) (x : mword 19) : ContextReg :=
   {[ v with
     ContextReg_ContextReg_chunk_0 :=
       (update_subrange_vec_dec v.(ContextReg_ContextReg_chunk_0) 22 4 (subrange_vec_dec x 18 0)) ]}.

Definition undefined_XContextReg '(tt : unit) : M (XContextReg) :=
   (undefined_bitvector 64) >>= fun w__0 : mword 64 =>
   returnm ({| XContextReg_XContextReg_chunk_0 := w__0 |}).

Definition Mk_XContextReg (v : mword 64) : XContextReg :=
   {| XContextReg_XContextReg_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_XContextReg_bits (v : XContextReg) : mword 64 :=
   subrange_vec_dec v.(XContextReg_XContextReg_chunk_0) 63 0.

Definition _set_XContextReg_bits
(r_ref : register_ref regstate register_value XContextReg) (v : mword 64)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       XContextReg_XContextReg_chunk_0 :=
         (update_subrange_vec_dec r.(XContextReg_XContextReg_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : XContextReg in
   write_reg r_ref r
    : M (unit).

Definition _update_XContextReg_bits (v : XContextReg) (x : mword 64) : XContextReg :=
   {[ v with
     XContextReg_XContextReg_chunk_0 :=
       (update_subrange_vec_dec v.(XContextReg_XContextReg_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_XContextReg_XPTEBase (v : XContextReg) : mword 31 :=
   subrange_vec_dec v.(XContextReg_XContextReg_chunk_0) 63 33.

Definition _set_XContextReg_XPTEBase
(r_ref : register_ref regstate register_value XContextReg) (v : mword 31)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       XContextReg_XContextReg_chunk_0 :=
         (update_subrange_vec_dec r.(XContextReg_XContextReg_chunk_0) 63 33
            (subrange_vec_dec v 30 0)) ]}
      : XContextReg in
   write_reg r_ref r
    : M (unit).

Definition _update_XContextReg_XPTEBase (v : XContextReg) (x : mword 31) : XContextReg :=
   {[ v with
     XContextReg_XContextReg_chunk_0 :=
       (update_subrange_vec_dec v.(XContextReg_XContextReg_chunk_0) 63 33 (subrange_vec_dec x 30 0)) ]}.

Definition _get_XContextReg_XR (v : XContextReg) : mword 2 :=
   subrange_vec_dec v.(XContextReg_XContextReg_chunk_0) 32 31.

Definition _set_XContextReg_XR
(r_ref : register_ref regstate register_value XContextReg) (v : mword 2)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       XContextReg_XContextReg_chunk_0 :=
         (update_subrange_vec_dec r.(XContextReg_XContextReg_chunk_0) 32 31 (subrange_vec_dec v 1 0)) ]}
      : XContextReg in
   write_reg r_ref r
    : M (unit).

Definition _update_XContextReg_XR (v : XContextReg) (x : mword 2) : XContextReg :=
   {[ v with
     XContextReg_XContextReg_chunk_0 :=
       (update_subrange_vec_dec v.(XContextReg_XContextReg_chunk_0) 32 31 (subrange_vec_dec x 1 0)) ]}.

Definition _get_XContextReg_XBadVPN2 (v : XContextReg) : mword 27 :=
   subrange_vec_dec v.(XContextReg_XContextReg_chunk_0) 30 4.

Definition _set_XContextReg_XBadVPN2
(r_ref : register_ref regstate register_value XContextReg) (v : mword 27)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       XContextReg_XContextReg_chunk_0 :=
         (update_subrange_vec_dec r.(XContextReg_XContextReg_chunk_0) 30 4 (subrange_vec_dec v 26 0)) ]}
      : XContextReg in
   write_reg r_ref r
    : M (unit).

Definition _update_XContextReg_XBadVPN2 (v : XContextReg) (x : mword 27) : XContextReg :=
   {[ v with
     XContextReg_XContextReg_chunk_0 :=
       (update_subrange_vec_dec v.(XContextReg_XContextReg_chunk_0) 30 4 (subrange_vec_dec x 26 0)) ]}.

Definition TLBNumEntries := 64.
Hint Unfold TLBNumEntries : sail.
Definition TLBIndexMax : TLBIndexT := 'b"111111"  : mword 6.
Hint Unfold TLBIndexMax : sail.
Definition MAX (n : Z) `{ArithFact (n >=? 0)} : {_retval : Z & ArithFact (_retval =? (2 ^ n - 1))} :=
   build_ex (Z.sub (projT1 (pow2 n)) 1).

Definition MAX_U64 := projT1 (MAX 64).
Hint Unfold MAX_U64 : sail.
Definition MAX_VA := projT1 (MAX 40).
Hint Unfold MAX_VA : sail.
Definition MAX_PA := projT1 (MAX 36).
Hint Unfold MAX_PA : sail.
Definition undefined_TLBEntry '(tt : unit) : M (TLBEntry) :=
   (undefined_bitvector 55) >>= fun w__0 : mword 55 =>
   (undefined_bitvector 64) >>= fun w__1 : mword 64 =>
   returnm ({| TLBEntry_TLBEntry_chunk_1 := w__0;  TLBEntry_TLBEntry_chunk_0 := w__1 |}).

Definition Mk_TLBEntry (v : mword 119) : TLBEntry :=
   {| TLBEntry_TLBEntry_chunk_1 := (subrange_vec_dec v 118 64); 
      TLBEntry_TLBEntry_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_TLBEntry_bits (v : TLBEntry) : mword 119 :=
   concat_vec (subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 54 0)
     (subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 63 0).

Definition _set_TLBEntry_bits
(r_ref : register_ref regstate register_value TLBEntry) (v : mword 119)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_1 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_1) 54 0 (subrange_vec_dec v 118 64)) ]}
      : TLBEntry in
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_bits (v : TLBEntry) (x : mword 119) : TLBEntry :=
   let v :=
     {[ v with
       TLBEntry_TLBEntry_chunk_1 :=
         (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 54 0 (subrange_vec_dec x 118 64)) ]} in
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_TLBEntry_pagemask (v : TLBEntry) : mword 16 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 54 39.

Definition _set_TLBEntry_pagemask
(r_ref : register_ref regstate register_value TLBEntry) (v : mword 16)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_1 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_1) 54 39 (subrange_vec_dec v 15 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_pagemask (v : TLBEntry) (x : mword 16) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_1 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 54 39 (subrange_vec_dec x 15 0)) ]}.

Definition _get_TLBEntry_r (v : TLBEntry) : mword 2 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 38 37.

Definition _set_TLBEntry_r (r_ref : register_ref regstate register_value TLBEntry) (v : mword 2)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_1 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_1) 38 37 (subrange_vec_dec v 1 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_r (v : TLBEntry) (x : mword 2) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_1 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 38 37 (subrange_vec_dec x 1 0)) ]}.

Definition _get_TLBEntry_vpn2 (v : TLBEntry) : mword 27 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 36 10.

Definition _set_TLBEntry_vpn2 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 27)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_1 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_1) 36 10 (subrange_vec_dec v 26 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_vpn2 (v : TLBEntry) (x : mword 27) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_1 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 36 10 (subrange_vec_dec x 26 0)) ]}.

Definition _get_TLBEntry_asid (v : TLBEntry) : mword 8 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 9 2.

Definition _set_TLBEntry_asid (r_ref : register_ref regstate register_value TLBEntry) (v : mword 8)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_1 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_1) 9 2 (subrange_vec_dec v 7 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_asid (v : TLBEntry) (x : mword 8) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_1 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 9 2 (subrange_vec_dec x 7 0)) ]}.

Definition _get_TLBEntry_g (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 1 1.

Definition _set_TLBEntry_g (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_1 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_1) 1 1 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_g (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_1 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_valid (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 0 0.

Definition _set_TLBEntry_valid (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_1 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_1) 0 0 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_valid (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_1 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_1) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_caplg1 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 63 63.

Definition _set_TLBEntry_caplg1
(r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 63 63 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_caplg1 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 63 63 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_caps1 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 62 62.

Definition _set_TLBEntry_caps1 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 62 62 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_caps1 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 62 62 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_capl1 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 61 61.

Definition _set_TLBEntry_capl1 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 61 61 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_capl1 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 61 61 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_pfn1 (v : TLBEntry) : mword 24 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 60 37.

Definition _set_TLBEntry_pfn1 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 24)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 60 37 (subrange_vec_dec v 23 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_pfn1 (v : TLBEntry) (x : mword 24) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 60 37 (subrange_vec_dec x 23 0)) ]}.

Definition _get_TLBEntry_c1 (v : TLBEntry) : mword 3 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 36 34.

Definition _set_TLBEntry_c1 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 3)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 36 34 (subrange_vec_dec v 2 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_c1 (v : TLBEntry) (x : mword 3) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 36 34 (subrange_vec_dec x 2 0)) ]}.

Definition _get_TLBEntry_d1 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 33 33.

Definition _set_TLBEntry_d1 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 33 33 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_d1 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 33 33 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_v1 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 32 32.

Definition _set_TLBEntry_v1 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 32 32 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_v1 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 32 32 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_caplg0 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 31 31.

Definition _set_TLBEntry_caplg0
(r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 31 31 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_caplg0 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 31 31 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_caps0 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 30 30.

Definition _set_TLBEntry_caps0 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 30 30 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_caps0 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 30 30 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_capl0 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 29 29.

Definition _set_TLBEntry_capl0 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 29 29 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_capl0 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 29 29 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_pfn0 (v : TLBEntry) : mword 24 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 28 5.

Definition _set_TLBEntry_pfn0 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 24)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 28 5 (subrange_vec_dec v 23 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_pfn0 (v : TLBEntry) (x : mword 24) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 28 5 (subrange_vec_dec x 23 0)) ]}.

Definition _get_TLBEntry_c0 (v : TLBEntry) : mword 3 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 4 2.

Definition _set_TLBEntry_c0 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 3)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 4 2 (subrange_vec_dec v 2 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_c0 (v : TLBEntry) (x : mword 3) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 4 2 (subrange_vec_dec x 2 0)) ]}.

Definition _get_TLBEntry_d0 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 1 1.

Definition _set_TLBEntry_d0 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_d0 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_TLBEntry_v0 (v : TLBEntry) : mword 1 :=
   subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 0 0.

Definition _set_TLBEntry_v0 (r_ref : register_ref regstate register_value TLBEntry) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       TLBEntry_TLBEntry_chunk_0 :=
         (update_subrange_vec_dec r.(TLBEntry_TLBEntry_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : TLBEntry in
   write_reg r_ref r
    : M (unit).

Definition _update_TLBEntry_v0 (v : TLBEntry) (x : mword 1) : TLBEntry :=
   {[ v with
     TLBEntry_TLBEntry_chunk_0 :=
       (update_subrange_vec_dec v.(TLBEntry_TLBEntry_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition TLBEntries : vec (register_ref regstate register_value TLBEntry) 64 :=
vec_of_list_len [TLBEntry63_ref;TLBEntry62_ref;TLBEntry61_ref;TLBEntry60_ref;TLBEntry59_ref;
                 TLBEntry58_ref;TLBEntry57_ref;TLBEntry56_ref;TLBEntry55_ref;TLBEntry54_ref;
                 TLBEntry53_ref;TLBEntry52_ref;TLBEntry51_ref;TLBEntry50_ref;TLBEntry49_ref;
                 TLBEntry48_ref;TLBEntry47_ref;TLBEntry46_ref;TLBEntry45_ref;TLBEntry44_ref;
                 TLBEntry43_ref;TLBEntry42_ref;TLBEntry41_ref;TLBEntry40_ref;TLBEntry39_ref;
                 TLBEntry38_ref;TLBEntry37_ref;TLBEntry36_ref;TLBEntry35_ref;TLBEntry34_ref;
                 TLBEntry33_ref;TLBEntry32_ref;TLBEntry31_ref;TLBEntry30_ref;TLBEntry29_ref;
                 TLBEntry28_ref;TLBEntry27_ref;TLBEntry26_ref;TLBEntry25_ref;TLBEntry24_ref;
                 TLBEntry23_ref;TLBEntry22_ref;TLBEntry21_ref;TLBEntry20_ref;TLBEntry19_ref;
                 TLBEntry18_ref;TLBEntry17_ref;TLBEntry16_ref;TLBEntry15_ref;TLBEntry14_ref;
                 TLBEntry13_ref;TLBEntry12_ref;TLBEntry11_ref;TLBEntry10_ref;TLBEntry09_ref;
                 TLBEntry08_ref;TLBEntry07_ref;TLBEntry06_ref;TLBEntry05_ref;TLBEntry04_ref;
                 TLBEntry03_ref;TLBEntry02_ref;TLBEntry01_ref;TLBEntry00_ref].
Hint Unfold TLBEntries : sail.
Definition undefined_StatusReg '(tt : unit) : M (StatusReg) :=
   (undefined_bitvector 32) >>= fun w__0 : mword 32 =>
   returnm ({| StatusReg_StatusReg_chunk_0 := w__0 |}).

Definition Mk_StatusReg (v : mword 32) : StatusReg :=
   {| StatusReg_StatusReg_chunk_0 := (subrange_vec_dec v 31 0) |}.

Definition _get_StatusReg_bits (v : StatusReg) : mword 32 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 31 0.

Definition _set_StatusReg_bits
(r_ref : register_ref regstate register_value StatusReg) (v : mword 32)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 31 0 (subrange_vec_dec v 31 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_bits (v : StatusReg) (x : mword 32) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 31 0 (subrange_vec_dec x 31 0)) ]}.

Definition _get_StatusReg_CU (v : StatusReg) : mword 4 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 31 28.

Definition _set_StatusReg_CU (r_ref : register_ref regstate register_value StatusReg) (v : mword 4)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 31 28 (subrange_vec_dec v 3 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_CU (v : StatusReg) (x : mword 4) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 31 28 (subrange_vec_dec x 3 0)) ]}.

Definition _get_StatusReg_BEV (v : StatusReg) : mword 1 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 22 22.

Definition _set_StatusReg_BEV (r_ref : register_ref regstate register_value StatusReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 22 22 (subrange_vec_dec v 0 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_BEV (v : StatusReg) (x : mword 1) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 22 22 (subrange_vec_dec x 0 0)) ]}.

Definition _get_StatusReg_IM (v : StatusReg) : mword 8 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 15 8.

Definition _set_StatusReg_IM (r_ref : register_ref regstate register_value StatusReg) (v : mword 8)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 15 8 (subrange_vec_dec v 7 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_IM (v : StatusReg) (x : mword 8) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 15 8 (subrange_vec_dec x 7 0)) ]}.

Definition _get_StatusReg_KX (v : StatusReg) : mword 1 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 7 7.

Definition _set_StatusReg_KX (r_ref : register_ref regstate register_value StatusReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 7 7 (subrange_vec_dec v 0 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_KX (v : StatusReg) (x : mword 1) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 7 7 (subrange_vec_dec x 0 0)) ]}.

Definition _get_StatusReg_SX (v : StatusReg) : mword 1 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 6 6.

Definition _set_StatusReg_SX (r_ref : register_ref regstate register_value StatusReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 6 6 (subrange_vec_dec v 0 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_SX (v : StatusReg) (x : mword 1) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 6 6 (subrange_vec_dec x 0 0)) ]}.

Definition _get_StatusReg_UX (v : StatusReg) : mword 1 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 5 5.

Definition _set_StatusReg_UX (r_ref : register_ref regstate register_value StatusReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 5 5 (subrange_vec_dec v 0 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_UX (v : StatusReg) (x : mword 1) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 5 5 (subrange_vec_dec x 0 0)) ]}.

Definition _get_StatusReg_KSU (v : StatusReg) : mword 2 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 4 3.

Definition _set_StatusReg_KSU (r_ref : register_ref regstate register_value StatusReg) (v : mword 2)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 4 3 (subrange_vec_dec v 1 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_KSU (v : StatusReg) (x : mword 2) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 4 3 (subrange_vec_dec x 1 0)) ]}.

Definition _get_StatusReg_ERL (v : StatusReg) : mword 1 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 2 2.

Definition _set_StatusReg_ERL (r_ref : register_ref regstate register_value StatusReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 2 2 (subrange_vec_dec v 0 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_ERL (v : StatusReg) (x : mword 1) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 2 2 (subrange_vec_dec x 0 0)) ]}.

Definition _get_StatusReg_EXL (v : StatusReg) : mword 1 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 1 1.

Definition _set_StatusReg_EXL (r_ref : register_ref regstate register_value StatusReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_EXL (v : StatusReg) (x : mword 1) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_StatusReg_IE (v : StatusReg) : mword 1 :=
   subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 0 0.

Definition _set_StatusReg_IE (r_ref : register_ref regstate register_value StatusReg) (v : mword 1)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       StatusReg_StatusReg_chunk_0 :=
         (update_subrange_vec_dec r.(StatusReg_StatusReg_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : StatusReg in
   write_reg r_ref r
    : M (unit).

Definition _update_StatusReg_IE (v : StatusReg) (x : mword 1) : StatusReg :=
   {[ v with
     StatusReg_StatusReg_chunk_0 :=
       (update_subrange_vec_dec v.(StatusReg_StatusReg_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition execute_branch_mips (pc : mword 64) : M (unit) :=
   write_reg DelayedPC_ref pc >>
   write_reg BranchPending_ref ('b"1"  : mword 1) >>
   write_reg NextInBranchDelay_ref ('b"1"  : mword 1)
    : M (unit).

Definition NotWordVal (word : mword 64) : bool :=
   neq_vec (zopz0zQzQ (cast_unit_vec (access_vec_dec word 31)) 32) (subrange_vec_dec word 63 32).

Definition rGPR (idx : mword 5) : M (mword 64) :=
   let i := projT1 (uint idx) in
   (if sumbool_of_bool (Z.eqb i 0) then returnm (Ox"0000000000000000"  : mword 64)
    else read_reg GPR_ref >>= fun w__0 : vec (mword 64) 32 => returnm (vec_access_dec w__0 i))
    : M (mword 64).

Definition wGPR (idx : mword 5) (v : mword 64) : M (unit) :=
   let i := projT1 (uint idx) in
   (if sumbool_of_bool (projT1 (neq_int i 0)) then
      let '_ :=
        (if sumbool_of_bool trace then
           let '_ := (prerr (string_of_int i))  : unit in
           prerr_bits " <- " v
         else tt)
         : unit in
      read_reg GPR_ref >>= fun w__0 : vec (mword 64) 32 =>
      write_reg GPR_ref (vec_update_dec w__0 i v)
       : M (unit)
    else returnm tt)
    : M (unit).















Definition Exception_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 18))} : Exception :=
   let l__140 := arg_ in
   if sumbool_of_bool (Z.eqb l__140 0) then Interrupt
   else if sumbool_of_bool (Z.eqb l__140 1) then TLBMod
   else if sumbool_of_bool (Z.eqb l__140 2) then TLBL
   else if sumbool_of_bool (Z.eqb l__140 3) then TLBS
   else if sumbool_of_bool (Z.eqb l__140 4) then AdEL
   else if sumbool_of_bool (Z.eqb l__140 5) then AdES
   else if sumbool_of_bool (Z.eqb l__140 6) then Sys
   else if sumbool_of_bool (Z.eqb l__140 7) then Bp
   else if sumbool_of_bool (Z.eqb l__140 8) then ResI
   else if sumbool_of_bool (Z.eqb l__140 9) then CpU
   else if sumbool_of_bool (Z.eqb l__140 10) then Ov
   else if sumbool_of_bool (Z.eqb l__140 11) then Tr
   else if sumbool_of_bool (Z.eqb l__140 12) then C2E
   else if sumbool_of_bool (Z.eqb l__140 13) then C2Trap
   else if sumbool_of_bool (Z.eqb l__140 14) then XTLBRefillL
   else if sumbool_of_bool (Z.eqb l__140 15) then XTLBRefillS
   else if sumbool_of_bool (Z.eqb l__140 16) then XTLBInvL
   else if sumbool_of_bool (Z.eqb l__140 17) then XTLBInvS
   else MCheck.

Definition num_of_Exception (arg_ : Exception) : {e : Z & ArithFact ((0 <=? e) && (e <=? 18))} :=
   build_ex (
      match arg_ with
      | Interrupt => 0
      | TLBMod => 1
      | TLBL => 2
      | TLBS => 3
      | AdEL => 4
      | AdES => 5
      | Sys => 6
      | Bp => 7
      | ResI => 8
      | CpU => 9
      | Ov => 10
      | Tr => 11
      | C2E => 12
      | C2Trap => 13
      | XTLBRefillL => 14
      | XTLBRefillS => 15
      | XTLBInvL => 16
      | XTLBInvS => 17
      | MCheck => 18
      end
   ).

Definition undefined_Exception '(tt : unit) : M (Exception) :=
   (internal_pick
      [Interrupt;
      TLBMod;
      TLBL;
      TLBS;
      AdEL;
      AdES;
      Sys;
      Bp;
      ResI;
      CpU;
      Ov;
      Tr;
      C2E;
      C2Trap;
      XTLBRefillL;
      XTLBRefillS;
      XTLBInvL;
      XTLBInvS;
      MCheck])
    : M (Exception).

Definition ExceptionCode (ex : Exception) : mword 5 :=
   let x : bits 8 :=
     match ex with
     | Interrupt => Ox"00"  : mword 8
     | TLBMod => Ox"01"  : mword 8
     | TLBL => Ox"02"  : mword 8
     | TLBS => Ox"03"  : mword 8
     | AdEL => Ox"04"  : mword 8
     | AdES => Ox"05"  : mword 8
     | Sys => Ox"08"  : mword 8
     | Bp => Ox"09"  : mword 8
     | ResI => Ox"0A"  : mword 8
     | CpU => Ox"0B"  : mword 8
     | Ov => Ox"0C"  : mword 8
     | Tr => Ox"0D"  : mword 8
     | C2E => Ox"12"  : mword 8
     | C2Trap => Ox"12"  : mword 8
     | XTLBRefillL => Ox"02"  : mword 8
     | XTLBRefillS => Ox"03"  : mword 8
     | XTLBInvL => Ox"02"  : mword 8
     | XTLBInvS => Ox"03"  : mword 8
     | MCheck => Ox"18"  : mword 8
     end in
   subrange_vec_dec x 4 0.

Definition string_of_exception (ex : Exception) : string :=
   match ex with
   | Interrupt => "Interrupt"
   | TLBMod => "TLBMod"
   | TLBL => "TLBL"
   | TLBS => "TLBS"
   | AdEL => "AdEL"
   | AdES => "AdES"
   | Sys => "Sys"
   | Bp => "Bp  "
   | ResI => "ResI"
   | CpU => "CpU"
   | Ov => "Ov"
   | Tr => "Tr"
   | C2E => "C2E"
   | C2Trap => "C2Trap"
   | XTLBRefillL => "XTLBRefillL"
   | XTLBRefillS => "XTLBRefillS"
   | XTLBInvL => "XTLBInvL"
   | XTLBInvS => "XTLBInvS"
   | MCheck => "MCheck"
   end.

Definition traceException (ex : Exception) : unit :=
   if sumbool_of_bool trace then
     let '_ := (prerr " EXCEPTION ")  : unit in
     prerr_endline (string_of_exception ex)
   else tt.

Definition exceptionVectorOffset (ex : Exception) : M (mword 12) :=
   read_reg CP0Status_ref >>= fun w__0 : StatusReg =>
   returnm (if (bits_to_bool (_get_StatusReg_EXL w__0))  : bool then Ox"180"  : mword 12
            else if orb (generic_eq ex XTLBRefillL) (generic_eq ex XTLBRefillS) then
              Ox"080"
               : mword 12
            else if generic_eq ex C2Trap then Ox"280"  : mword 12
            else Ox"180"  : mword 12).

Definition exceptionVectorBase '(tt : unit) : M (mword 64) :=
   read_reg CP0Status_ref >>= fun w__0 : StatusReg =>
   returnm (if (bits_to_bool (_get_StatusReg_BEV w__0))  : bool then
              Ox"FFFFFFFFBFC00200"
               : mword 64
            else Ox"FFFFFFFF80000000"  : mword 64).

Definition updateBadInstr '(tt : unit) : M (unit) :=
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bit_to_bool (access_vec_dec w__0 0))  : bool then
      ((read_reg LastInstrBits_ref)  : M (mword 32)) >>= fun w__1 : mword 32 =>
      write_reg CP0BadInstrP_ref w__1
       : M (unit)
    else returnm tt) >>
   ((read_reg CurrentInstrBits_ref)  : M (mword 32)) >>= fun w__2 : mword 32 =>
   write_reg CP0BadInstr_ref w__2
    : M (unit).

Definition undefined_Capability '(tt : unit) : M (Capability) :=
   (undefined_bool tt) >>= fun w__0 : bool =>
   (undefined_bitvector 8) >>= fun w__1 : mword 8 =>
   (undefined_bitvector 24) >>= fun w__2 : mword 24 =>
   (undefined_bitvector 16) >>= fun w__3 : mword 16 =>
   (undefined_bitvector 3) >>= fun w__4 : mword 3 =>
   (undefined_bool tt) >>= fun w__5 : bool =>
   (undefined_bool tt) >>= fun w__6 : bool =>
   (undefined_bool tt) >>= fun w__7 : bool =>
   (undefined_bool tt) >>= fun w__8 : bool =>
   (undefined_bool tt) >>= fun w__9 : bool =>
   (undefined_bool tt) >>= fun w__10 : bool =>
   (undefined_bool tt) >>= fun w__11 : bool =>
   (undefined_bool tt) >>= fun w__12 : bool =>
   (undefined_bool tt) >>= fun w__13 : bool =>
   (undefined_bool tt) >>= fun w__14 : bool =>
   (undefined_bool tt) >>= fun w__15 : bool =>
   (undefined_bool tt) >>= fun w__16 : bool =>
   (undefined_bool tt) >>= fun w__17 : bool =>
   (undefined_bitvector 64) >>= fun w__18 : mword 64 =>
   (undefined_bitvector 64) >>= fun w__19 : mword 64 =>
   (undefined_bitvector 64) >>= fun w__20 : mword 64 =>
   returnm ({| Capability_tag := w__0; 
               Capability_padding := w__1; 
               Capability_otype := w__2; 
               Capability_uperms := w__3; 
               Capability_perm_reserved12_14 := w__4; 
               Capability_permit_set_CID := w__5; 
               Capability_access_system_regs := w__6; 
               Capability_permit_unseal := w__7; 
               Capability_permit_ccall := w__8; 
               Capability_permit_seal := w__9; 
               Capability_permit_store_local_cap := w__10; 
               Capability_permit_store_cap := w__11; 
               Capability_permit_load_cap := w__12; 
               Capability_permit_store := w__13; 
               Capability_permit_load := w__14; 
               Capability_permit_execute := w__15; 
               Capability_global := w__16; 
               Capability_sealed := w__17; 
               Capability_address := w__18; 
               Capability_base := w__19; 
               Capability_length := w__20 |}).

Definition getCapBase (c : Capability)
: {rangevar : Z & ArithFact ((0 <=? rangevar) && (rangevar <=? (2 ^ 64 - 1)))} :=
   build_ex (projT1 (uint c.(Capability_base))).

Definition setCapOffset (c : Capability) (offset : mword 64) : (bool * Capability) :=
   (true, {[ c with Capability_address := (add_vec c.(Capability_base) offset) ]}).

Definition set_next_pcc (newPCC : Capability) : M (unit) :=
   write_reg NextPCC_ref newPCC >> write_reg DelayedPCC_ref newPCC  : M (unit).

Definition unrepCap (cap : Capability) : Capability := {[ cap with Capability_tag := false ]}.

Definition SignalException {o : Type} (ex : Exception) : M (o) :=
   let '_ := (traceException ex)  : unit in
   read_reg CP0Status_ref >>= fun w__0 : StatusReg =>
   (if negb (bits_to_bool (_get_StatusReg_EXL w__0)) then
      ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__1 : mword 1 =>
      (if (bit_to_bool (access_vec_dec w__1 0))  : bool then
         (_set_CauseReg_BD CP0Cause_ref ('b"1"  : mword 1)) >>
         ((read_reg PC_ref)  : M (mword 64)) >>= fun w__2 : mword 64 => returnm (sub_vec_int w__2 4)
       else
         (_set_CauseReg_BD CP0Cause_ref ('b"0"  : mword 1)) >>
         ((read_reg PC_ref)  : M (mword 64))
          : M (mword 64)) >>= fun epc : bits 64 =>
      read_reg PCC_ref >>= fun w__4 : Capability =>
      let '(representable, newEPCC) := setCapOffset w__4 epc in
      let '_ :=
        (if sumbool_of_bool (negb representable) then print_endline "UNREPRESENTABLE EPCC!"
         else tt)
         : unit in
      let '_ := (if newEPCC.(Capability_sealed) then print_endline "SEALED PCC!" else tt)  : unit in
      write_reg
        EPCC_ref
        (if sumbool_of_bool (andb representable (negb newEPCC.(Capability_sealed))) then newEPCC
         else unrepCap newEPCC)
       : M (unit)
    else returnm tt) >>
   (updateBadInstr tt) >>
   (exceptionVectorOffset ex) >>= fun vectorOffset =>
   (exceptionVectorBase tt) >>= fun vectorBase =>
   read_reg KCC_ref >>= fun w__5 : Capability =>
   let kccBase := projT1 (getCapBase w__5) in
   write_reg
     NextPC_ref
     (sub_vec (add_vec vectorBase (mips_zero_extend 64 vectorOffset)) (to_bits 64 kccBase)) >>
   read_reg KCC_ref >>= fun w__6 : Capability =>
   (set_next_pcc w__6) >>
   (_set_CauseReg_ExcCode CP0Cause_ref (ExceptionCode ex)) >>
   (_set_StatusReg_EXL CP0Status_ref ('b"1"  : mword 1)) >> throw (ISAException tt).

Definition SignalExceptionBadAddr {o : Type} (ex : Exception) (badAddr : mword 64) : M (o) :=
   write_reg CP0BadVAddr_ref badAddr >> (SignalException ex)  : M (o).

Definition SignalExceptionTLB {o : Type} (ex : Exception) (badAddr : mword 64) : M (o) :=
   write_reg CP0BadVAddr_ref badAddr >>
   (_set_ContextReg_BadVPN2 TLBContext_ref (subrange_vec_dec badAddr 31 13)) >>
   (_set_XContextReg_XBadVPN2 TLBXContext_ref (subrange_vec_dec badAddr 39 13)) >>
   (_set_XContextReg_XR TLBXContext_ref (subrange_vec_dec badAddr 63 62)) >>
   (_set_TLBEntryHiReg_R TLBEntryHi_ref (subrange_vec_dec badAddr 63 62)) >>
   (_set_TLBEntryHiReg_VPN2 TLBEntryHi_ref (subrange_vec_dec badAddr 39 13)) >>
   (SignalException ex)
    : M (o).

Definition MemAccessType_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 2))}
: MemAccessType :=
   let l__138 := arg_ in
   if sumbool_of_bool (Z.eqb l__138 0) then Instruction
   else if sumbool_of_bool (Z.eqb l__138 1) then LoadData
   else StoreData.

Definition num_of_MemAccessType (arg_ : MemAccessType)
: {e : Z & ArithFact ((0 <=? e) && (e <=? 2))} :=
   build_ex (match arg_ with | Instruction => 0 | LoadData => 1 | StoreData => 2 end).

Definition undefined_MemAccessType '(tt : unit) : M (MemAccessType) :=
   (internal_pick [Instruction; LoadData; StoreData])  : M (MemAccessType).

Definition MemAccessCapRestriction_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 2))}
: MemAccessCapRestriction :=
   let l__136 := arg_ in
   if sumbool_of_bool (Z.eqb l__136 0) then Unrestricted
   else if sumbool_of_bool (Z.eqb l__136 1) then Trap
   else Clear.

Definition num_of_MemAccessCapRestriction (arg_ : MemAccessCapRestriction)
: {e : Z & ArithFact ((0 <=? e) && (e <=? 2))} :=
   build_ex (match arg_ with | Unrestricted => 0 | Trap => 1 | Clear => 2 end).

Definition undefined_MemAccessCapRestriction '(tt : unit) : M (MemAccessCapRestriction) :=
   (internal_pick [Unrestricted; Trap; Clear])  : M (MemAccessCapRestriction).

Definition AccessLevel_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 2))} : AccessLevel :=
   let l__134 := arg_ in
   if sumbool_of_bool (Z.eqb l__134 0) then User
   else if sumbool_of_bool (Z.eqb l__134 1) then Supervisor
   else Kernel.

Definition num_of_AccessLevel (arg_ : AccessLevel) : {e : Z & ArithFact ((0 <=? e) && (e <=? 2))} :=
   build_ex (match arg_ with | User => 0 | Supervisor => 1 | Kernel => 2 end).

Definition undefined_AccessLevel '(tt : unit) : M (AccessLevel) :=
   (internal_pick [User; Supervisor; Kernel])  : M (AccessLevel).

Definition int_of_AccessLevel (level : AccessLevel)
: {n : Z & ArithFact (member_Z_list n [0; 1; 2])} :=
   build_ex (match level with | User => 0 | Supervisor => 1 | Kernel => 2 end).

Definition grantsAccess (currentLevel : AccessLevel) (requiredLevel : AccessLevel) : bool :=
   Z.geb (projT1 (int_of_AccessLevel currentLevel)) (projT1 (int_of_AccessLevel requiredLevel)).

Definition getAccessLevel '(tt : unit) : M (AccessLevel) :=
   (or_boolM
      (read_reg CP0Status_ref >>= fun w__0 : StatusReg =>
       returnm ((bits_to_bool (_get_StatusReg_EXL w__0))  : bool))
      (read_reg CP0Status_ref >>= fun w__1 : StatusReg =>
       returnm ((bits_to_bool (_get_StatusReg_ERL w__1))  : bool))) >>= fun w__2 : bool =>
   (if sumbool_of_bool w__2 then returnm Kernel
    else
      read_reg CP0Status_ref >>= fun w__3 : StatusReg =>
      let p__158 := _get_StatusReg_KSU w__3 in
      let b__0 := p__158 in
      returnm (if eq_vec b__0 ('b"00"  : mword 2) then Kernel
               else if eq_vec b__0 ('b"01"  : mword 2) then Supervisor
               else if eq_vec b__0 ('b"10"  : mword 2) then User
               else User))
    : M (AccessLevel).

Definition pcc_access_system_regs '(tt : unit) : M (bool) :=
   read_reg PCC_ref >>= fun w__0 : Capability => returnm w__0.(Capability_access_system_regs).

Definition undefined_CapCauseReg '(tt : unit) : M (CapCauseReg) :=
   (undefined_bitvector 16) >>= fun w__0 : mword 16 =>
   returnm ({| CapCauseReg_CapCauseReg_chunk_0 := w__0 |}).

Definition CapExCode (ex : CapEx) : mword 8 :=
   match ex with
   | CapEx_None => Ox"00"  : mword 8
   | CapEx_LengthViolation => Ox"01"  : mword 8
   | CapEx_TagViolation => Ox"02"  : mword 8
   | CapEx_SealViolation => Ox"03"  : mword 8
   | CapEx_TypeViolation => Ox"04"  : mword 8
   | CapEx_CallTrap => Ox"05"  : mword 8
   | CapEx_ReturnTrap => Ox"06"  : mword 8
   | CapEx_TSSUnderFlow => Ox"07"  : mword 8
   | CapEx_UserDefViolation => Ox"08"  : mword 8
   | CapEx_TLBNoStoreCap => Ox"09"  : mword 8
   | CapEx_InexactBounds => Ox"0A"  : mword 8
   | CapEx_TLBLoadCap => Ox"0C"  : mword 8
   | CapEx_GlobalViolation => Ox"10"  : mword 8
   | CapEx_PermitExecuteViolation => Ox"11"  : mword 8
   | CapEx_PermitLoadViolation => Ox"12"  : mword 8
   | CapEx_PermitStoreViolation => Ox"13"  : mword 8
   | CapEx_PermitLoadCapViolation => Ox"14"  : mword 8
   | CapEx_PermitStoreCapViolation => Ox"15"  : mword 8
   | CapEx_PermitStoreLocalCapViolation => Ox"16"  : mword 8
   | CapEx_PermitSealViolation => Ox"17"  : mword 8
   | CapEx_AccessSystemRegsViolation => Ox"18"  : mword 8
   | CapEx_PermitCCallViolation => Ox"19"  : mword 8
   | CapEx_AccessCCallIDCViolation => Ox"1A"  : mword 8
   | CapEx_PermitUnsealViolation => Ox"1B"  : mword 8
   | CapEx_PermitSetCIDViolation => Ox"1C"  : mword 8
   end.

Definition _set_CapCauseReg_ExcCode
(r_ref : register_ref regstate register_value CapCauseReg) (v : mword 8)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CapCauseReg_CapCauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CapCauseReg_CapCauseReg_chunk_0) 15 8 (subrange_vec_dec v 7 0)) ]}
      : CapCauseReg in
   write_reg r_ref r
    : M (unit).

Definition _set_CapCauseReg_RegNum
(r_ref : register_ref regstate register_value CapCauseReg) (v : mword 8)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CapCauseReg_CapCauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CapCauseReg_CapCauseReg_chunk_0) 7 0 (subrange_vec_dec v 7 0)) ]}
      : CapCauseReg in
   write_reg r_ref r
    : M (unit).

Definition string_of_capex (ex : CapEx) : string :=
   match ex with
   | CapEx_None => "None"
   | CapEx_LengthViolation => "LengthViolation"
   | CapEx_TagViolation => "TagViolation"
   | CapEx_SealViolation => "SealViolation"
   | CapEx_TypeViolation => "TypeViolation"
   | CapEx_CallTrap => "CallTrap"
   | CapEx_ReturnTrap => "ReturnTrap"
   | CapEx_TSSUnderFlow => "TSSUnderFlow"
   | CapEx_UserDefViolation => "UserDefViolation"
   | CapEx_TLBNoStoreCap => "TLBNoStoreCap"
   | CapEx_InexactBounds => "InexactBounds"
   | CapEx_GlobalViolation => "GlobalViolation"
   | CapEx_PermitExecuteViolation => "PermitExecuteViolation"
   | CapEx_PermitLoadViolation => "PermitLoadViolation"
   | CapEx_PermitStoreViolation => "PermitStoreViolation"
   | CapEx_PermitLoadCapViolation => "PermitLoadCapViolation"
   | CapEx_PermitStoreCapViolation => "PermitStoreCapViolation"
   | CapEx_PermitStoreLocalCapViolation => "PermitStoreLocalCapViolation"
   | CapEx_PermitSealViolation => "PermitSealViolation"
   | CapEx_AccessSystemRegsViolation => "AccessSystemRegsViolation"
   | CapEx_PermitCCallViolation => "PermitCCallViolation"
   | CapEx_AccessCCallIDCViolation => "AccessCCallIDCViolation"
   | CapEx_PermitUnsealViolation => "PermitUnsealViolation"
   | CapEx_PermitSetCIDViolation => "PermitSetCIDViolation"
   | CapEx_TLBLoadCap => "TLBLoadCap"
   end.

Definition raise_c2_exception8 {o : Type} (capEx : CapEx) (regnum : mword 8) : M (o) :=
   let '_ :=
     (if sumbool_of_bool trace then
        let '_ := (prerr " C2Ex ")  : unit in
        let '_ := (prerr (string_of_capex capEx))  : unit in
        let '_ := (prerr " reg: ")  : unit in
        prerr_endline (string_of_bits regnum)
      else tt)
      : unit in
   (_set_CapCauseReg_ExcCode CapCause_ref (CapExCode capEx)) >>
   (_set_CapCauseReg_RegNum CapCause_ref regnum) >>
   let mipsEx :=
     if orb (generic_eq capEx CapEx_CallTrap) (generic_eq capEx CapEx_ReturnTrap) then C2Trap
     else C2E in
   (SignalException mipsEx)
    : M (o).

Definition raise_c2_exception_noreg {o : Type} (capEx : CapEx) : M (o) :=
   (raise_c2_exception8 capEx (Ox"FF"  : mword 8))  : M (o).

Definition checkCP0AccessHook '(tt : unit) : M (unit) :=
   (pcc_access_system_regs tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (negb w__0) then
      (raise_c2_exception_noreg CapEx_AccessSystemRegsViolation)
       : M (unit)
    else returnm tt)
    : M (unit).

Definition checkCP0Access '(tt : unit) : M (unit) :=
   (getAccessLevel tt) >>= fun accessLevel =>
   (and_boolM (returnm ((generic_neq accessLevel Kernel)  : bool))
      (read_reg CP0Status_ref >>= fun w__0 : StatusReg =>
       returnm ((negb (bit_to_bool (access_vec_dec (_get_StatusReg_CU w__0) 0)))  : bool))) >>= fun w__1 : bool =>
   (if sumbool_of_bool w__1 then
      (_set_CauseReg_CE CP0Cause_ref ('b"00"  : mword 2)) >> (SignalException CpU)  : M (unit)
    else returnm tt) >>
   (checkCP0AccessHook tt)
    : M (unit).

Definition incrementCP0Count '(tt : unit) : M (unit) :=
   ((read_reg TLBRandom_ref)  : M (mword 6)) >>= fun w__0 : mword 6 =>
   ((read_reg TLBWired_ref)  : M (mword 6)) >>= fun w__1 : mword 6 =>
   (if eq_vec w__0 w__1 then returnm TLBIndexMax
    else
      ((read_reg TLBRandom_ref)  : M (mword 6)) >>= fun w__2 : mword 6 =>
      returnm (sub_vec_int w__2 1)) >>= fun w__3 : mword 6 =>
   write_reg TLBRandom_ref w__3 >>
   ((read_reg CP0Count_ref)  : M (mword 32)) >>= fun w__4 : mword 32 =>
   write_reg CP0Count_ref (add_vec_int w__4 1) >>
   ((read_reg CP0Count_ref)  : M (mword 32)) >>= fun w__5 : mword 32 =>
   ((read_reg CP0Compare_ref)  : M (mword 32)) >>= fun w__6 : mword 32 =>
   (if eq_vec w__5 w__6 then
      read_reg CP0Cause_ref >>= fun w__7 : CauseReg =>
      (_set_CauseReg_IP CP0Cause_ref (or_vec (_get_CauseReg_IP w__7) (Ox"80"  : mword 8)))
       : M (unit)
    else returnm tt) >>
   read_reg CP0Status_ref >>= fun w__8 : StatusReg =>
   let ims := _get_StatusReg_IM w__8 in
   read_reg CP0Cause_ref >>= fun w__9 : CauseReg =>
   let ips := _get_CauseReg_IP w__9 in
   read_reg CP0Status_ref >>= fun w__10 : StatusReg =>
   let ie := _get_StatusReg_IE w__10 in
   read_reg CP0Status_ref >>= fun w__11 : StatusReg =>
   let exl := _get_StatusReg_EXL w__11 in
   read_reg CP0Status_ref >>= fun w__12 : StatusReg =>
   let erl := _get_StatusReg_ERL w__12 in
   (if andb (negb (bits_to_bool exl))
         (andb (negb (bits_to_bool erl))
            (andb (bits_to_bool ie) (neq_vec (and_vec ips ims) (Ox"00"  : mword 8)))) then
      (SignalException Interrupt)
       : M (unit)
    else returnm tt)
    : M (unit).

Definition strReg (r : mword 5) : string := concat_str_dec "$" (projT1 (uint r)).

Definition strRRRArgs (r2 : mword 5) (r1 : mword 5) (rd : mword 5) : string :=
   String.append (strReg rd)
     (String.append ", " (String.append (strReg r1) (String.append ", " (strReg r2)))).

Definition strRRIArgs {n : Z} (rs : mword 5) (rd : mword 5) (imm : mword n) `{ArithFact (n >? 0)}
: string :=
   String.append (strReg rd)
     (String.append ", "
        (String.append (strReg rs) (String.append ", " (dec_str (projT1 (sint imm)))))).

Definition strRRIUArgs {n : Z} (rs : mword 5) (rd : mword 5) (imm : mword n) `{ArithFact (n >? 0)}
: string :=
   String.append (strReg rd)
     (String.append ", "
        (String.append (strReg rs) (String.append ", " (hex_str (projT1 (uint imm)))))).

Definition strRIArgs {n : Z} (rd : mword 5) (imm : mword n) `{ArithFact (n >? 0)} : string :=
   String.append (strReg rd) (String.append ", " (hex_str (projT1 (uint imm)))).

Definition strMemArgs {n : Z} (base : mword 5) (rt : mword 5) (offset : mword n)
`{ArithFact (n >? 0)}
: string :=
   String.append (strReg rt)
     (String.append ", "
        (String.append (dec_str (projT1 (sint offset)))
           (String.append "(" (String.append (strReg base) ")")))).

Definition decode_failure_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 3))}
: decode_failure :=
   let l__131 := arg_ in
   if sumbool_of_bool (Z.eqb l__131 0) then no_matching_pattern
   else if sumbool_of_bool (Z.eqb l__131 1) then unsupported_instruction
   else if sumbool_of_bool (Z.eqb l__131 2) then illegal_instruction
   else internal_error.

Definition num_of_decode_failure (arg_ : decode_failure)
: {e : Z & ArithFact ((0 <=? e) && (e <=? 3))} :=
   build_ex (
      match arg_ with
      | no_matching_pattern => 0
      | unsupported_instruction => 1
      | illegal_instruction => 2
      | internal_error => 3
      end
   ).

Definition undefined_decode_failure '(tt : unit) : M (decode_failure) :=
   (internal_pick
      [no_matching_pattern;
      unsupported_instruction;
      illegal_instruction;
      internal_error])
    : M (decode_failure).

Definition Comparison_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 7))} : Comparison :=
   let l__124 := arg_ in
   if sumbool_of_bool (Z.eqb l__124 0) then EQ'
   else if sumbool_of_bool (Z.eqb l__124 1) then NE
   else if sumbool_of_bool (Z.eqb l__124 2) then GE
   else if sumbool_of_bool (Z.eqb l__124 3) then GEU
   else if sumbool_of_bool (Z.eqb l__124 4) then GT'
   else if sumbool_of_bool (Z.eqb l__124 5) then LE
   else if sumbool_of_bool (Z.eqb l__124 6) then LT'
   else LTU.

Definition num_of_Comparison (arg_ : Comparison) : {e : Z & ArithFact ((0 <=? e) && (e <=? 7))} :=
   build_ex (
      match arg_ with
      | EQ' => 0
      | NE => 1
      | GE => 2
      | GEU => 3
      | GT' => 4
      | LE => 5
      | LT' => 6
      | LTU => 7
      end
   ).

Definition undefined_Comparison '(tt : unit) : M (Comparison) :=
   (internal_pick [EQ'; NE; GE; GEU; GT'; LE; LT'; LTU])  : M (Comparison).

Definition strCmp (cmp : Comparison) : string :=
   match cmp with
   | EQ' => "eq"
   | NE => "ne"
   | GE => "ge"
   | GEU => "geu"
   | GT' => "gt"
   | LE => "le"
   | LT' => "lt"
   | LTU => "ltu"
   end.

Definition compare (cmp : Comparison) (valA : mword 64) (valB : mword 64) : bool :=
   match cmp with
   | EQ' => eq_vec valA valB
   | NE => neq_vec valA valB
   | GE => zopz0zKzJ_s valA valB
   | GEU => zopz0zKzJ_u valA valB
   | GT' => zopz0zI_s valB valA
   | LE => zopz0zKzJ_s valB valA
   | LT' => zopz0zI_s valA valB
   | LTU => zopz0zI_u valA valB
   end.

Definition WordType_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 3))} : WordType :=
   let l__121 := arg_ in
   if sumbool_of_bool (Z.eqb l__121 0) then B
   else if sumbool_of_bool (Z.eqb l__121 1) then H
   else if sumbool_of_bool (Z.eqb l__121 2) then W
   else D.

Definition num_of_WordType (arg_ : WordType) : {e : Z & ArithFact ((0 <=? e) && (e <=? 3))} :=
   build_ex (match arg_ with | B => 0 | H => 1 | W => 2 | D => 3 end).

Definition undefined_WordType '(tt : unit) : M (WordType) :=
   (internal_pick [B; H; W; D])  : M (WordType).

Definition WordTypeUnaligned_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 3))}
: WordTypeUnaligned :=
   let l__118 := arg_ in
   if sumbool_of_bool (Z.eqb l__118 0) then WL
   else if sumbool_of_bool (Z.eqb l__118 1) then WR
   else if sumbool_of_bool (Z.eqb l__118 2) then DL
   else DR.

Definition num_of_WordTypeUnaligned (arg_ : WordTypeUnaligned)
: {e : Z & ArithFact ((0 <=? e) && (e <=? 3))} :=
   build_ex (match arg_ with | WL => 0 | WR => 1 | DL => 2 | DR => 3 end).

Definition undefined_WordTypeUnaligned '(tt : unit) : M (WordTypeUnaligned) :=
   (internal_pick [WL; WR; DL; DR])  : M (WordTypeUnaligned).

Definition strWordType (w : WordType) : string :=
   match w with | B => "b" | H => "h" | W => "w" | D => "d" end.

Definition unalignedBytesTouched (vAddr : Z) (width : WordTypeUnaligned) : (Z * Z) :=
   let woffset := projT1 (emod_with_eq vAddr 4) in
   let doffset := projT1 (emod_with_eq vAddr 8) in
   match width with
   | WL => (vAddr, Z.sub 4 woffset)
   | WR => (Z.sub vAddr woffset, Z.add woffset 1)
   | DL => (vAddr, Z.sub 8 doffset)
   | DR => (Z.sub vAddr doffset, Z.add doffset 1)
   end.

Definition wordWidthBytes (w : WordType)
: {rangevar : Z & ArithFact ((1 <=? rangevar) && (rangevar <=? 8))} :=
   build_ex (match w with | B => 1 | H => 2 | W => 4 | D => 8 end).

Definition alignment_width := 16.
Hint Unfold alignment_width : sail.
Definition isAddressAligned (addr : mword 64) (wordType : WordType) : bool :=
   let a := projT1 (uint addr) in
   Z.eqb (projT1 (ediv_with_eq a alignment_width))
     (projT1
      (ediv_with_eq (Z.sub (Z.add a (projT1 (wordWidthBytes wordType))) 1) alignment_width)).

Definition extendLoad {sz : Z} (memResult : mword sz) (sign : bool) `{ArithFact (sz <=? 64)}
: mword 64 :=
   if sumbool_of_bool sign then mips_sign_extend 64 memResult else mips_zero_extend 64 memResult.

Definition MEMr_wrapper (addr : mword 64) (size : Z) `{ArithFact ((1 <=? size) && (size <=? 8))}
: M (mword (8 * size)) :=
   (if eq_vec addr (Ox"000000007F000000"  : mword 64) then
      ((read_reg UART_RVALID_ref)  : M (mword 1)) >>= fun rvalid =>
      write_reg UART_RVALID_ref ('b"0"  : mword 1) >>
      ((read_reg UART_RDATA_ref)  : M (mword 8)) >>= fun w__0 : mword 8 =>
      returnm (mask (Z.mul 8 (projT1 (__id size)))
                 (concat_vec (Ox"00000000"  : mword 32)
                    (concat_vec w__0
                       (concat_vec rvalid
                          (concat_vec ('b"0000000"  : mword 7) (Ox"0000"  : mword 16))))))
    else if eq_vec addr (Ox"000000007F000004"  : mword 64) then
      returnm (mask (Z.mul 8 (projT1 (__id size))) (Ox"000000000004FFFF"  : mword 64))
    else (MEMr addr size) >>= fun w__1 : mword (8 * size) => returnm (reverse_endianness w__1))
    : M (mword (8 * size)).

Definition MEMr_reserve_wrapper (addr : mword 64) (size : Z)
`{ArithFact ((1 <=? size) && (size <=? 8))}
: M (mword (8 * size)) :=
   (MEMr_reserve addr size) >>= fun w__0 : mword (8 * size) => returnm (reverse_endianness w__0).

Definition init_cp0_state '(tt : unit) : M (unit) :=
   (_set_StatusReg_BEV CP0Status_ref ((cast_unit_vec B1)  : mword 1))  : M (unit).

Definition tlbEntryMatch (r : mword 2) (vpn2 : mword 27) (asid : mword 8) (entry : TLBEntry) : bool :=
   let entryValid := _get_TLBEntry_valid entry in
   let entryR := _get_TLBEntry_r entry in
   let entryMask := _get_TLBEntry_pagemask entry in
   let entryVPN := _get_TLBEntry_vpn2 entry in
   let entryASID := _get_TLBEntry_asid entry in
   let entryG := _get_TLBEntry_g entry in
   let vpnMask : bits 27 := not_vec (mips_zero_extend 27 entryMask) in
   andb (bits_to_bool entryValid)
     (andb (eq_vec r entryR)
        (andb (eq_vec (and_vec vpn2 vpnMask) (and_vec entryVPN vpnMask))
           (orb (eq_vec asid entryASID) (bits_to_bool entryG)))).

Definition tlbSearch (VAddr : mword 64) : M (option (mword 6)) :=
   catch_early_return
     (let r := subrange_vec_dec VAddr 63 62 in
     let vpn2 := subrange_vec_dec VAddr 39 13 in
     liftR (read_reg TLBEntryHi_ref) >>= fun w__0 : TLBEntryHiReg =>
     let asid := _get_TLBEntryHiReg_ASID w__0 in
     (let loop_idx_lower := 0 in
     let loop_idx_upper := 63 in
     (foreach_ZM_up loop_idx_lower loop_idx_upper 1 tt
       (fun idx _ _ =>
         liftR ((reg_deref (vec_access_dec TLBEntries idx))) >>= fun w__1 : TLBEntry =>
         (if tlbEntryMatch r vpn2 asid w__1 then
            (early_return ((Some (to_bits 6 idx))  : option (mword 6)) : MR unit (option (mword 6)))
             : MR (unit) _
          else returnm tt)
          : MR (unit) _))) >>
     returnm None).

Definition MIPSSegmentOf (vAddr : mword 64) : M ((AccessLevel * option (mword 64))) :=
   let compat32 :=
     eq_vec (subrange_vec_dec vAddr 61 31)
       ('b"1111111111111111111111111111111"
        : mword (61 - 31 + 1)) in
   let b__0 := subrange_vec_dec vAddr 63 62 in
   (if eq_vec b__0 ('b"11"  : mword (63 - 62 + 1)) then
      returnm (match (compat32, subrange_vec_dec vAddr 30 29) with
               | (true, b__1) =>
                  if eq_vec b__1 ('b"11"  : mword (30 - 29 + 1)) then
                    (Kernel, None
                     : option (bits 64))
                  else if eq_vec b__1 ('b"10"  : mword (30 - 29 + 1)) then
                    (Supervisor, None
                     : option (bits 64))
                  else if eq_vec b__1 ('b"01"  : mword (30 - 29 + 1)) then
                    (Kernel, Some
                               (concat_vec (Ox"00000000"  : mword 32)
                                  (concat_vec ('b"000"  : mword 3) (subrange_vec_dec vAddr 28 0))))
                  else if eq_vec b__1 ('b"00"  : mword (30 - 29 + 1)) then
                    (Kernel, Some
                               (concat_vec (Ox"00000000"  : mword 32)
                                  (concat_vec ('b"000"  : mword 3) (subrange_vec_dec vAddr 28 0))))
                  else match (true, b__1) with | (_, _) => (Kernel, None  : option (bits 64)) end
               | (_, _) => (Kernel, None  : option (bits 64))
               end)
    else if eq_vec b__0 ('b"10"  : mword (63 - 62 + 1)) then
      returnm (Kernel, Some (concat_vec ('b"00000"  : mword 5) (subrange_vec_dec vAddr 58 0)))
    else if eq_vec b__0 ('b"01"  : mword (63 - 62 + 1)) then
      returnm (Supervisor, None  : option (bits 64))
    else if eq_vec b__0 ('b"00"  : mword (63 - 62 + 1)) then
      returnm (User, None  : option (bits 64))
    else
      assert_exp' false "Pattern match failure at ../mips/mips_tlb.sail 64:1 - 75:2" >>= fun _ =>
      exit tt)
    : M ((AccessLevel * option (mword 64))).

Definition TLBTranslate2 (vAddr : mword 64) (accessType : MemAccessType) (accessLevel : AccessLevel)
: M ((mword 64 * MemAccessCapRestriction)) :=
   (tlbSearch vAddr) >>= fun idx =>
   (match idx with
    | Some idx =>
       let i := projT1 (uint idx) in
       (reg_deref (vec_access_dec TLBEntries i)) >>= fun entry =>
       let entryMask := _get_TLBEntry_pagemask entry in
       let b__0 := entryMask in
       (if eq_vec b__0 (Ox"0000"  : mword 16) then returnm (build_ex 12)
        else if eq_vec b__0 (Ox"0003"  : mword 16) then returnm (build_ex 14)
        else if eq_vec b__0 (Ox"000F"  : mword 16) then returnm (build_ex 16)
        else if eq_vec b__0 (Ox"003F"  : mword 16) then returnm (build_ex 18)
        else if eq_vec b__0 (Ox"00FF"  : mword 16) then returnm (build_ex 20)
        else if eq_vec b__0 (Ox"03FF"  : mword 16) then returnm (build_ex 22)
        else if eq_vec b__0 (Ox"0FFF"  : mword 16) then returnm (build_ex 24)
        else if eq_vec b__0 (Ox"3FFF"  : mword 16) then returnm (build_ex 26)
        else if eq_vec b__0 (Ox"FFFF"  : mword 16) then returnm (build_ex 28)
        else
          (undefined_range 12 28)
           : M ({rangevar : Z & ArithFact ((12 <=? rangevar) && (rangevar <=? 28))})) >>= fun '(existT _ evenOddBit _ : {rangevar : Z & ArithFact ((12 <=?
         rangevar) &&
         (rangevar <=? 28))}) =>
       let isOdd := access_vec_dec vAddr evenOddBit in
       let '(caps, caplg, capl, pfn, d, v) :=
         if (bit_to_bool isOdd)  : bool then
           (_get_TLBEntry_caps1 entry, _get_TLBEntry_caplg1 entry, _get_TLBEntry_capl1 entry, _get_TLBEntry_pfn1
                                                                                                entry, _get_TLBEntry_d1
                                                                                                         entry, _get_TLBEntry_v1
                                                                                                                  entry)
         else
           (_get_TLBEntry_caps0 entry, _get_TLBEntry_caplg0 entry, _get_TLBEntry_capl0 entry, _get_TLBEntry_pfn0
                                                                                                entry, _get_TLBEntry_d0
                                                                                                         entry, _get_TLBEntry_v0
                                                                                                                  entry) in
       (if negb (bits_to_bool v) then
          (SignalExceptionTLB (if generic_eq accessType StoreData then XTLBInvS else XTLBInvL) vAddr)
           : M ((mword 64 * MemAccessCapRestriction))
        else if andb (generic_eq accessType StoreData) (negb (bits_to_bool d)) then
          (SignalExceptionTLB TLBMod vAddr)
           : M ((mword 64 * MemAccessCapRestriction))
        else
          let res : bits 64 :=
            mips_zero_extend 64
              (concat_vec (subrange_vec_dec pfn 23 (Z.sub evenOddBit 12))
                 (subrange_vec_dec vAddr (Z.sub evenOddBit 1) 0)) in
          (if generic_eq accessType StoreData then
             returnm (if (bits_to_bool caps)  : bool then Trap else Unrestricted)
           else if (bits_to_bool capl)  : bool then returnm Clear
           else
             (match accessLevel with
              | User =>
                 read_reg TLBEntryHi_ref >>= fun w__11 : TLBEntryHiReg =>
                 returnm (_get_TLBEntryHiReg_CLGU w__11)
              | Supervisor =>
                 read_reg TLBEntryHi_ref >>= fun w__12 : TLBEntryHiReg =>
                 returnm (_get_TLBEntryHiReg_CLGS w__12)
              | Kernel =>
                 read_reg TLBEntryHi_ref >>= fun w__13 : TLBEntryHiReg =>
                 returnm (_get_TLBEntryHiReg_CLGK w__13)
              end) >>= fun gclg : bits 1 =>
             returnm (if neq_bool (bits_to_bool gclg) (bits_to_bool caplg) then Trap
                      else Unrestricted)) >>= fun macr =>
          returnm (res, macr))
        : M ((mword 64 * MemAccessCapRestriction))
    | None =>
       (SignalExceptionTLB (if generic_eq accessType StoreData then XTLBRefillS else XTLBRefillL)
          vAddr)
        : M ((mword 64 * MemAccessCapRestriction))
    end)
    : M ((mword 64 * MemAccessCapRestriction)).

Definition TLBTranslateC (vAddr : mword 64) (accessType : MemAccessType)
: M ((mword 64 * MemAccessCapRestriction)) :=
   (getAccessLevel tt) >>= fun currentAccessLevel =>
   let compat32 :=
     eq_vec (subrange_vec_dec vAddr 61 31)
       ('b"1111111111111111111111111111111"
        : mword (61 - 31 + 1)) in
   (MIPSSegmentOf vAddr) >>= fun '((requiredLevel, addr)
   : (AccessLevel * option (bits 64))) =>
   (if negb (grantsAccess currentAccessLevel requiredLevel) then
      (SignalExceptionBadAddr (if generic_eq accessType StoreData then AdES else AdEL) vAddr)
       : M ((mword 64 * MemAccessCapRestriction))
    else
      (match addr with
       | Some a => returnm (a, Unrestricted)
       | None =>
          (if sumbool_of_bool
             (andb (negb compat32)
                ((Z.gtb (projT1 (uint (subrange_vec_dec vAddr 61 0))) MAX_VA)
                 : bool)) then
             (SignalExceptionBadAddr (if generic_eq accessType StoreData then AdES else AdEL) vAddr)
              : M ((mword 64 * MemAccessCapRestriction))
           else
             (TLBTranslate2 vAddr accessType requiredLevel)
              : M ((mword 64 * MemAccessCapRestriction)))
           : M ((mword 64 * MemAccessCapRestriction))
       end) >>= fun '((pa, c)
      : (bits 64 * MemAccessCapRestriction)) =>
      (if sumbool_of_bool (Z.gtb (projT1 (uint pa)) MAX_PA) then
         (SignalExceptionBadAddr (if generic_eq accessType StoreData then AdES else AdEL) vAddr)
          : M ((mword 64 * MemAccessCapRestriction))
       else returnm (pa, c))
       : M ((mword 64 * MemAccessCapRestriction)))
    : M ((mword 64 * MemAccessCapRestriction)).

Definition TLBTranslate (vAddr : mword 64) (accessType : MemAccessType) : M (mword 64) :=
   (TLBTranslateC vAddr accessType) >>= fun '(addr, c) => returnm addr.

Definition CPtrCmpOp_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 7))} : CPtrCmpOp :=
   let l__111 := arg_ in
   if sumbool_of_bool (Z.eqb l__111 0) then CEQ
   else if sumbool_of_bool (Z.eqb l__111 1) then CNE
   else if sumbool_of_bool (Z.eqb l__111 2) then CLT
   else if sumbool_of_bool (Z.eqb l__111 3) then CLE
   else if sumbool_of_bool (Z.eqb l__111 4) then CLTU
   else if sumbool_of_bool (Z.eqb l__111 5) then CLEU
   else if sumbool_of_bool (Z.eqb l__111 6) then CEXEQ
   else CNEXEQ.

Definition num_of_CPtrCmpOp (arg_ : CPtrCmpOp) : {e : Z & ArithFact ((0 <=? e) && (e <=? 7))} :=
   build_ex (
      match arg_ with
      | CEQ => 0
      | CNE => 1
      | CLT => 2
      | CLE => 3
      | CLTU => 4
      | CLEU => 5
      | CEXEQ => 6
      | CNEXEQ => 7
      end
   ).

Definition undefined_CPtrCmpOp '(tt : unit) : M (CPtrCmpOp) :=
   (internal_pick [CEQ; CNE; CLT; CLE; CLTU; CLEU; CEXEQ; CNEXEQ])  : M (CPtrCmpOp).

Definition ClearRegSet_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 3))} : ClearRegSet :=
   let l__108 := arg_ in
   if sumbool_of_bool (Z.eqb l__108 0) then GPLo
   else if sumbool_of_bool (Z.eqb l__108 1) then GPHi
   else if sumbool_of_bool (Z.eqb l__108 2) then CLo
   else CHi.

Definition num_of_ClearRegSet (arg_ : ClearRegSet) : {e : Z & ArithFact ((0 <=? e) && (e <=? 3))} :=
   build_ex (match arg_ with | GPLo => 0 | GPHi => 1 | CLo => 2 | CHi => 3 end).

Definition undefined_ClearRegSet '(tt : unit) : M (ClearRegSet) :=
   (internal_pick [GPLo; GPHi; CLo; CHi])  : M (ClearRegSet).

Definition num_flags := 1.
Hint Unfold num_flags : sail.
Definition reserved_otypes := 16.
Hint Unfold reserved_otypes : sail.
Definition otype_unsealed := (-1).
Hint Unfold otype_unsealed : sail.
Definition otype_sentry := (-2).
Hint Unfold otype_sentry : sail.
Definition otype_unsealed_bits := to_bits 64 otype_unsealed.
Hint Unfold otype_unsealed_bits : sail.
Definition otype_sentry_bits := to_bits 64 otype_sentry.
Hint Unfold otype_sentry_bits : sail.
Definition max_otype := Z.sub (projT1 (MAX 24)) reserved_otypes.
Hint Unfold max_otype : sail.
Definition null_cap : Capability :=
{| Capability_tag := false; 
   Capability_padding := (zeros_implicit 8 tt); 
   Capability_otype := (ones_implicit 24 tt); 
   Capability_uperms := (zeros_implicit 16 tt); 
   Capability_perm_reserved12_14 := (zeros_implicit 3 tt); 
   Capability_permit_set_CID := false; 
   Capability_access_system_regs := false; 
   Capability_permit_unseal := false; 
   Capability_permit_ccall := false; 
   Capability_permit_seal := false; 
   Capability_permit_store_local_cap := false; 
   Capability_permit_store_cap := false; 
   Capability_permit_load_cap := false; 
   Capability_permit_store := false; 
   Capability_permit_load := false; 
   Capability_permit_execute := false; 
   Capability_global := false; 
   Capability_sealed := false; 
   Capability_address := (zeros_implicit 64 tt); 
   Capability_base := (zeros_implicit 64 tt); 
   Capability_length := (Ox"FFFFFFFFFFFFFFFF"  : mword 64) |}.
Hint Unfold null_cap : sail.
Definition default_cap : Capability :=
{| Capability_tag := true; 
   Capability_padding := (zeros_implicit 8 tt); 
   Capability_otype := (ones_implicit 24 tt); 
   Capability_uperms := (ones_implicit 16 tt); 
   Capability_perm_reserved12_14 := (zeros_implicit 3 tt); 
   Capability_permit_set_CID := true; 
   Capability_access_system_regs := true; 
   Capability_permit_unseal := true; 
   Capability_permit_ccall := true; 
   Capability_permit_seal := true; 
   Capability_permit_store_local_cap := true; 
   Capability_permit_store_cap := true; 
   Capability_permit_load_cap := true; 
   Capability_permit_store := true; 
   Capability_permit_load := true; 
   Capability_permit_execute := true; 
   Capability_global := true; 
   Capability_sealed := false; 
   Capability_address := (zeros_implicit 64 tt); 
   Capability_base := (zeros_implicit 64 tt); 
   Capability_length := (Ox"FFFFFFFFFFFFFFFF"  : mword 64) |}.
Hint Unfold default_cap : sail.
Definition cap_size := 32.
Hint Unfold cap_size : sail.
Definition caps_per_cacheline := 4.
Hint Unfold caps_per_cacheline : sail.
Definition capBitsToCapability (tag : bool) (capBits : mword 256) : Capability :=
   {| Capability_tag := tag; 
      Capability_padding := (subrange_vec_dec capBits 255 248); 
      Capability_otype := (subrange_vec_dec capBits 247 224); 
      Capability_uperms := (subrange_vec_dec capBits 223 208); 
      Capability_perm_reserved12_14 := (subrange_vec_dec capBits 207 205); 
      Capability_permit_set_CID := ((bit_to_bool (access_vec_dec capBits 204))  : bool); 
      Capability_access_system_regs := ((bit_to_bool (access_vec_dec capBits 203))  : bool); 
      Capability_permit_unseal := ((bit_to_bool (access_vec_dec capBits 202))  : bool); 
      Capability_permit_ccall := ((bit_to_bool (access_vec_dec capBits 201))  : bool); 
      Capability_permit_seal := ((bit_to_bool (access_vec_dec capBits 200))  : bool); 
      Capability_permit_store_local_cap := ((bit_to_bool (access_vec_dec capBits 199))  : bool); 
      Capability_permit_store_cap := ((bit_to_bool (access_vec_dec capBits 198))  : bool); 
      Capability_permit_load_cap := ((bit_to_bool (access_vec_dec capBits 197))  : bool); 
      Capability_permit_store := ((bit_to_bool (access_vec_dec capBits 196))  : bool); 
      Capability_permit_load := ((bit_to_bool (access_vec_dec capBits 195))  : bool); 
      Capability_permit_execute := ((bit_to_bool (access_vec_dec capBits 194))  : bool); 
      Capability_global := ((bit_to_bool (access_vec_dec capBits 193))  : bool); 
      Capability_sealed := ((bit_to_bool (access_vec_dec capBits 192))  : bool); 
      Capability_address := (subrange_vec_dec capBits 191 128); 
      Capability_base := (subrange_vec_dec capBits 127 64); 
      Capability_length := (subrange_vec_dec capBits 63 0) |}.

Definition getCapHardPerms (cap : Capability) : mword 12 :=
   concat_vec (bool_to_bits cap.(Capability_permit_set_CID))
     (concat_vec (bool_to_bits cap.(Capability_access_system_regs))
        (concat_vec (bool_to_bits cap.(Capability_permit_unseal))
           (concat_vec (bool_to_bits cap.(Capability_permit_ccall))
              (concat_vec (bool_to_bits cap.(Capability_permit_seal))
                 (concat_vec (bool_to_bits cap.(Capability_permit_store_local_cap))
                    (concat_vec (bool_to_bits cap.(Capability_permit_store_cap))
                       (concat_vec (bool_to_bits cap.(Capability_permit_load_cap))
                          (concat_vec (bool_to_bits cap.(Capability_permit_store))
                             (concat_vec (bool_to_bits cap.(Capability_permit_load))
                                (concat_vec (bool_to_bits cap.(Capability_permit_execute))
                                   (bool_to_bits cap.(Capability_global)))))))))))).

Definition getCapPerms (cap : Capability) : mword 31 :=
   concat_vec cap.(Capability_uperms) (concat_vec ('b"000"  : mword 3) (getCapHardPerms cap)).

Definition capToBits (cap : Capability) : mword 256 :=
   concat_vec cap.(Capability_padding)
     (concat_vec cap.(Capability_otype)
        (concat_vec cap.(Capability_uperms)
           (concat_vec cap.(Capability_perm_reserved12_14)
              (concat_vec (getCapHardPerms cap)
                 (concat_vec (bool_to_bits cap.(Capability_sealed))
                    (concat_vec cap.(Capability_address)
                       (concat_vec cap.(Capability_base) cap.(Capability_length)))))))).

Definition null_cap_bits : CapBits := capToBits null_cap.
Hint Unfold null_cap_bits : sail.
Definition capToMemBits (cap : Capability) : mword 256 := xor_vec (capToBits cap) null_cap_bits.

Definition memBitsToCapability (tag : bool) (b : mword 256) : Capability :=
   capBitsToCapability tag (xor_vec b null_cap_bits).

Definition setCapPerms (cap : Capability) (perms : mword 31) : Capability :=
   {| Capability_tag := cap.(Capability_tag); 
      Capability_padding := cap.(Capability_padding); 
      Capability_otype := cap.(Capability_otype); 
      Capability_uperms := (subrange_vec_dec perms 30 15); 
      Capability_perm_reserved12_14 := cap.(Capability_perm_reserved12_14); 
      Capability_permit_set_CID := ((bit_to_bool (access_vec_dec perms 11))  : bool); 
      Capability_access_system_regs := ((bit_to_bool (access_vec_dec perms 10))  : bool); 
      Capability_permit_unseal := ((bit_to_bool (access_vec_dec perms 9))  : bool); 
      Capability_permit_ccall := ((bit_to_bool (access_vec_dec perms 8))  : bool); 
      Capability_permit_seal := ((bit_to_bool (access_vec_dec perms 7))  : bool); 
      Capability_permit_store_local_cap := ((bit_to_bool (access_vec_dec perms 6))  : bool); 
      Capability_permit_store_cap := ((bit_to_bool (access_vec_dec perms 5))  : bool); 
      Capability_permit_load_cap := ((bit_to_bool (access_vec_dec perms 4))  : bool); 
      Capability_permit_store := ((bit_to_bool (access_vec_dec perms 3))  : bool); 
      Capability_permit_load := ((bit_to_bool (access_vec_dec perms 2))  : bool); 
      Capability_permit_execute := ((bit_to_bool (access_vec_dec perms 1))  : bool); 
      Capability_global := ((bit_to_bool (access_vec_dec perms 0))  : bool); 
      Capability_sealed := cap.(Capability_sealed); 
      Capability_address := cap.(Capability_address); 
      Capability_base := cap.(Capability_base); 
      Capability_length := cap.(Capability_length) |}.

Definition sealCap (cap : Capability) (otype : mword 24) : (bool * Capability) :=
   (true, {| Capability_tag := cap.(Capability_tag); 
             Capability_padding := cap.(Capability_padding); 
             Capability_otype := otype; 
             Capability_uperms := cap.(Capability_uperms); 
             Capability_perm_reserved12_14 := cap.(Capability_perm_reserved12_14); 
             Capability_permit_set_CID := cap.(Capability_permit_set_CID); 
             Capability_access_system_regs := cap.(Capability_access_system_regs); 
             Capability_permit_unseal := cap.(Capability_permit_unseal); 
             Capability_permit_ccall := cap.(Capability_permit_ccall); 
             Capability_permit_seal := cap.(Capability_permit_seal); 
             Capability_permit_store_local_cap := cap.(Capability_permit_store_local_cap); 
             Capability_permit_store_cap := cap.(Capability_permit_store_cap); 
             Capability_permit_load_cap := cap.(Capability_permit_load_cap); 
             Capability_permit_store := cap.(Capability_permit_store); 
             Capability_permit_load := cap.(Capability_permit_load); 
             Capability_permit_execute := cap.(Capability_permit_execute); 
             Capability_global := cap.(Capability_global); 
             Capability_sealed := true; 
             Capability_address := cap.(Capability_address); 
             Capability_base := cap.(Capability_base); 
             Capability_length := cap.(Capability_length) |}).

Definition unsealCap (cap : Capability) : Capability :=
   {| Capability_tag := cap.(Capability_tag); 
      Capability_padding := cap.(Capability_padding); 
      Capability_otype := (ones_implicit 24 tt); 
      Capability_uperms := cap.(Capability_uperms); 
      Capability_perm_reserved12_14 := cap.(Capability_perm_reserved12_14); 
      Capability_permit_set_CID := cap.(Capability_permit_set_CID); 
      Capability_access_system_regs := cap.(Capability_access_system_regs); 
      Capability_permit_unseal := cap.(Capability_permit_unseal); 
      Capability_permit_ccall := cap.(Capability_permit_ccall); 
      Capability_permit_seal := cap.(Capability_permit_seal); 
      Capability_permit_store_local_cap := cap.(Capability_permit_store_local_cap); 
      Capability_permit_store_cap := cap.(Capability_permit_store_cap); 
      Capability_permit_load_cap := cap.(Capability_permit_load_cap); 
      Capability_permit_store := cap.(Capability_permit_store); 
      Capability_permit_load := cap.(Capability_permit_load); 
      Capability_permit_execute := cap.(Capability_permit_execute); 
      Capability_global := cap.(Capability_global); 
      Capability_sealed := false; 
      Capability_address := cap.(Capability_address); 
      Capability_base := cap.(Capability_base); 
      Capability_length := cap.(Capability_length) |}.

Definition getCapTop (c : Capability)
: {rangevar : Z & ArithFact ((0 <=? rangevar) && (rangevar <=? (2 ^ 65)))} :=
   build_ex (Z.add (projT1 (uint c.(Capability_base))) (projT1 (uint c.(Capability_length)))).

Definition getCapBounds (c : Capability)
:
({rangevar : Z & ArithFact ((0 <=? rangevar) && (rangevar <=? (2 ^ 64 - 1)))} * {rangevar : Z & ArithFact ((0 <=?
  rangevar) &&
  (rangevar <=? (2 ^ 65)))}) :=
   (build_ex (projT1 (getCapBase c)), build_ex (projT1 (getCapTop c))).

Definition getCapOffset (c : Capability)
: {rangevar : Z & ArithFact ((0 <=? rangevar) && (rangevar <=? (2 ^ 64 - 1)))} :=
   build_ex (
      projT1
      (emod_with_eq
         (Z.sub (projT1 (uint c.(Capability_address))) (projT1 (uint c.(Capability_base))))
         (projT1
          (pow2 64)))
   ).

Definition getCapLength (c : Capability)
: {rangevar : Z & ArithFact ((0 <=? rangevar) && (rangevar <=? (2 ^ 65)))} :=
   build_ex (projT1 (uint c.(Capability_length))).

Definition getCapCursor (c : Capability)
: {rangevar : Z & ArithFact ((0 <=? rangevar) && (rangevar <=? (2 ^ 64 - 1)))} :=
   build_ex (projT1 (uint c.(Capability_address))).

Definition setCapAddr (c : Capability) (addr : mword 64) : (bool * Capability) :=
   (true, {[ c with Capability_address := addr ]}).

Definition incCapOffset (c : Capability) (delta : mword 64) : (bool * Capability) :=
   let newAddr : bits 64 := add_vec c.(Capability_address) delta in
   (true, {[ c with Capability_address := newAddr ]}).

Definition setCapBounds (cap : Capability) (base : mword 64) (top : mword 65) : (bool * Capability) :=
   let length : bits 65 := sub_vec top (concat_vec ('b"0"  : mword 1) base) in
   (true, {| Capability_tag := cap.(Capability_tag); 
             Capability_padding := cap.(Capability_padding); 
             Capability_otype := cap.(Capability_otype); 
             Capability_uperms := cap.(Capability_uperms); 
             Capability_perm_reserved12_14 := cap.(Capability_perm_reserved12_14); 
             Capability_permit_set_CID := cap.(Capability_permit_set_CID); 
             Capability_access_system_regs := cap.(Capability_access_system_regs); 
             Capability_permit_unseal := cap.(Capability_permit_unseal); 
             Capability_permit_ccall := cap.(Capability_permit_ccall); 
             Capability_permit_seal := cap.(Capability_permit_seal); 
             Capability_permit_store_local_cap := cap.(Capability_permit_store_local_cap); 
             Capability_permit_store_cap := cap.(Capability_permit_store_cap); 
             Capability_permit_load_cap := cap.(Capability_permit_load_cap); 
             Capability_permit_store := cap.(Capability_permit_store); 
             Capability_permit_load := cap.(Capability_permit_load); 
             Capability_permit_execute := cap.(Capability_permit_execute); 
             Capability_global := cap.(Capability_global); 
             Capability_sealed := cap.(Capability_sealed); 
             Capability_address := base; 
             Capability_base := base; 
             Capability_length := (subrange_vec_dec length 63 0) |}).

Definition getRepresentableAlignmentMask (len : mword 64) : mword 64 := ones_implicit 64 tt.

Definition getRepresentableLength (len : mword 64) : mword 64 := len.

Definition CapRegs : vec (register_ref regstate register_value Capability) 32 :=
vec_of_list_len [C31_ref;C30_ref;C29_ref;C28_ref;C27_ref;C26_ref;C25_ref;C24_ref;C23_ref;C22_ref;
                 C21_ref;C20_ref;C19_ref;C18_ref;C17_ref;C16_ref;C15_ref;C14_ref;C13_ref;C12_ref;
                 C11_ref;C10_ref;C09_ref;C08_ref;C07_ref;C06_ref;C05_ref;C04_ref;C03_ref;C02_ref;
                 C01_ref;DDC_ref].
Hint Unfold CapRegs : sail.
Definition have_cp2 := true.
Hint Unfold have_cp2 : sail.
Definition readCapReg (n : mword 5) : M (Capability) :=
   (if eq_vec n ('b"00000"  : mword 5) then returnm null_cap
    else
      let i := projT1 (uint n) in
      (reg_deref (vec_access_dec CapRegs i))
       : M (Capability))
    : M (Capability).

Definition readCapRegDDC (n : mword 5) : M (Capability) :=
   let i := projT1 (uint n) in
   (reg_deref (vec_access_dec CapRegs i))
    : M (Capability).

Definition hasReservedOType (cap : Capability) : bool :=
   Z.gtb (projT1 (uint cap.(Capability_otype))) max_otype.

Definition capToString (cap : Capability) (fixlen : bool) : M (string) :=
   (skip tt) >>
   let len := projT1 (getCapLength cap) in
   let len_str :=
     if sumbool_of_bool fixlen then
       string_of_bits (to_bits 64 (projT1 (min_atom len (projT1 (MAX 64)))))
     else string_of_bits (to_bits 68 len) in
   let otype64 : bits 64 :=
     if hasReservedOType cap then mips_sign_extend 64 cap.(Capability_otype)
     else mips_zero_extend 64 cap.(Capability_otype) in
   returnm (String.append " t:"
              (String.append (if cap.(Capability_tag) then "1" else "0")
                 (String.append " s:"
                    (String.append (if cap.(Capability_sealed) then "1" else "0")
                       (String.append " perms:"
                          (String.append
                             (string_of_bits (concat_vec ('b"0"  : mword 1) (getCapPerms cap)))
                             (String.append " type:"
                                (String.append (string_of_bits otype64)
                                   (String.append " offset:"
                                      (String.append
                                         (string_of_bits (to_bits 64 (projT1 (getCapOffset cap))))
                                         (String.append " base:"
                                            (String.append
                                               (string_of_bits
                                                  (to_bits 64 (projT1 (getCapBase cap))))
                                               (String.append " length:" len_str))))))))))))).

Definition writeCapReg (n : mword 5) (cap : Capability) : M (unit) :=
   (if eq_vec n ('b"00000"  : mword 5) then returnm tt
    else
      let i := projT1 (uint n) in
      (if sumbool_of_bool trace then
         let '_ := (prerr (string_of_int i))  : unit in
         let '_ := (prerr " <- ")  : unit in
         (capToString cap false) >>= fun w__0 : string =>
         let '_ := (prerr_endline w__0)  : unit in
         let cap2 := capBitsToCapability cap.(Capability_tag) (capToBits cap) in
         (if generic_neq cap cap2 then
            let '_ := (prerr_endline "Wrote non-normal cap:")  : unit in
            (capToString cap false) >>= fun w__1 : string =>
            let '_ := (prerr_endline w__1)  : unit in
            (capToString cap2 false) >>= fun w__2 : string =>
            let '_ := (prerr_endline w__2)  : unit in
            assert_exp' false "wrote non-normal capability" >>= fun _ => exit tt
          else returnm tt)
          : M (unit)
       else (skip tt)  : M (unit)) >>
      write_reg (vec_access_dec CapRegs i) cap
       : M (unit))
    : M (unit).

Definition CapEx_of_num (arg_ : Z) `{ArithFact ((0 <=? arg_) && (arg_ <=? 24))} : CapEx :=
   let l__84 := arg_ in
   if sumbool_of_bool (Z.eqb l__84 0) then CapEx_None
   else if sumbool_of_bool (Z.eqb l__84 1) then CapEx_LengthViolation
   else if sumbool_of_bool (Z.eqb l__84 2) then CapEx_TagViolation
   else if sumbool_of_bool (Z.eqb l__84 3) then CapEx_SealViolation
   else if sumbool_of_bool (Z.eqb l__84 4) then CapEx_TypeViolation
   else if sumbool_of_bool (Z.eqb l__84 5) then CapEx_CallTrap
   else if sumbool_of_bool (Z.eqb l__84 6) then CapEx_ReturnTrap
   else if sumbool_of_bool (Z.eqb l__84 7) then CapEx_TSSUnderFlow
   else if sumbool_of_bool (Z.eqb l__84 8) then CapEx_UserDefViolation
   else if sumbool_of_bool (Z.eqb l__84 9) then CapEx_TLBNoStoreCap
   else if sumbool_of_bool (Z.eqb l__84 10) then CapEx_InexactBounds
   else if sumbool_of_bool (Z.eqb l__84 11) then CapEx_GlobalViolation
   else if sumbool_of_bool (Z.eqb l__84 12) then CapEx_PermitExecuteViolation
   else if sumbool_of_bool (Z.eqb l__84 13) then CapEx_PermitLoadViolation
   else if sumbool_of_bool (Z.eqb l__84 14) then CapEx_PermitStoreViolation
   else if sumbool_of_bool (Z.eqb l__84 15) then CapEx_PermitLoadCapViolation
   else if sumbool_of_bool (Z.eqb l__84 16) then CapEx_PermitStoreCapViolation
   else if sumbool_of_bool (Z.eqb l__84 17) then CapEx_PermitStoreLocalCapViolation
   else if sumbool_of_bool (Z.eqb l__84 18) then CapEx_PermitSealViolation
   else if sumbool_of_bool (Z.eqb l__84 19) then CapEx_AccessSystemRegsViolation
   else if sumbool_of_bool (Z.eqb l__84 20) then CapEx_PermitCCallViolation
   else if sumbool_of_bool (Z.eqb l__84 21) then CapEx_AccessCCallIDCViolation
   else if sumbool_of_bool (Z.eqb l__84 22) then CapEx_PermitUnsealViolation
   else if sumbool_of_bool (Z.eqb l__84 23) then CapEx_PermitSetCIDViolation
   else CapEx_TLBLoadCap.

Definition num_of_CapEx (arg_ : CapEx) : {e : Z & ArithFact ((0 <=? e) && (e <=? 24))} :=
   build_ex (
      match arg_ with
      | CapEx_None => 0
      | CapEx_LengthViolation => 1
      | CapEx_TagViolation => 2
      | CapEx_SealViolation => 3
      | CapEx_TypeViolation => 4
      | CapEx_CallTrap => 5
      | CapEx_ReturnTrap => 6
      | CapEx_TSSUnderFlow => 7
      | CapEx_UserDefViolation => 8
      | CapEx_TLBNoStoreCap => 9
      | CapEx_InexactBounds => 10
      | CapEx_GlobalViolation => 11
      | CapEx_PermitExecuteViolation => 12
      | CapEx_PermitLoadViolation => 13
      | CapEx_PermitStoreViolation => 14
      | CapEx_PermitLoadCapViolation => 15
      | CapEx_PermitStoreCapViolation => 16
      | CapEx_PermitStoreLocalCapViolation => 17
      | CapEx_PermitSealViolation => 18
      | CapEx_AccessSystemRegsViolation => 19
      | CapEx_PermitCCallViolation => 20
      | CapEx_AccessCCallIDCViolation => 21
      | CapEx_PermitUnsealViolation => 22
      | CapEx_PermitSetCIDViolation => 23
      | CapEx_TLBLoadCap => 24
      end
   ).

Definition undefined_CapEx '(tt : unit) : M (CapEx) :=
   (internal_pick
      [CapEx_None;
      CapEx_LengthViolation;
      CapEx_TagViolation;
      CapEx_SealViolation;
      CapEx_TypeViolation;
      CapEx_CallTrap;
      CapEx_ReturnTrap;
      CapEx_TSSUnderFlow;
      CapEx_UserDefViolation;
      CapEx_TLBNoStoreCap;
      CapEx_InexactBounds;
      CapEx_GlobalViolation;
      CapEx_PermitExecuteViolation;
      CapEx_PermitLoadViolation;
      CapEx_PermitStoreViolation;
      CapEx_PermitLoadCapViolation;
      CapEx_PermitStoreCapViolation;
      CapEx_PermitStoreLocalCapViolation;
      CapEx_PermitSealViolation;
      CapEx_AccessSystemRegsViolation;
      CapEx_PermitCCallViolation;
      CapEx_AccessCCallIDCViolation;
      CapEx_PermitUnsealViolation;
      CapEx_PermitSetCIDViolation;
      CapEx_TLBLoadCap])
    : M (CapEx).

Definition Mk_CapCauseReg (v : mword 16) : CapCauseReg :=
   {| CapCauseReg_CapCauseReg_chunk_0 := (subrange_vec_dec v 15 0) |}.

Definition _get_CapCauseReg_bits (v : CapCauseReg) : mword 16 :=
   subrange_vec_dec v.(CapCauseReg_CapCauseReg_chunk_0) 15 0.

Definition _set_CapCauseReg_bits
(r_ref : register_ref regstate register_value CapCauseReg) (v : mword 16)
: M (unit) :=
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       CapCauseReg_CapCauseReg_chunk_0 :=
         (update_subrange_vec_dec r.(CapCauseReg_CapCauseReg_chunk_0) 15 0 (subrange_vec_dec v 15 0)) ]}
      : CapCauseReg in
   write_reg r_ref r
    : M (unit).

Definition _update_CapCauseReg_bits (v : CapCauseReg) (x : mword 16) : CapCauseReg :=
   {[ v with
     CapCauseReg_CapCauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CapCauseReg_CapCauseReg_chunk_0) 15 0 (subrange_vec_dec x 15 0)) ]}.

Definition _get_CapCauseReg_ExcCode (v : CapCauseReg) : mword 8 :=
   subrange_vec_dec v.(CapCauseReg_CapCauseReg_chunk_0) 15 8.

Definition _update_CapCauseReg_ExcCode (v : CapCauseReg) (x : mword 8) : CapCauseReg :=
   {[ v with
     CapCauseReg_CapCauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CapCauseReg_CapCauseReg_chunk_0) 15 8 (subrange_vec_dec x 7 0)) ]}.

Definition _get_CapCauseReg_RegNum (v : CapCauseReg) : mword 8 :=
   subrange_vec_dec v.(CapCauseReg_CapCauseReg_chunk_0) 7 0.

Definition _update_CapCauseReg_RegNum (v : CapCauseReg) (x : mword 8) : CapCauseReg :=
   {[ v with
     CapCauseReg_CapCauseReg_chunk_0 :=
       (update_subrange_vec_dec v.(CapCauseReg_CapCauseReg_chunk_0) 7 0 (subrange_vec_dec x 7 0)) ]}.

Definition execute_branch_pcc (newPCC : Capability) : M (unit) :=
   write_reg DelayedPC_ref (to_bits 64 (projT1 (getCapOffset newPCC))) >>
   write_reg DelayedPCC_ref newPCC >>
   write_reg BranchPending_ref ('b"1"  : mword 1) >>
   write_reg NextInBranchDelay_ref ('b"1"  : mword 1)
    : M (unit).

Definition raise_c2_exception {o : Type} (capEx : CapEx) (regnum : mword 5) : M (o) :=
   let reg8 := concat_vec ('b"000"  : mword 3) regnum in
   (raise_c2_exception8 capEx reg8)
    : M (o).

Definition raise_c2_exception_badaddr {o : Type}
(capEx : CapEx) (regnum : mword 5) (badAddr : mword 64)
: M (o) :=
   write_reg CP0BadVAddr_ref badAddr >> (raise_c2_exception capEx regnum)  : M (o).

Definition cap_addr_mask := to_bits 64 (Z.sub (projT1 (pow2 64)) cap_size).
Hint Unfold cap_addr_mask : sail.








Definition MEMw_wrapper (addr : mword 64) (size : Z) (data : mword (8 * size))
`{ArithFact (size >=? 1)}
: M (unit) :=
   (if eq_vec addr (Ox"000000007F000000"  : mword 64) then
      let ledata := reverse_endianness data in
      write_reg UART_WDATA_ref (subrange_vec_dec ledata 7 0) >>
      write_reg UART_WRITTEN_ref ('b"1"  : mword 1)
       : M (unit)
    else
      assert_exp (eq_vec (and_vec addr cap_addr_mask)
                    (and_vec (add_vec addr (to_bits 64 (Z.sub size 1))) cap_addr_mask)) "cheri_prelude_common.sail 460:85 - 460:86" >>
      (MEMw_tagged addr size false (autocast (autocast data)))
       : M (unit))
    : M (unit).

Definition MEMw_conditional_wrapper (addr : mword 64) (size : Z) (data : mword (8 * size))
`{ArithFact (size >=? 1)}
: M (bool) :=
   assert_exp (eq_vec (and_vec addr cap_addr_mask)
                 (and_vec (add_vec addr (to_bits 64 (Z.sub size 1))) cap_addr_mask)) "cheri_prelude_common.sail 472:85 - 472:86" >>
   (MEMw_tagged_conditional addr size false (autocast (autocast data)))
    : M (bool).

Definition checkDDCPerms (ddc : Capability) (accessType : MemAccessType) : M (unit) :=
   (if negb ddc.(Capability_tag) then
      (raise_c2_exception CapEx_TagViolation ('b"00000"  : mword 5))
       : M (unit)
    else if ddc.(Capability_sealed) then
      (raise_c2_exception CapEx_SealViolation ('b"00000"  : mword 5))
       : M (unit)
    else returnm tt) >>
   (match accessType with
    | Instruction =>
       assert_exp' false "cheri_prelude_common.sail 485:34 - 485:35" >>= fun _ => exit tt
    | LoadData =>
       (if negb ddc.(Capability_permit_load) then
          (raise_c2_exception CapEx_PermitLoadViolation ('b"00000"  : mword 5))
           : M (unit)
        else returnm tt)
        : M (unit)
    | StoreData =>
       (if negb ddc.(Capability_permit_store) then
          (raise_c2_exception CapEx_PermitStoreViolation ('b"00000"  : mword 5))
           : M (unit)
        else returnm tt)
        : M (unit)
    end)
    : M (unit).

Definition addrWrapper (addr : mword 64) (accessType : MemAccessType) (width : WordType)
: M (mword 64) :=
   read_reg DDC_ref >>= fun ddc =>
   (checkDDCPerms ddc accessType) >>
   let cursor := projT1 (getCapCursor ddc) in
   let vAddr := projT1 (emod_with_eq (Z.add cursor (projT1 (uint addr))) (projT1 (pow2 64))) in
   let size := projT1 (wordWidthBytes width) in
   let '(existT _ base _, existT _ top _) := getCapBounds ddc in
   (if sumbool_of_bool (Z.gtb (Z.add vAddr size) top) then
      (raise_c2_exception CapEx_LengthViolation ('b"00000"  : mword 5))
       : M (mword 64)
    else if sumbool_of_bool (Z.ltb vAddr base) then
      (raise_c2_exception CapEx_LengthViolation ('b"00000"  : mword 5))
       : M (mword 64)
    else returnm (to_bits 64 vAddr))
    : M (mword 64).

Definition addrWrapperUnaligned
(addr : mword 64) (accessType : MemAccessType) (width : WordTypeUnaligned)
: M ((mword 64 * Z)) :=
   read_reg DDC_ref >>= fun ddc =>
   (checkDDCPerms ddc accessType) >>
   let cursor := projT1 (getCapCursor ddc) in
   let vAddr := projT1 (emod_with_eq (Z.add cursor (projT1 (uint addr))) (projT1 (pow2 64))) in
   let '(waddr, size) := unalignedBytesTouched vAddr width in
   let '(existT _ base _, existT _ top _) := getCapBounds ddc in
   (if sumbool_of_bool (Z.gtb (Z.add waddr size) top) then
      (raise_c2_exception CapEx_LengthViolation ('b"00000"  : mword 5))
       : M ((mword 64 * Z))
    else if sumbool_of_bool (Z.ltb waddr base) then
      (raise_c2_exception CapEx_LengthViolation ('b"00000"  : mword 5))
       : M ((mword 64 * Z))
    else returnm (to_bits 64 waddr, size))
    : M ((mword 64 * Z)).

Definition execute_branch (pc : mword 64) : M (unit) :=
   read_reg PCC_ref >>= fun w__0 : Capability =>
   let len := projT1 (getCapLength w__0) in
   (if sumbool_of_bool (Z.gtb (Z.add (projT1 (uint pc)) 4) len) then
      (raise_c2_exception_noreg CapEx_LengthViolation)
       : M (unit)
    else returnm tt) >>
   (execute_branch_mips pc)
    : M (unit).

Definition TranslatePC (vAddr : mword 64) : M (mword 64) :=
   (incrementCP0Count tt) >>
   read_reg PCC_ref >>= fun pcc =>
   let '(existT _ base _, existT _ top _) := getCapBounds pcc in
   let absPC := Z.add base (projT1 (uint vAddr)) in
   (if sumbool_of_bool (projT1 (neq_int (projT1 (emod_with_eq absPC 4)) 0)) then
      (SignalExceptionBadAddr AdEL (to_bits 64 absPC))
       : M (mword 64)
    else if negb pcc.(Capability_tag) then
      (raise_c2_exception_noreg CapEx_TagViolation)
       : M (mword 64)
    else if pcc.(Capability_sealed) then
      (raise_c2_exception_noreg CapEx_SealViolation)
       : M (mword 64)
    else if negb pcc.(Capability_permit_execute) then
      (raise_c2_exception_noreg CapEx_PermitExecuteViolation)
       : M (mword 64)
    else if sumbool_of_bool (Z.gtb (Z.add absPC 4) top) then
      (raise_c2_exception_noreg CapEx_LengthViolation)
       : M (mword 64)
    else (TLBTranslate (to_bits 64 absPC) Instruction)  : M (mword 64))
    : M (mword 64).

Definition checkCP2usable '(tt : unit) : M (unit) :=
   read_reg CP0Status_ref >>= fun w__0 : StatusReg =>
   (if negb (bit_to_bool (access_vec_dec (_get_StatusReg_CU w__0) 2)) then
      (_set_CauseReg_CE CP0Cause_ref ('b"10"  : mword 2)) >> (SignalException CpU)  : M (unit)
    else returnm tt)
    : M (unit).

Definition init_cp2_state '(tt : unit) : M (unit) :=
   write_reg PCC_ref default_cap >>
   write_reg NextPCC_ref default_cap >>
   write_reg DelayedPCC_ref default_cap >>
   write_reg DDC_ref default_cap >>
   write_reg KCC_ref default_cap >>
   write_reg EPCC_ref default_cap >>
   write_reg ErrorEPCC_ref default_cap >>
   write_reg KDC_ref null_cap >>
   write_reg KR1C_ref null_cap >>
   write_reg KR2C_ref null_cap >>
   write_reg CPLR_ref null_cap >>
   write_reg CULR_ref null_cap >>
   let loop_i_lower := 1 in
   let loop_i_upper := 31 in
   (foreach_ZM_up loop_i_lower loop_i_upper 1 tt
     (fun i _ _ =>
       let idx := to_bits 5 i in
       (writeCapReg idx null_cap)
        : M (unit))).

Definition cp2_next_pc '(tt : unit) : M (unit) :=
   read_reg NextPCC_ref >>= fun w__0 : Capability =>
   write_reg PCC_ref w__0 >>
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__1 : mword 1 =>
   (if (bits_to_bool w__1)  : bool then
      read_reg DelayedPCC_ref >>= fun w__2 : Capability => write_reg NextPCC_ref w__2  : M (unit)
    else returnm tt)
    : M (unit).

Definition get_CP0EPC '(tt : unit) : M (mword 64) :=
   read_reg EPCC_ref >>= fun w__0 : Capability => returnm (to_bits 64 (projT1 (getCapOffset w__0))).

Definition set_CP0EPC (newEPC : mword 64) : M (unit) :=
   read_reg EPCC_ref >>= fun w__0 : Capability =>
   let '(representable, newEPCC) := setCapOffset w__0 newEPC in
   write_reg
     EPCC_ref
     (if sumbool_of_bool representable then
        {[ newEPCC with
          Capability_tag := (andb newEPCC.(Capability_tag) (negb newEPCC.(Capability_sealed))) ]}
      else unrepCap newEPCC)
    : M (unit).

Definition get_CP0ErrorEPC '(tt : unit) : M (mword 64) :=
   read_reg ErrorEPCC_ref >>= fun w__0 : Capability =>
   returnm (to_bits 64 (projT1 (getCapOffset w__0))).

Definition set_CP0ErrorEPC (v : mword 64) : M (unit) :=
   read_reg ErrorEPCC_ref >>= fun w__0 : Capability =>
   let '(representable, newErrorEPCC) := setCapOffset w__0 v in
   write_reg
     ErrorEPCC_ref
     (if sumbool_of_bool representable then
        {[ newErrorEPCC with
          Capability_tag :=
            (andb newErrorEPCC.(Capability_tag) (negb newErrorEPCC.(Capability_sealed))) ]}
      else unrepCap newErrorEPCC)
    : M (unit).

Definition dump_cp2_state '(tt : unit) : M (unit) :=
   read_reg PCC_ref >>= fun w__0 : Capability =>
   (capToString w__0 true) >>= fun w__1 : string =>
   let '_ := (print_endline (String.append "DEBUG CAP PCC" w__1))  : unit in
   (let loop_i_lower := 0 in
   let loop_i_upper := 31 in
   (foreach_ZM_up loop_i_lower loop_i_upper 1 tt
     (fun i _ _ =>
       (readCapReg (to_bits 5 i)) >>= fun w__2 : Capability =>
       (capToString w__2 true) >>= fun w__3 : string =>
       returnm (let '_ :=
         (print_endline (String.append "DEBUG CAP REG " (String.append (string_of_int i) w__3)))
          : unit in
       tt)))) >>
   read_reg DDC_ref >>= fun w__4 : Capability =>
   (capToString w__4 true) >>= fun w__5 : string =>
   let '_ := (print_endline (String.append "DEBUG CAP HWREG 00" w__5))  : unit in
   read_reg CULR_ref >>= fun w__6 : Capability =>
   (capToString w__6 true) >>= fun w__7 : string =>
   let '_ := (print_endline (String.append "DEBUG CAP HWREG 01" w__7))  : unit in
   read_reg CPLR_ref >>= fun w__8 : Capability =>
   (capToString w__8 true) >>= fun w__9 : string =>
   let '_ := (print_endline (String.append "DEBUG CAP HWREG 08" w__9))  : unit in
   read_reg KR1C_ref >>= fun w__10 : Capability =>
   (capToString w__10 true) >>= fun w__11 : string =>
   let '_ := (print_endline (String.append "DEBUG CAP HWREG 22" w__11))  : unit in
   read_reg KR2C_ref >>= fun w__12 : Capability =>
   (capToString w__12 true) >>= fun w__13 : string =>
   let '_ := (print_endline (String.append "DEBUG CAP HWREG 23" w__13))  : unit in
   read_reg ErrorEPCC_ref >>= fun w__14 : Capability =>
   (capToString w__14 true) >>= fun w__15 : string =>
   let '_ := (print_endline (String.append "DEBUG CAP HWREG 28" w__15))  : unit in
   read_reg KCC_ref >>= fun w__16 : Capability =>
   (capToString w__16 true) >>= fun w__17 : string =>
   let '_ := (print_endline (String.append "DEBUG CAP HWREG 29" w__17))  : unit in
   read_reg KDC_ref >>= fun w__18 : Capability =>
   (capToString w__18 true) >>= fun w__19 : string =>
   let '_ := (print_endline (String.append "DEBUG CAP HWREG 30" w__19))  : unit in
   read_reg EPCC_ref >>= fun w__20 : Capability =>
   (capToString w__20 true) >>= fun w__21 : string =>
   returnm (print_endline (String.append "DEBUG CAP HWREG 31" w__21)).

Definition getCapFlags (cap : Capability) : mword 1 := 'b"0"  : mword 1.

Definition setCapFlags (cap : Capability) (flags : mword 1) : Capability := cap.

Definition isSentryCap (cap : Capability) : bool :=
   Z.eqb (projT1 (sint cap.(Capability_otype))) otype_sentry.

Definition ERETHook '(tt : unit) : M (unit) :=
   read_reg CP0Status_ref >>= fun w__0 : StatusReg =>
   (if Bool.eqb (bits_to_bool (_get_StatusReg_ERL w__0)) (bit_to_bool B1) then
      read_reg ErrorEPCC_ref
       : M (Capability)
    else read_reg EPCC_ref  : M (Capability)) >>= fun epcc_val =>
   let new_pcc := if isSentryCap epcc_val then unsealCap epcc_val else epcc_val in
   (set_next_pcc new_pcc)
    : M (unit).

Definition TLBWriteEntry (idx : mword 6) : M (unit) :=
   ((read_reg TLBPageMask_ref)  : M (mword 16)) >>= fun pagemask =>
   let b__0 := pagemask in
   (if eq_vec b__0 (Ox"0000"  : mword 16) then returnm tt
    else if eq_vec b__0 (Ox"0003"  : mword 16) then returnm tt
    else if eq_vec b__0 (Ox"000F"  : mword 16) then returnm tt
    else if eq_vec b__0 (Ox"003F"  : mword 16) then returnm tt
    else if eq_vec b__0 (Ox"00FF"  : mword 16) then returnm tt
    else if eq_vec b__0 (Ox"03FF"  : mword 16) then returnm tt
    else if eq_vec b__0 (Ox"0FFF"  : mword 16) then returnm tt
    else if eq_vec b__0 (Ox"3FFF"  : mword 16) then returnm tt
    else if eq_vec b__0 (Ox"FFFF"  : mword 16) then returnm tt
    else (SignalException MCheck)  : M (unit)) >>
   let i := projT1 (uint idx) in
   let entry := vec_access_dec TLBEntries i in
   (_set_TLBEntry_pagemask entry pagemask) >>
   read_reg TLBEntryHi_ref >>= fun w__0 : TLBEntryHiReg =>
   (_set_TLBEntry_r entry (_get_TLBEntryHiReg_R w__0)) >>
   read_reg TLBEntryHi_ref >>= fun w__1 : TLBEntryHiReg =>
   (_set_TLBEntry_vpn2 entry (_get_TLBEntryHiReg_VPN2 w__1)) >>
   read_reg TLBEntryHi_ref >>= fun w__2 : TLBEntryHiReg =>
   (_set_TLBEntry_asid entry (_get_TLBEntryHiReg_ASID w__2)) >>
   (and_boolM
      (read_reg TLBEntryLo0_ref >>= fun w__3 : TLBEntryLoReg =>
       returnm ((bits_to_bool (_get_TLBEntryLoReg_G w__3))  : bool))
      (read_reg TLBEntryLo1_ref >>= fun w__4 : TLBEntryLoReg =>
       returnm ((bits_to_bool (_get_TLBEntryLoReg_G w__4))  : bool))) >>= fun w__5 : bool =>
   (_set_TLBEntry_g entry ((bool_to_bits w__5)  : mword 1)) >>
   (_set_TLBEntry_valid entry ((cast_unit_vec B1)  : mword 1)) >>
   read_reg TLBEntryLo0_ref >>= fun w__6 : TLBEntryLoReg =>
   (_set_TLBEntry_caps0 entry (_get_TLBEntryLoReg_CapS w__6)) >>
   read_reg TLBEntryLo0_ref >>= fun w__7 : TLBEntryLoReg =>
   (_set_TLBEntry_capl0 entry (_get_TLBEntryLoReg_CapL w__7)) >>
   read_reg TLBEntryLo0_ref >>= fun w__8 : TLBEntryLoReg =>
   (_set_TLBEntry_caplg0 entry (_get_TLBEntryLoReg_CapLG w__8)) >>
   read_reg TLBEntryLo0_ref >>= fun w__9 : TLBEntryLoReg =>
   (_set_TLBEntry_pfn0 entry (_get_TLBEntryLoReg_PFN w__9)) >>
   read_reg TLBEntryLo0_ref >>= fun w__10 : TLBEntryLoReg =>
   (_set_TLBEntry_c0 entry (_get_TLBEntryLoReg_C w__10)) >>
   read_reg TLBEntryLo0_ref >>= fun w__11 : TLBEntryLoReg =>
   (_set_TLBEntry_d0 entry (_get_TLBEntryLoReg_D w__11)) >>
   read_reg TLBEntryLo0_ref >>= fun w__12 : TLBEntryLoReg =>
   (_set_TLBEntry_v0 entry (_get_TLBEntryLoReg_V w__12)) >>
   read_reg TLBEntryLo1_ref >>= fun w__13 : TLBEntryLoReg =>
   (_set_TLBEntry_caps1 entry (_get_TLBEntryLoReg_CapS w__13)) >>
   read_reg TLBEntryLo1_ref >>= fun w__14 : TLBEntryLoReg =>
   (_set_TLBEntry_capl1 entry (_get_TLBEntryLoReg_CapL w__14)) >>
   read_reg TLBEntryLo1_ref >>= fun w__15 : TLBEntryLoReg =>
   (_set_TLBEntry_caplg1 entry (_get_TLBEntryLoReg_CapLG w__15)) >>
   read_reg TLBEntryLo1_ref >>= fun w__16 : TLBEntryLoReg =>
   (_set_TLBEntry_pfn1 entry (_get_TLBEntryLoReg_PFN w__16)) >>
   read_reg TLBEntryLo1_ref >>= fun w__17 : TLBEntryLoReg =>
   (_set_TLBEntry_c1 entry (_get_TLBEntryLoReg_C w__17)) >>
   read_reg TLBEntryLo1_ref >>= fun w__18 : TLBEntryLoReg =>
   (_set_TLBEntry_d1 entry (_get_TLBEntryLoReg_D w__18)) >>
   read_reg TLBEntryLo1_ref >>= fun w__19 : TLBEntryLoReg =>
   (_set_TLBEntry_v1 entry (_get_TLBEntryLoReg_V w__19))
    : M (unit).

Definition strCReg (r : mword 5) : string := concat_str_dec "$c" (projT1 (uint r)).

Definition strRRArgs (rd : mword 5) (r1 : mword 5) : string :=
   String.append (strReg rd) (String.append ", " (strReg r1)).

Definition strRCArgs (rd : mword 5) (c1 : mword 5) : string :=
   String.append (strReg rd) (String.append ", " (strCReg c1)).

Definition strCRArgs (cd : mword 5) (r1 : mword 5) : string :=
   String.append (strCReg cd) (String.append ", " (strReg r1)).

Definition strCCArgs (cd : mword 5) (c1 : mword 5) : string :=
   String.append (strCReg cd) (String.append ", " (strCReg c1)).

Definition strCCCArgs (cd : mword 5) (c1 : mword 5) (c2 : mword 5) : string :=
   String.append (strCReg cd)
     (String.append ", " (String.append (strCReg c1) (String.append ", " (strCReg c2)))).

Definition strCCRArgs (cd : mword 5) (c1 : mword 5) (r2 : mword 5) : string :=
   String.append (strCReg cd)
     (String.append ", " (String.append (strCReg c1) (String.append ", " (strReg r2)))).

Definition strRCCArgs (rd : mword 5) (c1 : mword 5) (c2 : mword 5) : string :=
   String.append (strReg rd)
     (String.append ", " (String.append (strCReg c1) (String.append ", " (strCReg c2)))).

Definition strRCRArgs (rd : mword 5) (c1 : mword 5) (r2 : mword 5) : string :=
   String.append (strReg rd)
     (String.append ", " (String.append (strCReg c1) (String.append ", " (strReg r2)))).

Definition strCCIArgs {n : Z} (cd : mword 5) (cs : mword 5) (imm : mword n) `{ArithFact (n >? 0)}
: string :=
   String.append (strCReg cd)
     (String.append ", "
        (String.append (strCReg cs) (String.append ", " (dec_str (projT1 (sint imm)))))).

Definition strCCIUArgs {n : Z} (cd : mword 5) (cs : mword 5) (imm : mword n) `{ArithFact (n >? 0)}
: string :=
   String.append (strCReg cd)
     (String.append ", "
        (String.append (strCReg cs) (String.append ", " (hex_str (projT1 (uint imm)))))).

Definition decode (v__0 : mword 32) : option ast :=
   if eq_vec (subrange_vec_dec v__0 31 26) ('b"011001"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (DADDIU (rs, rt, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000101101"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DADDU (rs, rt, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"011000"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (DADDI (rs, rt, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000101100"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DADD (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000100000"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (ADD (rs, rt, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"001000"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (ADDI (rs, rt, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000100001"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (ADDU (rs, rt, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"001001"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (ADDIU (rs, rt, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000101111"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSUBU (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000101110"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSUB (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000100010"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SUB (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000100011"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SUBU (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000100100"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (AND (rs, rt, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"001100"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (ANDI (rs, rt, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000100101"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (OR (rs, rt, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"001101"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (ORI (rs, rt, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000100111"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (NOR (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000100110"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (XOR (rs, rt, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"001110"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (XORI (rs, rt, imm))
   else if eq_vec (subrange_vec_dec v__0 31 21) ('b"00111100000"  : mword (31 - 21 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (LUI (rt, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"00000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"111000"  : mword (5 - 0 + 1))) then
     let sa : bits 5 := subrange_vec_dec v__0 10 6 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSLL (rt, rd, sa))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"00000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"111100"  : mword (5 - 0 + 1))) then
     let sa : bits 5 := subrange_vec_dec v__0 10 6 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSLL32 (rt, rd, sa))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000010100"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSLLV (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"00000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"111011"  : mword (5 - 0 + 1))) then
     let sa : bits 5 := subrange_vec_dec v__0 10 6 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSRA (rt, rd, sa))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"00000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"111111"  : mword (5 - 0 + 1))) then
     let sa : bits 5 := subrange_vec_dec v__0 10 6 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSRA32 (rt, rd, sa))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000010111"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSRAV (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"00000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"111010"  : mword (5 - 0 + 1))) then
     let sa : bits 5 := subrange_vec_dec v__0 10 6 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSRL (rt, rd, sa))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"00000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"111110"  : mword (5 - 0 + 1))) then
     let sa : bits 5 := subrange_vec_dec v__0 10 6 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSRL32 (rt, rd, sa))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000010110"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (DSRLV (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"00000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1))) then
     let sa : regno := subrange_vec_dec v__0 10 6 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SLL (rt, rd, sa))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000100"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SLLV (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"00000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000011"  : mword (5 - 0 + 1))) then
     let sa : regno := subrange_vec_dec v__0 10 6 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SRA (rt, rd, sa))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000111"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SRAV (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"00000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000010"  : mword (5 - 0 + 1))) then
     let sa : regno := subrange_vec_dec v__0 10 6 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SRL (rt, rd, sa))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000110"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SRLV (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000101010"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SLT (rs, rt, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"001010"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (SLTI (rs, rt, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000101011"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (SLTU (rs, rt, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"001011"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (SLTIU (rs, rt, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001011"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (MOVN (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001010"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (MOVZ (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 16) (Ox"0000"  : mword (31 - 16 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000010000"  : mword (10 - 0 + 1))) then
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (MFHI rd)
   else if andb (eq_vec (subrange_vec_dec v__0 31 16) (Ox"0000"  : mword (31 - 16 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000010010"  : mword (10 - 0 + 1))) then
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (MFLO rd)
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 0) ('b"000000000000000010001"  : mword (20 - 0 + 1)))
   then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (MTHI rs)
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 0) ('b"000000000000000010011"  : mword (20 - 0 + 1)))
   then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (MTLO rs)
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"011100"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000010"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (MUL (rs, rt, rd))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"0018"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (MULT (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"0019"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (MULTU (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"001C"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (DMULT (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"001D"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (DMULTU (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"011100"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"0000"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (MADD (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"011100"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"0001"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (MADDU (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"011100"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"0004"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (MSUB (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"011100"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"0005"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (MSUBU (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"001A"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (DIV (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"001B"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (DIVU (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"001E"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (DDIV (rs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"001F"  : mword (15 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (DDIVU (rs, rt))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"000010"  : mword (31 - 26 + 1)) then
     let offset : bits 26 := subrange_vec_dec v__0 25 0 in
     Some (J offset)
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"000011"  : mword (31 - 26 + 1)) then
     let offset : bits 26 := subrange_vec_dec v__0 25 0 in
     Some (JAL offset)
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 20 11) ('b"0000000000"  : mword (20 - 11 + 1)))
                (eq_vec (subrange_vec_dec v__0 5 0) ('b"001000"  : mword (5 - 0 + 1)))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (JR rs)
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 20 16) ('b"00000"  : mword (20 - 16 + 1)))
                (eq_vec (subrange_vec_dec v__0 5 0) ('b"001001"  : mword (5 - 0 + 1)))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (JALR (rs, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"000100"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BEQ (rs, rt, imm, false, false))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"010100"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BEQ (rs, rt, imm, false, true))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"000101"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BEQ (rs, rt, imm, true, false))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"010101"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BEQ (rs, rt, imm, true, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"00000"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, LT', false, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"10000"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, LT', true, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"00010"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, LT', false, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"10010"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, LT', true, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"00001"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, GE, false, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"10001"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, GE, true, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"00011"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, GE, false, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"10011"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, GE, true, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000111"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"00000"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, GT', false, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"010111"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"00000"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, GT', false, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000110"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"00000"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, LE, false, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"010110"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"00000"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (BCMPZ (rs, imm, LE, false, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001100"  : mword (5 - 0 + 1))) then
     Some (SYSCALL tt)
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001101"  : mword (5 - 0 + 1))) then
     Some (BREAK tt)
   else if eq_vec v__0 (Ox"42000020"  : mword 32) then Some (WAIT tt)
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"110000"  : mword (5 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (TRAPREG (rs, rt, GE))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"110001"  : mword (5 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (TRAPREG (rs, rt, GEU))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"110010"  : mword (5 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (TRAPREG (rs, rt, LT'))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"110011"  : mword (5 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (TRAPREG (rs, rt, LTU))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"110100"  : mword (5 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (TRAPREG (rs, rt, EQ'))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000000"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"110110"  : mword (5 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rs : regno := subrange_vec_dec v__0 25 21 in
     Some (TRAPREG (rs, rt, NE))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"01100"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (TRAPIMM (rs, imm, EQ'))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"01110"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (TRAPIMM (rs, imm, NE))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"01000"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (TRAPIMM (rs, imm, GE))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"01001"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (TRAPIMM (rs, imm, GEU))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"01010"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (TRAPIMM (rs, imm, LT'))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"000001"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 20 16) ('b"01011"  : mword (20 - 16 + 1))) then
     let rs : regno := subrange_vec_dec v__0 25 21 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     Some (TRAPIMM (rs, imm, LTU))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"100000"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Load (B, true, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"100100"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Load (B, false, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"100001"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Load (H, true, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"100101"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Load (H, false, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"100011"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Load (W, true, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"100111"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Load (W, false, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"110111"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Load (D, false, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"110000"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Load (W, true, true, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"110100"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Load (D, false, true, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"101000"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Store (B, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"101001"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Store (H, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"101011"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Store (W, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"111111"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Store (D, false, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"111000"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Store (W, true, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"111100"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (Store (D, true, base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"100010"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (LWL (base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"100110"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (LWR (base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"101010"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (SWL (base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"101110"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (SWR (base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"011010"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (LDL (base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"011011"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (LDR (base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"101100"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (SDL (base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"101101"  : mword (31 - 26 + 1)) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let offset : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (SDR (base, rt, offset))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"101111"  : mword (31 - 26 + 1)) then
     let op : regno := subrange_vec_dec v__0 20 16 in
     let imm : imm16 := subrange_vec_dec v__0 15 0 in
     let base : regno := subrange_vec_dec v__0 25 21 in
     Some (CACHE (base, op, imm))
   else if andb
             (eq_vec (subrange_vec_dec v__0 31 11)
                ('b"000000000000000000000"
                 : mword (31 - 11 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001111"  : mword (5 - 0 + 1))) then
     Some (SYNC tt)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01000000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 3) (Ox"00"  : mword (10 - 3 + 1))) then
     let sel : bits 3 := subrange_vec_dec v__0 2 0 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (MFC0 (rt, rd, sel, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01000000001"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 3) (Ox"00"  : mword (10 - 3 + 1))) then
     let sel : bits 3 := subrange_vec_dec v__0 2 0 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (MFC0 (rt, rd, sel, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01000000100"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"B800"  : mword (15 - 0 + 1))) then
     Some (HCF tt)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01000000100"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"D000"  : mword (15 - 0 + 1))) then
     Some (HCF tt)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01000000100"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 3) (Ox"00"  : mword (10 - 3 + 1))) then
     let sel : bits 3 := subrange_vec_dec v__0 2 0 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (MTC0 (rt, rd, sel, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01000000101"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 3) (Ox"00"  : mword (10 - 3 + 1))) then
     let sel : bits 3 := subrange_vec_dec v__0 2 0 in
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (MTC0 (rt, rd, sel, true))
   else if eq_vec v__0 (Ox"42000002"  : mword 32) then Some ((TLBWI tt)  : ast)
   else if eq_vec v__0 (Ox"42000006"  : mword 32) then Some ((TLBWR tt)  : ast)
   else if eq_vec v__0 (Ox"42000001"  : mword 32) then Some ((TLBR tt)  : ast)
   else if eq_vec v__0 (Ox"42000008"  : mword 32) then Some ((TLBP tt)  : ast)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01111100000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000111011"  : mword (10 - 0 + 1))) then
     let rt : regno := subrange_vec_dec v__0 20 16 in
     let rd : regno := subrange_vec_dec v__0 15 11 in
     Some (RDHWR (rt, rd))
   else if eq_vec v__0 (Ox"42000018"  : mword 32) then Some (ERET tt)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000000"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetPerm (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000001"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetType (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000010"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetBase (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000011"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetLen (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000101"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetTag (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000110"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetSealed (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"0004"  : mword (15 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CGetCause rd)
   else if eq_vec v__0 (Ox"48C00000"  : mword 32) then Some (CReturn tt)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001101"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000010"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetOffset (rd, cb))
   else if andb
             (eq_vec (subrange_vec_dec v__0 31 11)
                ('b"010010001000000000000"
                 : mword (31 - 11 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000100"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     Some (CSetCause rt)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000100"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CAndPerm (cd, cb, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001100"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegOrDDCEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CToPtr (rd, cb, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001110"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, ct, CEQ))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001110"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000001"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, ct, CNE))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001110"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000010"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, ct, CLT))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001110"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000011"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, ct, CLE))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001110"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000100"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, ct, CLTU))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001110"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000101"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, ct, CLEU))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001110"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000110"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, ct, CEXEQ))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001110"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000111"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, ct, CNEXEQ))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001101"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CIncOffset (cd, cb, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001101"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000001"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CSetOffset (cd, cb, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000001"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CSetBounds (cd, cb, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000100"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000101"  : mword (10 - 0 + 1))) then
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CClearTag (cd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000100"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000111"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CFromPtr (cd, cb, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001011"  : mword (31 - 21 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 15 11) ('b"00000"  : mword (15 - 11 + 1)))
                (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1)))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CCheckPerm (cs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001011"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000001"  : mword (10 - 0 + 1))) then
     let cs : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CCheckType (cs, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000010"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1))) then
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CSeal (cd, cs, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000011"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1))) then
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CUnseal (cd, cs, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000111"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000000"  : mword (10 - 0 + 1))) then
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CJALR (cd, cb, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 16) (Ox"4900"  : mword (31 - 16 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000000000"  : mword (10 - 0 + 1))) then
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CJALR ('b"00000"  : mword 5, cb, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"0FFF"  : mword (15 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CGetCause rd)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"17FF"  : mword (15 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CSetCause rs)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"07FF"  : mword (15 - 0 + 1))) then
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CGetPCC cd)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"1FFF"  : mword (15 - 0 + 1))) then
     let cb : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CJALR ('b"00000"  : mword 5, cb, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"27FF"  : mword (15 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CGetCID rd)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"2FFF"  : mword (15 - 0 + 1))) then
     let cb : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CSetCID cb)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"C7FF"  : mword (15 - 0 + 1))) then
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CClearTags cb)
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"01000111111"  : mword (10 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let cs : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CCheckPerm (cs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"01001111111"  : mword (10 - 0 + 1))) then
     let cs : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CCheckType (cs, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"01011111111"  : mword (10 - 0 + 1))) then
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CClearTag (cd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"01010111111"  : mword (10 - 0 + 1))) then
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CMove (cd, cs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"01100111111"  : mword (10 - 0 + 1))) then
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CJALR (cd, cb, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"11101111111"  : mword (10 - 0 + 1))) then
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CSealEntry (cd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"11110111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CLoadTags (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetPerm (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00001111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetType (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00010111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetBase (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00011111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetLen (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00100111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetTag (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00101111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetSealed (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00110111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetOffset (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00111111111"  : mword (10 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CGetPCCSetOffset (cd, rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"01101111111"  : mword (10 - 0 + 1))) then
     let sel : CapHwrEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CReadHwr (cd, sel))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"01110111111"  : mword (10 - 0 + 1))) then
     let sel : CapHwrEnc := subrange_vec_dec v__0 15 11 in
     let cb : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CWriteHwr (cb, sel))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"01111111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetAddr (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"10010111111"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetFlags (rd, cb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"10011111111"  : mword (10 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CGetPCCIncOffset (cd, rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"10100111111"  : mword (10 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CGetPCCSetAddr (cd, rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"10000111111"  : mword (10 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let rs : IntRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CRAP (rt, rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"10001111111"  : mword (10 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let rs : IntRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CRAM (rt, rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001011"  : mword (5 - 0 + 1))) then
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CSeal (cd, cs, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001100"  : mword (5 - 0 + 1))) then
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CUnseal (cd, cs, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001101"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CAndPerm (cd, cs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001111"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CSetOffset (cd, cs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001000"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CSetBounds (cd, cs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001001"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CSetBoundsExact (cd, cs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001110"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CSetFlags (cd, cs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"010001"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CIncOffset (cd, cb, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"011101"  : mword (5 - 0 + 1))) then
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CBuildCap (cd, cb, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"011110"  : mword (5 - 0 + 1))) then
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CCopyType (cd, cb, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"011111"  : mword (5 - 0 + 1))) then
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CCSeal (cd, cs, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"010010"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CToPtr (rd, cb, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"010011"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CFromPtr (cd, cb, rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"001010"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CSub (rt, cb, cs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"011011"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CMOVX (cd, cs, rs, false))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"011100"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CMOVX (cd, cs, rs, true))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"100010"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CSetAddr (cd, cs, rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"100011"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CGetAndAddr (rd, cs, rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"100100"  : mword (5 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CAndAddr (cd, cs, rt))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"010100"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, cs, CEQ))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"010101"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, cs, CNE))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"010110"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, cs, CLT))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"010111"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, cs, CLE))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"011000"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, cs, CLTU))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"011001"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, cs, CLEU))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"011010"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, cs, CEXEQ))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"100001"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cs : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CPtrCmp (rd, cb, cs, CNEXEQ))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"100000"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let ct : CapRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CTestSubset (rd, cb, ct))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"111000"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CLCNT (cd, cs, rs))
   else if eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001001"  : mword (31 - 21 + 1)) then
     let imm : bits 16 := subrange_vec_dec v__0 15 0 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CBX (cd, imm, true))
   else if eq_vec (subrange_vec_dec v__0 31 21) ('b"01001001010"  : mword (31 - 21 + 1)) then
     let imm : bits 16 := subrange_vec_dec v__0 15 0 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CBX (cd, imm, false))
   else if eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010001"  : mword (31 - 21 + 1)) then
     let imm : bits 16 := subrange_vec_dec v__0 15 0 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CBZ (cd, imm, false))
   else if eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010010"  : mword (31 - 21 + 1)) then
     let imm : bits 16 := subrange_vec_dec v__0 15 0 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     Some (CBZ (cd, imm, true))
   else if eq_vec v__0 (Ox"48A007FF"  : mword 32) then Some (CReturn tt)
   else if eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000101"  : mword (31 - 21 + 1)) then
     let selector : bits 11 := subrange_vec_dec v__0 10 0 in
     let cs : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CCall (cs, cb, selector))
   else if eq_vec (subrange_vec_dec v__0 31 16) (Ox"49E0"  : mword (31 - 16 + 1)) then
     let imm : bits 16 := subrange_vec_dec v__0 15 0 in
     Some (ClearRegs (GPLo, imm))
   else if eq_vec (subrange_vec_dec v__0 31 16) (Ox"49E1"  : mword (31 - 16 + 1)) then
     let imm : bits 16 := subrange_vec_dec v__0 15 0 in
     Some (ClearRegs (GPHi, imm))
   else if eq_vec (subrange_vec_dec v__0 31 16) (Ox"49E2"  : mword (31 - 16 + 1)) then
     let imm : bits 16 := subrange_vec_dec v__0 15 0 in
     Some (ClearRegs (CLo, imm))
   else if eq_vec (subrange_vec_dec v__0 31 16) (Ox"49E3"  : mword (31 - 16 + 1)) then
     let imm : bits 16 := subrange_vec_dec v__0 15 0 in
     Some (ClearRegs (CHi, imm))
   else if eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010011"  : mword (31 - 21 + 1)) then
     let imm : bits 11 := subrange_vec_dec v__0 10 0 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CIncOffsetImmediate (cd, cb, imm))
   else if eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010100"  : mword (31 - 21 + 1)) then
     let imm : bits 11 := subrange_vec_dec v__0 10 0 in
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegEnc := subrange_vec_dec v__0 15 11 in
     Some (CSetBoundsImmediate (cd, cb, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"110010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"000"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rd : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CLoad (rd, cb, rt, offset, false, B))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"110010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"100"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rd : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CLoad (rd, cb, rt, offset, true, B))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"110010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"001"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rd : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CLoad (rd, cb, rt, offset, false, H))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"110010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"101"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rd : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CLoad (rd, cb, rt, offset, true, H))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"110010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"010"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rd : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CLoad (rd, cb, rt, offset, false, W))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"110010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"110"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rd : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CLoad (rd, cb, rt, offset, true, W))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"110010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"011"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rd : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CLoad (rd, cb, rt, offset, false, D))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001000"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CLoadLinked (rd, cb, false, B))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001100"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CLoadLinked (rd, cb, true, B))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001001"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CLoadLinked (rd, cb, false, H))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001101"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CLoadLinked (rd, cb, true, H))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001010"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CLoadLinked (rd, cb, false, W))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001110"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CLoadLinked (rd, cb, true, W))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001011"  : mword (10 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CLoadLinked (rd, cb, false, D))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"111010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"000"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rs : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CStore (rs, cb, rt, offset, B))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"111010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"001"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rs : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CStore (rs, cb, rt, offset, H))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"111010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"010"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rs : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CStore (rs, cb, rt, offset, W))
   else if andb (eq_vec (subrange_vec_dec v__0 31 26) ('b"111010"  : mword (31 - 26 + 1)))
             (eq_vec (subrange_vec_dec v__0 2 0) ('b"011"  : mword (2 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let rs : IntRegEnc := subrange_vec_dec v__0 25 21 in
     let offset : bits 8 := subrange_vec_dec v__0 10 3 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CStore (rs, cb, rt, offset, D))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000000"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let rd : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CStoreConditional (rs, cb, rd, B))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000001"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let rd : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CStoreConditional (rs, cb, rd, H))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000010"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let rd : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CStoreConditional (rs, cb, rd, W))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000011"  : mword (5 - 0 + 1))) then
     let rs : IntRegEnc := subrange_vec_dec v__0 20 16 in
     let rd : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CStoreConditional (rs, cb, rd, D))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"111110"  : mword (31 - 26 + 1)) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let offset : bits 11 := subrange_vec_dec v__0 10 0 in
     let cs : CapRegEnc := subrange_vec_dec v__0 25 21 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CSC (cs, cb, rt, offset))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 5 0) ('b"000111"  : mword (5 - 0 + 1))) then
     let rd : IntRegEnc := subrange_vec_dec v__0 10 6 in
     let cs : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CSCC (cs, cb, rd))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"110110"  : mword (31 - 26 + 1)) then
     let rt : IntRegEnc := subrange_vec_dec v__0 15 11 in
     let offset : bits 11 := subrange_vec_dec v__0 10 0 in
     let cd : CapRegEnc := subrange_vec_dec v__0 25 21 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CLC (cd, cb, rt, offset))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001010000"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 10 0) ('b"00000001111"  : mword (10 - 0 + 1))) then
     let cd : CapRegEnc := subrange_vec_dec v__0 20 16 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 15 11 in
     Some (CLLC (cd, cb))
   else if eq_vec (subrange_vec_dec v__0 31 26) ('b"011101"  : mword (31 - 26 + 1)) then
     let offset : bits 16 := subrange_vec_dec v__0 15 0 in
     let cd : CapRegEnc := subrange_vec_dec v__0 25 21 in
     let cb : CapRegOrDDCEnc := subrange_vec_dec v__0 20 16 in
     Some (CLCBI (cd, cb, offset))
   else if andb (eq_vec (subrange_vec_dec v__0 31 21) ('b"01001000100"  : mword (31 - 21 + 1)))
             (eq_vec (subrange_vec_dec v__0 15 0) (Ox"0006"  : mword (15 - 0 + 1))) then
     let rt : IntRegEnc := subrange_vec_dec v__0 20 16 in
     Some (C2Dump rt)
   else Some (RI tt).

Definition execute_XORI (rs : mword 5) (rt : mword 5) (imm : mword 16) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (wGPR rt (xor_vec w__0 (mips_zero_extend 64 imm)))
    : M (unit).

Definition execute_XOR (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 => (wGPR rd (xor_vec w__0 w__1))  : M (unit).

Definition execute_WAIT '(tt : unit) : M (unit) :=
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   write_reg NextPC_ref w__1
    : M (unit).

Definition execute_TRAPREG (rs : mword 5) (rt : mword 5) (cmp : Comparison) : M (unit) :=
   (rGPR rs) >>= fun rs_val =>
   (rGPR rt) >>= fun rt_val =>
   let condition := compare cmp rs_val rt_val in
   (if sumbool_of_bool condition then (SignalException Tr)  : M (unit)
    else returnm tt)
    : M (unit).

Definition execute_TRAPIMM (rs : mword 5) (imm : mword 16) (cmp : Comparison) : M (unit) :=
   (rGPR rs) >>= fun rs_val =>
   let imm_val : bits 64 := mips_sign_extend 64 imm in
   let condition := compare cmp rs_val imm_val in
   (if sumbool_of_bool condition then (SignalException Tr)  : M (unit)
    else returnm tt)
    : M (unit).

Definition execute_TLBWR '(tt : unit) : M (unit) :=
   (checkCP0Access tt) >>
   ((read_reg TLBRandom_ref)  : M (mword 6)) >>= fun w__0 : mword 6 =>
   (TLBWriteEntry w__0)
    : M (unit).

Definition execute_TLBWI '(tt : unit) : M (unit) :=
   (checkCP0Access tt) >>
   ((read_reg TLBIndex_ref)  : M (mword 6)) >>= fun w__0 : mword 6 =>
   (TLBWriteEntry w__0)
    : M (unit).

Definition execute_TLBR '(tt : unit) : M (unit) :=
   (checkCP0Access tt) >>
   ((read_reg TLBIndex_ref)  : M (mword 6)) >>= fun w__0 : mword 6 =>
   let i := projT1 (uint w__0) in
   (reg_deref (vec_access_dec TLBEntries i)) >>= fun entry =>
   write_reg TLBPageMask_ref (_get_TLBEntry_pagemask entry) >>
   (_set_TLBEntryHiReg_R TLBEntryHi_ref (_get_TLBEntry_r entry)) >>
   (_set_TLBEntryHiReg_CLGK TLBEntryHi_ref ((cast_unit_vec B0)  : mword 1)) >>
   (_set_TLBEntryHiReg_CLGS TLBEntryHi_ref ((cast_unit_vec B0)  : mword 1)) >>
   (_set_TLBEntryHiReg_CLGU TLBEntryHi_ref ((cast_unit_vec B0)  : mword 1)) >>
   (_set_TLBEntryHiReg_VPN2 TLBEntryHi_ref (_get_TLBEntry_vpn2 entry)) >>
   (_set_TLBEntryHiReg_ASID TLBEntryHi_ref (_get_TLBEntry_asid entry)) >>
   (_set_TLBEntryLoReg_CapS TLBEntryLo0_ref (_get_TLBEntry_caps0 entry)) >>
   (_set_TLBEntryLoReg_CapL TLBEntryLo0_ref (_get_TLBEntry_capl0 entry)) >>
   (_set_TLBEntryLoReg_CapLG TLBEntryLo0_ref (_get_TLBEntry_caplg0 entry)) >>
   (_set_TLBEntryLoReg_PFN TLBEntryLo0_ref (_get_TLBEntry_pfn0 entry)) >>
   (_set_TLBEntryLoReg_C TLBEntryLo0_ref (_get_TLBEntry_c0 entry)) >>
   (_set_TLBEntryLoReg_D TLBEntryLo0_ref (_get_TLBEntry_d0 entry)) >>
   (_set_TLBEntryLoReg_V TLBEntryLo0_ref (_get_TLBEntry_v0 entry)) >>
   (_set_TLBEntryLoReg_G TLBEntryLo0_ref (_get_TLBEntry_g entry)) >>
   (_set_TLBEntryLoReg_CapS TLBEntryLo1_ref (_get_TLBEntry_caps1 entry)) >>
   (_set_TLBEntryLoReg_CapL TLBEntryLo1_ref (_get_TLBEntry_capl1 entry)) >>
   (_set_TLBEntryLoReg_CapLG TLBEntryLo1_ref (_get_TLBEntry_caplg1 entry)) >>
   (_set_TLBEntryLoReg_PFN TLBEntryLo1_ref (_get_TLBEntry_pfn1 entry)) >>
   (_set_TLBEntryLoReg_C TLBEntryLo1_ref (_get_TLBEntry_c1 entry)) >>
   (_set_TLBEntryLoReg_D TLBEntryLo1_ref (_get_TLBEntry_d1 entry)) >>
   (_set_TLBEntryLoReg_V TLBEntryLo1_ref (_get_TLBEntry_v1 entry)) >>
   (_set_TLBEntryLoReg_G TLBEntryLo1_ref (_get_TLBEntry_g entry))
    : M (unit).

Definition execute_TLBP '(tt : unit) : M (unit) :=
   (checkCP0Access tt) >>
   read_reg TLBEntryHi_ref >>= fun w__0 : TLBEntryHiReg =>
   (tlbSearch (_get_TLBEntryHiReg_bits w__0)) >>= fun result =>
   (match result with
    | Some idx =>
       write_reg TLBProbe_ref ('b"0"  : mword 1) >> write_reg TLBIndex_ref idx  : M (unit)
    | None =>
       write_reg TLBProbe_ref ('b"1"  : mword 1) >>
       write_reg TLBIndex_ref ('b"000000"  : mword 6)
        : M (unit)
    end)
    : M (unit).

Definition execute_Store
(width : WordType) (conditional : bool) (base : mword 5) (rt : mword 5) (offset : mword 16)
: M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapper (add_vec (mips_sign_extend 64 offset) w__0) StoreData width) >>= fun vAddr : bits 64 =>
   (rGPR rt) >>= fun rt_val =>
   (if negb (isAddressAligned vAddr width) then (SignalExceptionBadAddr AdES vAddr)  : M (unit)
    else
    (TLBTranslate vAddr StoreData) >>= fun pAddr =>
    if sumbool_of_bool conditional then
      (and_boolM
         (((read_reg CP0LLBit_ref)  : M (mword 1)) >>= fun w__1 : mword 1 =>
          returnm ((bit_to_bool (access_vec_dec w__1 0))  : bool))
         (((read_reg CP0LLAddr_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
          returnm ((eq_vec w__2 pAddr)  : bool))) >>= fun w__3 : bool =>
      (if sumbool_of_bool w__3 then
         (match width with
          | W => (MEMw_conditional_wrapper pAddr 4 (subrange_vec_dec rt_val 31 0))  : M (bool)
          | D => (MEMw_conditional_wrapper pAddr 8 rt_val)  : M (bool)
          | _ => throw (Error_internal_error tt)
          end)
          : M (bool)
       else returnm false) >>= fun success : bool =>
      (wGPR rt (mips_zero_extend 64 (bool_to_bits success)))
       : M (unit)
    else
      (match width with
       | B => (MEMw_wrapper pAddr 1 (subrange_vec_dec rt_val 7 0))  : M (unit)
       | H => (MEMw_wrapper pAddr 2 (subrange_vec_dec rt_val 15 0))  : M (unit)
       | W => (MEMw_wrapper pAddr 4 (subrange_vec_dec rt_val 31 0))  : M (unit)
       | D => (MEMw_wrapper pAddr 8 rt_val)  : M (unit)
       end)
       : M (unit))
    : M (unit).

Definition execute_SYSCALL '(tt : unit) : M (unit) := (SignalException Sys)  : M (unit).

Definition execute_SYNC '(tt : unit) : M (unit) := (MEM_sync tt)  : M (unit).

Definition execute_SWR (base : mword 5) (rt : mword 5) (offset : mword 16) : M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapperUnaligned (add_vec (mips_sign_extend 64 offset) w__0) StoreData WR) >>= fun '(vAddr, size) =>
   (TLBTranslate vAddr StoreData) >>= fun pAddr =>
   (rGPR rt) >>= fun reg_val =>
   let l__12 := size in
   (if sumbool_of_bool (Z.eqb l__12 1) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 7 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__12 2) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 15 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__12 3) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 23 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__12 4) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 31 0))))
       : M (unit)
    else assert_exp' false "../mips/mips_insts.sail 1404:26 - 1404:27" >>= fun _ => exit tt)
    : M (unit).

Definition execute_SWL (base : mword 5) (rt : mword 5) (offset : mword 16) : M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapperUnaligned (add_vec (mips_sign_extend 64 offset) w__0) StoreData WL) >>= fun '(vAddr, size) =>
   (TLBTranslate vAddr StoreData) >>= fun pAddr =>
   (rGPR rt) >>= fun reg_val =>
   let l__8 := size in
   (if sumbool_of_bool (Z.eqb l__8 4) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 31 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__8 3) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 31 8))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__8 2) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 31 16))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__8 1) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 31 24))))
       : M (unit)
    else assert_exp' false "../mips/mips_insts.sail 1383:24 - 1383:25" >>= fun _ => exit tt)
    : M (unit).

Definition execute_SUBU (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun opA =>
   (rGPR rt) >>= fun opB =>
   (if orb (NotWordVal opA) (NotWordVal opB) then
      (undefined_bitvector 64) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit)
    else
      (wGPR rd
         (mips_sign_extend 64 (sub_vec (subrange_vec_dec opA 31 0) (subrange_vec_dec opB 31 0))))
       : M (unit))
    : M (unit).

Definition execute_SUB (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun opA =>
   (rGPR rt) >>= fun opB =>
   (if orb (NotWordVal opA) (NotWordVal opB) then
      (undefined_bitvector 64) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit)
    else
      let temp33 : bits 33 :=
        sub_vec (mips_sign_extend 33 (subrange_vec_dec opA 31 0))
          (mips_sign_extend 33 (subrange_vec_dec opB 31 0)) in
      (if neq_bool (bit_to_bool (access_vec_dec temp33 32)) (bit_to_bool (access_vec_dec temp33 31))
       then
         (SignalException Ov)
          : M (unit)
       else (wGPR rd (mips_sign_extend 64 (subrange_vec_dec temp33 31 0)))  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_SRLV (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   (rGPR rs) >>= fun w__0 : mword 64 =>
   let sa := subrange_vec_dec w__0 4 0 in
   (if NotWordVal temp then
      (undefined_bitvector 64) >>= fun w__1 : mword 64 => (wGPR rd w__1)  : M (unit)
    else
      let rt32 := subrange_vec_dec temp 31 0 in
      (shift_bits_right rt32 sa) >>= fun w__2 : mword (31 - 0 + 1) =>
      (wGPR rd (mips_sign_extend 64 w__2))
       : M (unit))
    : M (unit).

Definition execute_SRL (rt : mword 5) (rd : mword 5) (sa : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   (if NotWordVal temp then
      (undefined_bitvector 64) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit)
    else
      let rt32 := subrange_vec_dec temp 31 0 in
      (shift_bits_right rt32 sa) >>= fun w__1 : mword (31 - 0 + 1) =>
      (wGPR rd (mips_sign_extend 64 w__1))
       : M (unit))
    : M (unit).

Definition execute_SRAV (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   (rGPR rs) >>= fun w__0 : mword 64 =>
   let sa := subrange_vec_dec w__0 4 0 in
   (if NotWordVal temp then
      (undefined_bitvector 64) >>= fun w__1 : mword 64 => (wGPR rd w__1)  : M (unit)
    else
      let rt32 := subrange_vec_dec temp 31 0 in
      (shift_bits_right_arith rt32 sa) >>= fun w__2 : mword (31 - 0 + 1) =>
      (wGPR rd (mips_sign_extend 64 w__2))
       : M (unit))
    : M (unit).

Definition execute_SRA (rt : mword 5) (rd : mword 5) (sa : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   (if NotWordVal temp then
      (undefined_bitvector 64) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit)
    else
      let rt32 := subrange_vec_dec temp 31 0 in
      (shift_bits_right_arith rt32 sa) >>= fun w__1 : mword (31 - 0 + 1) =>
      (wGPR rd (mips_sign_extend 64 w__1))
       : M (unit))
    : M (unit).

Definition execute_SLTU (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rs_val =>
   (rGPR rt) >>= fun rt_val =>
   (wGPR rd
      (mips_zero_extend 64 (if zopz0zI_u rs_val rt_val then 'b"1"  : mword 1 else 'b"0"  : mword 1)))
    : M (unit).

Definition execute_SLTIU (rs : mword 5) (rt : mword 5) (imm : mword 16) : M (unit) :=
   (rGPR rs) >>= fun rs_val =>
   let immext : bits 64 := mips_sign_extend 64 imm in
   (wGPR rt
      (mips_zero_extend 64 (if zopz0zI_u rs_val immext then 'b"1"  : mword 1 else 'b"0"  : mword 1)))
    : M (unit).

Definition execute_SLTI (rs : mword 5) (rt : mword 5) (imm : mword 16) : M (unit) :=
   let imm_val := projT1 (sint imm) in
   (rGPR rs) >>= fun w__0 : mword 64 =>
   let rs_val := projT1 (sint w__0) in
   (wGPR rt
      (mips_zero_extend 64
         (if sumbool_of_bool (Z.ltb rs_val imm_val) then 'b"1"  : mword 1
          else 'b"0"  : mword 1)))
    : M (unit).

Definition execute_SLT (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 =>
   (wGPR rd
      (mips_zero_extend 64 (if zopz0zI_s w__0 w__1 then 'b"1"  : mword 1 else 'b"0"  : mword 1)))
    : M (unit).

Definition execute_SLLV (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   let sa := subrange_vec_dec w__0 4 0 in
   (rGPR rt) >>= fun w__1 : mword 64 =>
   let rt32 := subrange_vec_dec w__1 31 0 in
   (shift_bits_left rt32 sa) >>= fun w__2 : mword (31 - 0 + 1) =>
   (wGPR rd (mips_sign_extend 64 w__2))
    : M (unit).

Definition execute_SLL (rt : mword 5) (rd : mword 5) (sa : mword 5) : M (unit) :=
   (rGPR rt) >>= fun w__0 : mword 64 =>
   let rt32 := subrange_vec_dec w__0 31 0 in
   (shift_bits_left rt32 sa) >>= fun w__1 : mword (31 - 0 + 1) =>
   (wGPR rd (mips_sign_extend 64 w__1))
    : M (unit).

Definition execute_SDR (base : mword 5) (rt : mword 5) (offset : mword 16) : M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapperUnaligned (add_vec (mips_sign_extend 64 offset) w__0) StoreData DR) >>= fun '(vAddr, size) =>
   (TLBTranslate vAddr StoreData) >>= fun pAddr =>
   (rGPR rt) >>= fun reg_val =>
   let l__40 := size in
   (if sumbool_of_bool (Z.eqb l__40 1) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 7 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__40 2) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 15 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__40 3) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 23 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__40 4) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 31 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__40 5) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 39 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__40 6) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 47 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__40 7) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 55 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__40 8) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 63 0))))
       : M (unit)
    else assert_exp' false "../mips/mips_insts.sail 1509:24 - 1509:25" >>= fun _ => exit tt)
    : M (unit).

Definition execute_SDL (base : mword 5) (rt : mword 5) (offset : mword 16) : M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapperUnaligned (add_vec (mips_sign_extend 64 offset) w__0) StoreData DL) >>= fun '(vAddr, size) =>
   (TLBTranslate vAddr StoreData) >>= fun pAddr =>
   (rGPR rt) >>= fun reg_val =>
   let l__32 := size in
   (if sumbool_of_bool (Z.eqb l__32 8) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 63 0))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__32 7) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 63 8))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__32 6) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 63 16))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__32 5) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 63 24))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__32 4) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 63 32))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__32 3) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 63 40))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__32 2) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 63 48))))
       : M (unit)
    else if sumbool_of_bool (Z.eqb l__32 1) then
      (MEMw_wrapper pAddr size (autocast (autocast (subrange_vec_dec reg_val 63 56))))
       : M (unit)
    else assert_exp' false "../mips/mips_insts.sail 1482:24 - 1482:25" >>= fun _ => exit tt)
    : M (unit).

Definition execute_RI '(tt : unit) : M (unit) := (skip tt) >> (SignalException ResI)  : M (unit).

Definition execute_RDHWR (rt : mword 5) (rd : mword 5) : M (unit) :=
   (getAccessLevel tt) >>= fun accessLevel =>
   let haveAccessLevel : bool := generic_eq accessLevel Kernel in
   read_reg CP0Status_ref >>= fun w__0 : StatusReg =>
   let haveCU0 : bool := eq_bit B1 (access_vec_dec (_get_StatusReg_CU w__0) 0) in
   let rdi := projT1 (uint rd) in
   ((read_reg CP0HWREna_ref)  : M (mword 32)) >>= fun w__1 : mword 32 =>
   let haveHWREna : bool := eq_bit B1 (access_vec_dec w__1 rdi) in
   (if sumbool_of_bool (negb (orb haveAccessLevel (orb haveCU0 haveHWREna))) then
      (SignalException ResI)
       : M (unit)
    else returnm tt) >>
   let b__102 := rd in
   (if eq_vec b__102 ('b"00000"  : mword 5) then returnm (mips_zero_extend 64 ('b"0"  : mword 1))
    else if eq_vec b__102 ('b"00001"  : mword 5) then
      returnm (mips_zero_extend 64 ('b"0"  : mword 1))
    else if eq_vec b__102 ('b"00010"  : mword 5) then
      ((read_reg CP0Count_ref)  : M (mword 32)) >>= fun w__2 : mword 32 =>
      returnm (mips_zero_extend 64 w__2)
    else if eq_vec b__102 ('b"00011"  : mword 5) then
      returnm (mips_zero_extend 64 ('b"1"  : mword 1))
    else if eq_vec b__102 ('b"11101"  : mword 5) then
      ((read_reg CP0UserLocal_ref)  : M (mword 64))
       : M (mword 64)
    else (SignalException ResI)  : M (mword 64)) >>= fun temp : bits 64 =>
   (wGPR rt temp)
    : M (unit).

Definition execute_ORI (rs : mword 5) (rt : mword 5) (imm : mword 16) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (wGPR rt (or_vec w__0 (mips_zero_extend 64 imm)))
    : M (unit).

Definition execute_OR (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 => (wGPR rd (or_vec w__0 w__1))  : M (unit).

Definition execute_NOR (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 => (wGPR rd (not_vec (or_vec w__0 w__1)))  : M (unit).

Definition execute_MULTU (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rsVal =>
   (rGPR rt) >>= fun rtVal =>
   (if orb (NotWordVal rsVal) (NotWordVal rtVal) then (undefined_bitvector 64)  : M (mword 64)
    else returnm (mult_vec (subrange_vec_dec rsVal 31 0) (subrange_vec_dec rtVal 31 0))) >>= fun result : bits 64 =>
   write_reg HI_ref (mips_sign_extend 64 (subrange_vec_dec result 63 32)) >>
   write_reg LO_ref (mips_sign_extend 64 (subrange_vec_dec result 31 0))
    : M (unit).

Definition execute_MULT (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rsVal =>
   (rGPR rt) >>= fun rtVal =>
   (if orb (NotWordVal rsVal) (NotWordVal rtVal) then (undefined_bitvector 64)  : M (mword 64)
    else returnm (mults_vec (subrange_vec_dec rsVal 31 0) (subrange_vec_dec rtVal 31 0))) >>= fun result : bits 64 =>
   write_reg HI_ref (mips_sign_extend 64 (subrange_vec_dec result 63 32)) >>
   write_reg LO_ref (mips_sign_extend 64 (subrange_vec_dec result 31 0))
    : M (unit).

Definition execute_MUL (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rsVal =>
   (rGPR rt) >>= fun rtVal =>
   let result : bits 64 :=
     mips_sign_extend 64 (mults_vec (subrange_vec_dec rsVal 31 0) (subrange_vec_dec rtVal 31 0)) in
   (if orb (NotWordVal rsVal) (NotWordVal rtVal) then (undefined_bitvector 64)  : M (mword 64)
    else returnm (mips_sign_extend 64 (subrange_vec_dec result 31 0))) >>= fun w__1 : mword 64 =>
   (wGPR rd w__1)
    : M (unit).

Definition execute_MTLO (rs : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 => write_reg LO_ref w__0  : M (unit).

Definition execute_MTHI (rs : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 => write_reg HI_ref w__0  : M (unit).

Definition execute_MTC0 (rt : mword 5) (rd : mword 5) (sel : mword 3) (double : bool) : M (unit) :=
   (checkCP0Access tt) >>
   (rGPR rt) >>= fun reg_val =>
   (match (rd, sel) with
    | (b__64, b__65) =>
       (if andb (eq_vec b__64 ('b"00000"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          write_reg TLBIndex_ref (mask 6 reg_val)
           : M (unit)
        else if andb (eq_vec b__64 ('b"00001"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          returnm tt
        else if andb (eq_vec b__64 ('b"00010"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          (_set_TLBEntryLoReg_bits TLBEntryLo0_ref reg_val)
           : M (unit)
        else if andb (eq_vec b__64 ('b"00011"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          (_set_TLBEntryLoReg_bits TLBEntryLo1_ref reg_val)
           : M (unit)
        else if andb (eq_vec b__64 ('b"00100"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          (_set_ContextReg_PTEBase TLBContext_ref (subrange_vec_dec reg_val 63 23))
           : M (unit)
        else if andb (eq_vec b__64 ('b"00100"  : mword 5)) (eq_vec b__65 ('b"010"  : mword 3)) then
          write_reg CP0UserLocal_ref reg_val
           : M (unit)
        else if andb (eq_vec b__64 ('b"00101"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          write_reg TLBPageMask_ref (subrange_vec_dec reg_val 28 13)
           : M (unit)
        else if andb (eq_vec b__64 ('b"00110"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          write_reg TLBWired_ref (mask 6 reg_val) >> write_reg TLBRandom_ref TLBIndexMax  : M (unit)
        else if andb (eq_vec b__64 ('b"00111"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          write_reg
            CP0HWREna_ref
            (concat_vec (subrange_vec_dec reg_val 31 29)
               (concat_vec ('b"0000000000000000000000000"  : mword 25)
                  (subrange_vec_dec reg_val 3 0)))
           : M (unit)
        else if andb (eq_vec b__64 ('b"01000"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          returnm tt
        else if andb (eq_vec b__64 ('b"01001"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          write_reg CP0Count_ref (subrange_vec_dec reg_val 31 0)
           : M (unit)
        else if andb (eq_vec b__64 ('b"01010"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          (_set_TLBEntryHiReg_R TLBEntryHi_ref (subrange_vec_dec reg_val 63 62)) >>
          (_set_TLBEntryHiReg_CLGK TLBEntryHi_ref
             ((cast_unit_vec (access_vec_dec reg_val 61))
              : mword 1)) >>
          (_set_TLBEntryHiReg_CLGS TLBEntryHi_ref
             ((cast_unit_vec (access_vec_dec reg_val 60))
              : mword 1)) >>
          (_set_TLBEntryHiReg_CLGU TLBEntryHi_ref
             ((cast_unit_vec (access_vec_dec reg_val 59))
              : mword 1)) >>
          (_set_TLBEntryHiReg_VPN2 TLBEntryHi_ref (subrange_vec_dec reg_val 39 13)) >>
          (_set_TLBEntryHiReg_ASID TLBEntryHi_ref (subrange_vec_dec reg_val 7 0))
           : M (unit)
        else if andb (eq_vec b__64 ('b"01011"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          write_reg CP0Compare_ref (subrange_vec_dec reg_val 31 0) >>
          read_reg CP0Cause_ref >>= fun w__0 : CauseReg =>
          (_set_CauseReg_IP CP0Cause_ref (and_vec (_get_CauseReg_IP w__0) (Ox"7F"  : mword 8)))
           : M (unit)
        else if andb (eq_vec b__64 ('b"01100"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          (_set_StatusReg_CU CP0Status_ref
             (and_vec (subrange_vec_dec reg_val 31 28)
                (concat_vec ('b"0"  : mword 1)
                   (concat_vec (bool_to_bits have_cp2) ('b"01"  : mword 2))))) >>
          (_set_StatusReg_BEV CP0Status_ref ((cast_unit_vec (access_vec_dec reg_val 22))  : mword 1)) >>
          (_set_StatusReg_IM CP0Status_ref (subrange_vec_dec reg_val 15 8)) >>
          (_set_StatusReg_KX CP0Status_ref ((cast_unit_vec (access_vec_dec reg_val 7))  : mword 1)) >>
          (_set_StatusReg_SX CP0Status_ref ((cast_unit_vec (access_vec_dec reg_val 6))  : mword 1)) >>
          (_set_StatusReg_UX CP0Status_ref ((cast_unit_vec (access_vec_dec reg_val 5))  : mword 1)) >>
          (_set_StatusReg_KSU CP0Status_ref (subrange_vec_dec reg_val 4 3)) >>
          (_set_StatusReg_ERL CP0Status_ref ((cast_unit_vec (access_vec_dec reg_val 2))  : mword 1)) >>
          (_set_StatusReg_EXL CP0Status_ref ((cast_unit_vec (access_vec_dec reg_val 1))  : mword 1)) >>
          (_set_StatusReg_IE CP0Status_ref ((cast_unit_vec (access_vec_dec reg_val 0))  : mword 1))
           : M (unit)
        else if andb (eq_vec b__64 ('b"01101"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          (_set_CauseReg_IV CP0Cause_ref ((cast_unit_vec (access_vec_dec reg_val 23))  : mword 1)) >>
          read_reg CP0Cause_ref >>= fun w__1 : CauseReg =>
          let ip := _get_CauseReg_IP w__1 in
          (_set_CauseReg_IP CP0Cause_ref
             (concat_vec (subrange_vec_dec ip 7 2) (subrange_vec_dec reg_val 9 8)))
           : M (unit)
        else if andb (eq_vec b__64 ('b"01110"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          (set_CP0EPC reg_val)
           : M (unit)
        else if andb (eq_vec b__64 ('b"10000"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          write_reg CP0ConfigK0_ref (subrange_vec_dec reg_val 2 0)
           : M (unit)
        else if andb (eq_vec b__64 ('b"10100"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          (_set_XContextReg_XPTEBase TLBXContext_ref (subrange_vec_dec reg_val 63 33))
           : M (unit)
        else if andb (eq_vec b__64 ('b"11110"  : mword 5)) (eq_vec b__65 ('b"000"  : mword 3)) then
          (set_CP0ErrorEPC reg_val)
           : M (unit)
        else (SignalException ResI)  : M (unit))
        : M (unit)
    end)
    : M (unit).

Definition execute_MSUBU (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rsVal =>
   (rGPR rt) >>= fun rtVal =>
   (if orb (NotWordVal rsVal) (NotWordVal rtVal) then (undefined_bitvector 64)  : M (mword 64)
    else returnm (mult_vec (subrange_vec_dec rsVal 31 0) (subrange_vec_dec rtVal 31 0))) >>= fun mul_result : bits 64 =>
   ((read_reg HI_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   ((read_reg LO_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   let result :=
     sub_vec (concat_vec (subrange_vec_dec w__1 31 0) (subrange_vec_dec w__2 31 0)) mul_result in
   write_reg HI_ref (mips_sign_extend 64 (subrange_vec_dec result 63 32)) >>
   write_reg LO_ref (mips_sign_extend 64 (subrange_vec_dec result 31 0))
    : M (unit).

Definition execute_MSUB (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rsVal =>
   (rGPR rt) >>= fun rtVal =>
   (if orb (NotWordVal rsVal) (NotWordVal rtVal) then (undefined_bitvector 64)  : M (mword 64)
    else returnm (mults_vec (subrange_vec_dec rsVal 31 0) (subrange_vec_dec rtVal 31 0))) >>= fun mul_result : bits 64 =>
   ((read_reg HI_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   ((read_reg LO_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   let result :=
     sub_vec (concat_vec (subrange_vec_dec w__1 31 0) (subrange_vec_dec w__2 31 0)) mul_result in
   write_reg HI_ref (mips_sign_extend 64 (subrange_vec_dec result 63 32)) >>
   write_reg LO_ref (mips_sign_extend 64 (subrange_vec_dec result 31 0))
    : M (unit).

Definition execute_MOVZ (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rt) >>= fun w__0 : mword 64 =>
   (if eq_vec w__0 (Ox"0000000000000000"  : mword 64) then
      (rGPR rs) >>= fun w__1 : mword 64 => (wGPR rd w__1)  : M (unit)
    else returnm tt)
    : M (unit).

Definition execute_MOVN (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rt) >>= fun w__0 : mword 64 =>
   (if neq_vec w__0 (Ox"0000000000000000"  : mword 64) then
      (rGPR rs) >>= fun w__1 : mword 64 => (wGPR rd w__1)  : M (unit)
    else returnm tt)
    : M (unit).

Definition execute_MFLO (rd : mword 5) : M (unit) :=
   ((read_reg LO_ref)  : M (mword 64)) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit).

Definition execute_MFHI (rd : mword 5) : M (unit) :=
   ((read_reg HI_ref)  : M (mword 64)) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit).

Definition execute_MFC0 (rt : mword 5) (rd : mword 5) (sel : mword 3) (double : bool) : M (unit) :=
   (checkCP0Access tt) >>
   (match (rd, sel) with
    | (b__0, b__1) =>
       (if andb (eq_vec b__0 ('b"00000"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg TLBIndex_ref)  : M (mword 6)) >>= fun w__0 : mword 6 =>
          let idx : bits 31 := mips_zero_extend 31 w__0 in
          ((read_reg TLBProbe_ref)  : M (mword 1)) >>= fun w__1 : mword 1 =>
          returnm (concat_vec (Ox"00000000"  : mword 32) (concat_vec w__1 idx))
        else if andb (eq_vec b__0 ('b"00001"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg TLBRandom_ref)  : M (mword 6)) >>= fun w__2 : mword 6 =>
          returnm (mips_zero_extend 64 w__2)
        else if andb (eq_vec b__0 ('b"00010"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          read_reg TLBEntryLo0_ref >>= fun w__3 : TLBEntryLoReg =>
          returnm (_get_TLBEntryLoReg_bits w__3)
        else if andb (eq_vec b__0 ('b"00011"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          read_reg TLBEntryLo1_ref >>= fun w__4 : TLBEntryLoReg =>
          returnm (_get_TLBEntryLoReg_bits w__4)
        else if andb (eq_vec b__0 ('b"00100"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          read_reg TLBContext_ref >>= fun w__5 : ContextReg => returnm (_get_ContextReg_bits w__5)
        else if andb (eq_vec b__0 ('b"00100"  : mword 5)) (eq_vec b__1 ('b"010"  : mword 3)) then
          ((read_reg CP0UserLocal_ref)  : M (mword 64))
           : M (mword 64)
        else if andb (eq_vec b__0 ('b"00101"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg TLBPageMask_ref)  : M (mword 16)) >>= fun w__7 : mword 16 =>
          returnm (mips_zero_extend 64 (concat_vec w__7 (Ox"000"  : mword 12)))
        else if andb (eq_vec b__0 ('b"00110"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg TLBWired_ref)  : M (mword 6)) >>= fun w__8 : mword 6 =>
          returnm (mips_zero_extend 64 w__8)
        else if andb (eq_vec b__0 ('b"00111"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg CP0HWREna_ref)  : M (mword 32)) >>= fun w__9 : mword 32 =>
          returnm (mips_zero_extend 64 w__9)
        else if andb (eq_vec b__0 ('b"01000"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg CP0BadVAddr_ref)  : M (mword 64))
           : M (mword 64)
        else if andb (eq_vec b__0 ('b"01000"  : mword 5)) (eq_vec b__1 ('b"001"  : mword 3)) then
          ((read_reg CP0BadInstr_ref)  : M (mword 32)) >>= fun w__11 : mword 32 =>
          returnm (mips_zero_extend 64 w__11)
        else if andb (eq_vec b__0 ('b"01000"  : mword 5)) (eq_vec b__1 ('b"010"  : mword 3)) then
          ((read_reg CP0BadInstrP_ref)  : M (mword 32)) >>= fun w__12 : mword 32 =>
          returnm (mips_zero_extend 64 w__12)
        else if andb (eq_vec b__0 ('b"01001"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg CP0Count_ref)  : M (mword 32)) >>= fun w__13 : mword 32 =>
          returnm (mips_zero_extend 64 w__13)
        else if andb (eq_vec b__0 ('b"01010"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          read_reg TLBEntryHi_ref >>= fun w__14 : TLBEntryHiReg =>
          returnm (_get_TLBEntryHiReg_bits w__14)
        else if andb (eq_vec b__0 ('b"01011"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg CP0Compare_ref)  : M (mword 32)) >>= fun w__15 : mword 32 =>
          returnm (mips_zero_extend 64 w__15)
        else if andb (eq_vec b__0 ('b"01100"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          read_reg CP0Status_ref >>= fun w__16 : StatusReg =>
          returnm (mips_zero_extend 64 (_get_StatusReg_bits w__16))
        else if andb (eq_vec b__0 ('b"01101"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          read_reg CP0Cause_ref >>= fun w__17 : CauseReg =>
          returnm (mips_zero_extend 64 (_get_CauseReg_bits w__17))
        else if andb (eq_vec b__0 ('b"01110"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          (get_CP0EPC tt)
           : M (mword 64)
        else if andb (eq_vec b__0 ('b"01111"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          returnm (mips_zero_extend 64 (Ox"00000405"  : mword 32))
        else if andb (eq_vec b__0 ('b"01111"  : mword 5)) (eq_vec b__1 ('b"110"  : mword 3)) then
          returnm (mips_zero_extend 64 ('b"0"  : mword 1))
        else if andb (eq_vec b__0 ('b"01111"  : mword 5)) (eq_vec b__1 ('b"111"  : mword 3)) then
          returnm (mips_zero_extend 64 ('b"0"  : mword 1))
        else if andb (eq_vec b__0 ('b"10000"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg CP0ConfigK0_ref)  : M (mword 3)) >>= fun w__19 : mword 3 =>
          returnm (mips_zero_extend 64
                     (concat_vec ('b"1"  : mword 1)
                        (concat_vec ('b"000000000000000"  : mword 15)
                           (concat_vec ('b"1"  : mword 1)
                              (concat_vec ('b"10"  : mword 2)
                                 (concat_vec ('b"000"  : mword 3)
                                    (concat_vec ('b"001"  : mword 3)
                                       (concat_vec (Ox"0"  : mword 4) w__19))))))))
        else if andb (eq_vec b__0 ('b"10000"  : mword 5)) (eq_vec b__1 ('b"001"  : mword 3)) then
          returnm (mips_zero_extend 64
                     (concat_vec ('b"1"  : mword 1)
                        (concat_vec TLBIndexMax
                           (concat_vec ('b"000"  : mword 3)
                              (concat_vec ('b"000"  : mword 3)
                                 (concat_vec ('b"000"  : mword 3)
                                    (concat_vec ('b"000"  : mword 3)
                                       (concat_vec ('b"000"  : mword 3)
                                          (concat_vec ('b"000"  : mword 3)
                                             (concat_vec (bool_to_bits have_cp2)
                                                (concat_vec ('b"0"  : mword 1)
                                                   (concat_vec ('b"0"  : mword 1)
                                                      (concat_vec ('b"0"  : mword 1)
                                                         (concat_vec ('b"0"  : mword 1)
                                                            (concat_vec ('b"0"  : mword 1)
                                                               ('b"0"
                                                                : mword 1))))))))))))))))
        else if andb (eq_vec b__0 ('b"10000"  : mword 5)) (eq_vec b__1 ('b"010"  : mword 3)) then
          returnm (mips_zero_extend 64
                     (concat_vec ('b"1"  : mword 1)
                        (concat_vec ('b"000"  : mword 3)
                           (concat_vec (Ox"0"  : mword 4)
                              (concat_vec (Ox"0"  : mword 4)
                                 (concat_vec (Ox"0"  : mword 4)
                                    (concat_vec (Ox"0"  : mword 4)
                                       (concat_vec (Ox"0"  : mword 4)
                                          (concat_vec (Ox"0"  : mword 4) (Ox"0"  : mword 4))))))))))
        else if andb (eq_vec b__0 ('b"10000"  : mword 5)) (eq_vec b__1 ('b"011"  : mword 3)) then
          returnm (Ox"000000000C002000"  : mword 64)
        else if andb (eq_vec b__0 ('b"10000"  : mword 5)) (eq_vec b__1 ('b"101"  : mword 3)) then
          returnm (Ox"0000000000000000"  : mword 64)
        else if andb (eq_vec b__0 ('b"10000"  : mword 5)) (eq_vec b__1 ('b"110"  : mword 3)) then
          returnm (Ox"0000000000000000"  : mword 64)
        else if andb (eq_vec b__0 ('b"10001"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          ((read_reg CP0LLAddr_ref)  : M (mword 64))
           : M (mword 64)
        else if andb (eq_vec b__0 ('b"10010"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          returnm (mips_zero_extend 64 ('b"0"  : mword 1))
        else if andb (eq_vec b__0 ('b"10011"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          returnm (mips_zero_extend 64 ('b"0"  : mword 1))
        else if andb (eq_vec b__0 ('b"10100"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          read_reg TLBXContext_ref >>= fun w__21 : XContextReg =>
          returnm (_get_XContextReg_bits w__21)
        else if andb (eq_vec b__0 ('b"11110"  : mword 5)) (eq_vec b__1 ('b"000"  : mword 3)) then
          (get_CP0ErrorEPC tt)
           : M (mword 64)
        else (SignalException ResI)  : M (mword 64))
        : M (mword 64)
    end) >>= fun result : bits 64 =>
   (wGPR rt
      (if sumbool_of_bool double then result
       else mips_sign_extend 64 (subrange_vec_dec result 31 0)))
    : M (unit).

Definition execute_MADDU (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rsVal =>
   (rGPR rt) >>= fun rtVal =>
   (if orb (NotWordVal rsVal) (NotWordVal rtVal) then (undefined_bitvector 64)  : M (mword 64)
    else returnm (mult_vec (subrange_vec_dec rsVal 31 0) (subrange_vec_dec rtVal 31 0))) >>= fun mul_result : bits 64 =>
   ((read_reg HI_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   ((read_reg LO_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   let result :=
     add_vec mul_result (concat_vec (subrange_vec_dec w__1 31 0) (subrange_vec_dec w__2 31 0)) in
   write_reg HI_ref (mips_sign_extend 64 (subrange_vec_dec result 63 32)) >>
   write_reg LO_ref (mips_sign_extend 64 (subrange_vec_dec result 31 0))
    : M (unit).

Definition execute_MADD (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rsVal =>
   (rGPR rt) >>= fun rtVal =>
   (if orb (NotWordVal rsVal) (NotWordVal rtVal) then (undefined_bitvector 64)  : M (mword 64)
    else returnm (mults_vec (subrange_vec_dec rsVal 31 0) (subrange_vec_dec rtVal 31 0))) >>= fun mul_result : bits 64 =>
   ((read_reg HI_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   ((read_reg LO_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   let result :=
     add_vec mul_result (concat_vec (subrange_vec_dec w__1 31 0) (subrange_vec_dec w__2 31 0)) in
   write_reg HI_ref (mips_sign_extend 64 (subrange_vec_dec result 63 32)) >>
   write_reg LO_ref (mips_sign_extend 64 (subrange_vec_dec result 31 0))
    : M (unit).

Definition execute_Load
(width : WordType) (sign : bool) (linked : bool) (base : mword 5) (rt : mword 5) (offset : mword 16)
: M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapper (add_vec (mips_sign_extend 64 offset) w__0) LoadData width) >>= fun vAddr : bits 64 =>
   (if negb (isAddressAligned vAddr width) then (SignalExceptionBadAddr AdEL vAddr)  : M (unit)
    else
      (TLBTranslate vAddr LoadData) >>= fun pAddr =>
      (if sumbool_of_bool linked then
         write_reg CP0LLBit_ref ('b"1"  : mword 1) >>
         write_reg CP0LLAddr_ref pAddr >>
         (match width with
          | W =>
             (MEMr_reserve_wrapper pAddr 4) >>= fun w__1 : mword (8 * 4) =>
             returnm (extendLoad w__1 sign)
          | D =>
             (MEMr_reserve_wrapper pAddr 8) >>= fun w__2 : mword (8 * 8) =>
             returnm (extendLoad w__2 sign)
          | _ => throw (Error_internal_error tt)
          end)
          : M (mword 64)
       else
         (match width with
          | B =>
             (MEMr_wrapper pAddr 1) >>= fun w__5 : mword (8 * 1) => returnm (extendLoad w__5 sign)
          | H =>
             (MEMr_wrapper pAddr 2) >>= fun w__6 : mword (8 * 2) => returnm (extendLoad w__6 sign)
          | W =>
             (MEMr_wrapper pAddr 4) >>= fun w__7 : mword (8 * 4) => returnm (extendLoad w__7 sign)
          | D =>
             (MEMr_wrapper pAddr 8) >>= fun w__8 : mword (8 * 8) => returnm (extendLoad w__8 sign)
          end)
          : M (mword 64)) >>= fun memResult : bits 64 =>
      (wGPR rt memResult)
       : M (unit))
    : M (unit).

Definition execute_LWR (base : mword 5) (rt : mword 5) (offset : mword 16) : M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapperUnaligned (add_vec (mips_sign_extend 64 offset) w__0) LoadData WR) >>= fun '(vAddr, size) =>
   (TLBTranslate vAddr LoadData) >>= fun pAddr =>
   (rGPR rt) >>= fun reg_val =>
   let l__4 := size in
   (if sumbool_of_bool (Z.eqb l__4 1) then
      (MEMr_wrapper pAddr size) >>= fun w__1 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 31 8) w__1)))
    else if sumbool_of_bool (Z.eqb l__4 2) then
      (MEMr_wrapper pAddr size) >>= fun w__2 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 31 16) w__2)))
    else if sumbool_of_bool (Z.eqb l__4 3) then
      (MEMr_wrapper pAddr size) >>= fun w__3 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 31 24) w__3)))
    else if sumbool_of_bool (Z.eqb l__4 4) then (MEMr_wrapper pAddr _)  : M (mword (8 * 4))
    else assert_exp' false "../mips/mips_insts.sail 1360:21 - 1360:22" >>= fun _ => exit tt) >>= fun result : bits 32 =>
   (wGPR rt (mips_sign_extend 64 result))
    : M (unit).

Definition execute_LWL (base : mword 5) (rt : mword 5) (offset : mword 16) : M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapperUnaligned (add_vec (mips_sign_extend 64 offset) w__0) LoadData WL) >>= fun '(vAddr, size) =>
   (TLBTranslate vAddr LoadData) >>= fun pAddr =>
   (rGPR rt) >>= fun reg_val =>
   let l__0 := size in
   (if sumbool_of_bool (Z.eqb l__0 4) then (MEMr_wrapper pAddr _)  : M (mword (8 * 4))
    else if sumbool_of_bool (Z.eqb l__0 3) then
      (MEMr_wrapper pAddr size) >>= fun w__2 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__2 (subrange_vec_dec reg_val 7 0))))
    else if sumbool_of_bool (Z.eqb l__0 2) then
      (MEMr_wrapper pAddr size) >>= fun w__3 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__3 (subrange_vec_dec reg_val 15 0))))
    else if sumbool_of_bool (Z.eqb l__0 1) then
      (MEMr_wrapper pAddr size) >>= fun w__4 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__4 (subrange_vec_dec reg_val 23 0))))
    else assert_exp' false "../mips/mips_insts.sail 1339:21 - 1339:22" >>= fun _ => exit tt) >>= fun result : bits 32 =>
   (wGPR rt (mips_sign_extend 64 result))
    : M (unit).

Definition execute_LUI (rt : mword 5) (imm : mword 16) : M (unit) :=
   (wGPR rt (mips_sign_extend 64 (concat_vec imm (Ox"0000"  : mword 16))))  : M (unit).

Definition execute_LDR (base : mword 5) (rt : mword 5) (offset : mword 16) : M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapperUnaligned (add_vec (mips_sign_extend 64 offset) w__0) LoadData DR) >>= fun '(vAddr, size) =>
   (TLBTranslate vAddr LoadData) >>= fun pAddr =>
   (rGPR rt) >>= fun reg_val =>
   let l__24 := size in
   (if sumbool_of_bool (Z.eqb l__24 1) then
      (MEMr_wrapper pAddr size) >>= fun w__1 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 63 8) w__1)))
    else if sumbool_of_bool (Z.eqb l__24 2) then
      (MEMr_wrapper pAddr size) >>= fun w__2 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 63 16) w__2)))
    else if sumbool_of_bool (Z.eqb l__24 3) then
      (MEMr_wrapper pAddr size) >>= fun w__3 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 63 24) w__3)))
    else if sumbool_of_bool (Z.eqb l__24 4) then
      (MEMr_wrapper pAddr size) >>= fun w__4 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 63 32) w__4)))
    else if sumbool_of_bool (Z.eqb l__24 5) then
      (MEMr_wrapper pAddr size) >>= fun w__5 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 63 40) w__5)))
    else if sumbool_of_bool (Z.eqb l__24 6) then
      (MEMr_wrapper pAddr size) >>= fun w__6 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 63 48) w__6)))
    else if sumbool_of_bool (Z.eqb l__24 7) then
      (MEMr_wrapper pAddr size) >>= fun w__7 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec (subrange_vec_dec reg_val 63 56) w__7)))
    else if sumbool_of_bool (Z.eqb l__24 8) then (MEMr_wrapper pAddr _)  : M (mword (8 * 8))
    else assert_exp' false "../mips/mips_insts.sail 1456:21 - 1456:22" >>= fun _ => exit tt) >>= fun w__16 : mword 64 =>
   (wGPR rt w__16)
    : M (unit).

Definition execute_LDL (base : mword 5) (rt : mword 5) (offset : mword 16) : M (unit) :=
   (rGPR base) >>= fun w__0 : mword 64 =>
   (addrWrapperUnaligned (add_vec (mips_sign_extend 64 offset) w__0) LoadData DL) >>= fun '(vAddr, size) =>
   (TLBTranslate vAddr LoadData) >>= fun pAddr =>
   (rGPR rt) >>= fun reg_val =>
   let l__16 := size in
   (if sumbool_of_bool (Z.eqb l__16 8) then (MEMr_wrapper pAddr _)  : M (mword (8 * 8))
    else if sumbool_of_bool (Z.eqb l__16 7) then
      (MEMr_wrapper pAddr size) >>= fun w__2 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__2 (subrange_vec_dec reg_val 7 0))))
    else if sumbool_of_bool (Z.eqb l__16 6) then
      (MEMr_wrapper pAddr size) >>= fun w__3 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__3 (subrange_vec_dec reg_val 15 0))))
    else if sumbool_of_bool (Z.eqb l__16 5) then
      (MEMr_wrapper pAddr size) >>= fun w__4 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__4 (subrange_vec_dec reg_val 23 0))))
    else if sumbool_of_bool (Z.eqb l__16 4) then
      (MEMr_wrapper pAddr size) >>= fun w__5 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__5 (subrange_vec_dec reg_val 31 0))))
    else if sumbool_of_bool (Z.eqb l__16 3) then
      (MEMr_wrapper pAddr size) >>= fun w__6 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__6 (subrange_vec_dec reg_val 39 0))))
    else if sumbool_of_bool (Z.eqb l__16 2) then
      (MEMr_wrapper pAddr size) >>= fun w__7 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__7 (subrange_vec_dec reg_val 47 0))))
    else if sumbool_of_bool (Z.eqb l__16 1) then
      (MEMr_wrapper pAddr size) >>= fun w__8 : mword (8 * size) =>
      returnm (autocast (autocast (concat_vec w__8 (subrange_vec_dec reg_val 55 0))))
    else assert_exp' false "../mips/mips_insts.sail 1430:21 - 1430:22" >>= fun _ => exit tt) >>= fun w__16 : mword 64 =>
   (wGPR rt w__16)
    : M (unit).

Definition execute_JR (rs : mword 5) : M (unit) :=
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   (rGPR rs) >>= fun w__1 : mword 64 => (execute_branch w__1)  : M (unit).

Definition execute_JALR (rs : mword 5) (rd : mword 5) : M (unit) :=
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   (rGPR rs) >>= fun w__1 : mword 64 =>
   (execute_branch w__1) >>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   (wGPR rd (add_vec_int w__2 8))
    : M (unit).

Definition execute_JAL (offset : mword 26) : M (unit) :=
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   (execute_branch
      (concat_vec (subrange_vec_dec (add_vec_int w__1 4) 63 28)
         (concat_vec offset ('b"00"  : mword 2)))) >>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   (wGPR ('b"11111"  : mword 5) (add_vec_int w__2 8))
    : M (unit).

Definition execute_J (offset : mword 26) : M (unit) :=
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   (execute_branch
      (concat_vec (subrange_vec_dec (add_vec_int w__1 4) 63 28)
         (concat_vec offset ('b"00"  : mword 2))))
    : M (unit).

Definition execute_HCF '(tt : unit) : unit := tt.

Definition execute_ERET '(tt : unit) : M (unit) :=
   (checkCP0Access tt) >>
   (ERETHook tt) >>
   write_reg CP0LLBit_ref ('b"0"  : mword 1) >>
   read_reg CP0Status_ref >>= fun w__0 : StatusReg =>
   (if Bool.eqb (bits_to_bool (_get_StatusReg_ERL w__0)) (bit_to_bool B1) then
      (get_CP0ErrorEPC tt) >>= fun w__1 : mword 64 =>
      write_reg NextPC_ref w__1 >> (_set_StatusReg_ERL CP0Status_ref ('b"0"  : mword 1))  : M (unit)
    else
      (get_CP0EPC tt) >>= fun w__2 : mword 64 =>
      write_reg NextPC_ref w__2 >> (_set_StatusReg_EXL CP0Status_ref ('b"0"  : mword 1))  : M (unit))
    : M (unit).

Definition execute_DSUBU (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 => (wGPR rd (sub_vec w__0 w__1))  : M (unit).

Definition execute_DSUB (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 =>
   let temp65 : bits 65 := sub_vec (mips_sign_extend 65 w__0) (mips_sign_extend 65 w__1) in
   (if neq_bool (bit_to_bool (access_vec_dec temp65 64)) (bit_to_bool (access_vec_dec temp65 63))
    then
      (SignalException Ov)
       : M (unit)
    else (wGPR rd (subrange_vec_dec temp65 63 0))  : M (unit))
    : M (unit).

Definition execute_DSRLV (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   (rGPR rs) >>= fun w__0 : mword 64 =>
   let sa := subrange_vec_dec w__0 5 0 in
   (shift_bits_right temp sa) >>= fun w__1 : mword 64 => (wGPR rd w__1)  : M (unit).

Definition execute_DSRL32 (rt : mword 5) (rd : mword 5) (sa : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   let sa32 := concat_vec ('b"1"  : mword 1) sa in
   (shift_bits_right temp sa32) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit).

Definition execute_DSRL (rt : mword 5) (rd : mword 5) (sa : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   (shift_bits_right temp sa) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit).

Definition execute_DSRAV (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   (rGPR rs) >>= fun w__0 : mword 64 =>
   let sa := subrange_vec_dec w__0 5 0 in
   (shift_bits_right_arith temp sa) >>= fun w__1 : mword 64 => (wGPR rd w__1)  : M (unit).

Definition execute_DSRA32 (rt : mword 5) (rd : mword 5) (sa : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   let sa32 := concat_vec ('b"1"  : mword 1) sa in
   (shift_bits_right_arith temp sa32) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit).

Definition execute_DSRA (rt : mword 5) (rd : mword 5) (sa : mword 5) : M (unit) :=
   (rGPR rt) >>= fun temp =>
   (shift_bits_right_arith temp sa) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit).

Definition execute_DSLLV (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rt) >>= fun w__0 : mword 64 =>
   (rGPR rs) >>= fun w__1 : mword 64 =>
   (shift_bits_left w__0 (subrange_vec_dec w__1 5 0)) >>= fun w__2 : mword 64 =>
   (wGPR rd w__2)
    : M (unit).

Definition execute_DSLL32 (rt : mword 5) (rd : mword 5) (sa : mword 5) : M (unit) :=
   (rGPR rt) >>= fun w__0 : mword 64 =>
   (shift_bits_left w__0 (concat_vec ('b"1"  : mword 1) sa)) >>= fun w__1 : mword 64 =>
   (wGPR rd w__1)
    : M (unit).

Definition execute_DSLL (rt : mword 5) (rd : mword 5) (sa : mword 5) : M (unit) :=
   (rGPR rt) >>= fun w__0 : mword 64 =>
   (shift_bits_left w__0 sa) >>= fun w__1 : mword 64 => (wGPR rd w__1)  : M (unit).

Definition execute_DMULTU (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 =>
   let result := mult_vec w__0 w__1 in
   write_reg HI_ref (subrange_vec_dec result 127 64) >>
   write_reg LO_ref (subrange_vec_dec result 63 0)
    : M (unit).

Definition execute_DMULT (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 =>
   let result := mults_vec w__0 w__1 in
   write_reg HI_ref (subrange_vec_dec result 127 64) >>
   write_reg LO_ref (subrange_vec_dec result 63 0)
    : M (unit).

Definition execute_DIVU (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rsVal =>
   (rGPR rt) >>= fun rtVal =>
   (if orb (NotWordVal rsVal)
         (orb (NotWordVal rtVal) (eq_vec rtVal (Ox"0000000000000000"  : mword 64))) then
      (undefined_bitvector 32) >>= fun w__0 : mword 32 =>
      (undefined_bitvector 32) >>= fun w__1 : mword 32 => returnm (w__0  : bits 32, w__1  : bits 32)
    else
      let si := projT1 (uint (subrange_vec_dec rsVal 31 0)) in
      let ti := projT1 (uint (subrange_vec_dec rtVal 31 0)) in
      let qi := Z.quot si ti in
      let ri := Z.rem si ti in
      returnm (to_bits 32 qi, to_bits 32 ri)) >>= fun '(q, r) =>
   write_reg HI_ref (mips_sign_extend 64 r) >> write_reg LO_ref (mips_sign_extend 64 q)  : M (unit).

Definition execute_DIV (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun rsVal =>
   (rGPR rt) >>= fun rtVal =>
   (if orb (NotWordVal rsVal)
         (orb (NotWordVal rtVal) (eq_vec rtVal (Ox"0000000000000000"  : mword 64))) then
      (undefined_bitvector 32) >>= fun w__0 : mword 32 =>
      (undefined_bitvector 32) >>= fun w__1 : mword 32 => returnm (w__0  : bits 32, w__1  : bits 32)
    else
      let si := projT1 (sint (subrange_vec_dec rsVal 31 0)) in
      let ti := projT1 (sint (subrange_vec_dec rtVal 31 0)) in
      let qi := Z.quot si ti in
      let ri := Z.sub si (Z.mul ti qi) in
      returnm (to_bits 32 qi, to_bits 32 ri)) >>= fun '(q, r) =>
   write_reg HI_ref (mips_sign_extend 64 r) >> write_reg LO_ref (mips_sign_extend 64 q)  : M (unit).

Definition execute_DDIVU (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   let rsVal := projT1 (uint w__0) in
   (rGPR rt) >>= fun w__1 : mword 64 =>
   let rtVal := projT1 (uint w__1) in
   (if sumbool_of_bool (Z.eqb rtVal 0) then
      (undefined_bitvector 64) >>= fun w__2 : mword 64 =>
      (undefined_bitvector 64) >>= fun w__3 : mword 64 => returnm (w__2  : bits 64, w__3  : bits 64)
    else
      let qi := Z.quot rsVal rtVal in
      let ri := Z.rem rsVal rtVal in
      returnm (to_bits 64 qi, to_bits 64 ri)) >>= fun '(q, r) =>
   write_reg LO_ref q >> write_reg HI_ref r  : M (unit).

Definition execute_DDIV (rs : mword 5) (rt : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   let rsVal := projT1 (sint w__0) in
   (rGPR rt) >>= fun w__1 : mword 64 =>
   let rtVal := projT1 (sint w__1) in
   (if sumbool_of_bool (Z.eqb rtVal 0) then
      (undefined_bitvector 64) >>= fun w__2 : mword 64 =>
      (undefined_bitvector 64) >>= fun w__3 : mword 64 => returnm (w__2  : bits 64, w__3  : bits 64)
    else
      let qi := Z.quot rsVal rtVal in
      let ri := Z.sub rsVal (Z.mul qi rtVal) in
      returnm (to_bits 64 qi, to_bits 64 ri)) >>= fun '(q, r) =>
   write_reg LO_ref q >> write_reg HI_ref r  : M (unit).

Definition execute_DADDU (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 => (wGPR rd (add_vec w__0 w__1))  : M (unit).

Definition execute_DADDIU (rs : mword 5) (rt : mword 5) (imm : mword 16) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (wGPR rt (add_vec w__0 (mips_sign_extend 64 imm)))
    : M (unit).

Definition execute_DADDI (rs : mword 5) (rt : mword 5) (imm : mword 16) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   let sum65 : bits 65 := add_vec (mips_sign_extend 65 w__0) (mips_sign_extend 65 imm) in
   (if neq_bool (bit_to_bool (access_vec_dec sum65 64)) (bit_to_bool (access_vec_dec sum65 63)) then
      (SignalException Ov)
       : M (unit)
    else (wGPR rt (subrange_vec_dec sum65 63 0))  : M (unit))
    : M (unit).

Definition execute_DADD (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 =>
   let sum65 : bits 65 := add_vec (mips_sign_extend 65 w__0) (mips_sign_extend 65 w__1) in
   (if neq_bool (bit_to_bool (access_vec_dec sum65 64)) (bit_to_bool (access_vec_dec sum65 63)) then
      (SignalException Ov)
       : M (unit)
    else (wGPR rd (subrange_vec_dec sum65 63 0))  : M (unit))
    : M (unit).

Definition execute_ClearRegs (regset : ClearRegSet) (m : mword 16) : M (unit) :=
   (if orb (generic_eq regset CLo) (generic_eq regset CHi) then (checkCP2usable tt)  : M (unit)
    else returnm tt) >>
   let loop_i_lower := 0 in
   let loop_i_upper := 15 in
   (foreach_ZM_up loop_i_lower loop_i_upper 1 tt
     (fun i _ _ =>
       (if (bit_to_bool (access_vec_dec m i))  : bool then
          (match regset with
           | GPLo => (wGPR (to_bits 5 i) (zeros_implicit 64 tt))  : M (unit)
           | GPHi => (wGPR (to_bits 5 (Z.add i 16)) (zeros_implicit 64 tt))  : M (unit)
           | CLo =>
              (if sumbool_of_bool (Z.eqb i 0) then write_reg DDC_ref null_cap  : M (unit)
               else (writeCapReg (to_bits 5 i) null_cap)  : M (unit))
               : M (unit)
           | CHi => (writeCapReg (to_bits 5 (Z.add i 16)) null_cap)  : M (unit)
           end)
           : M (unit)
        else returnm tt)
        : M (unit))).

Definition execute_CWriteHwr (cb : mword 5) (sel : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   let l__75 := projT1 (uint sel) in
   (if sumbool_of_bool (Z.eqb l__75 0) then returnm (false, false)
    else if sumbool_of_bool (Z.eqb l__75 1) then returnm (false, false)
    else if sumbool_of_bool (Z.eqb l__75 8) then returnm (false, true)
    else if sumbool_of_bool (Z.eqb l__75 22) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__75 23) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__75 28) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__75 29) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__75 30) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__75 31) then returnm (true, true)
    else (SignalException ResI)  : M ((bool * bool))) >>= fun '((needSup, needAccessSys)
   : (bool * bool)) =>
   (and_boolMP
      ((returnm (build_ex needAccessSys)) : M ({_bool : bool & ArithFact (Bool.eqb needAccessSys _bool)}))
      (build_trivial_ex
      ((pcc_access_system_regs tt) >>= fun w__9 : bool => returnm ((negb w__9)  : bool))) : M ({_bool : bool & ArithFactP (exists simp_1 , Bool.eqb (needAccessSys &&
     simp_1) _bool = true)})) >>= fun '(existT _ w__10 _) =>
   (if sumbool_of_bool w__10 then
      (raise_c2_exception CapEx_AccessSystemRegsViolation sel)
       : M (unit)
    else
    (and_boolMP
       ((returnm (build_ex needSup)) : M ({_bool : bool & ArithFact (Bool.eqb needSup _bool)}))
       (build_trivial_ex
       ((getAccessLevel tt) >>= fun w__11 : AccessLevel =>
        returnm ((negb (grantsAccess w__11 Supervisor))  : bool))) : M ({_bool : bool & ArithFactP (exists simp_1 , Bool.eqb (needSup &&
      simp_1) _bool = true)})) >>= fun '(existT _ w__12 _) =>
    if sumbool_of_bool w__12 then
      (raise_c2_exception CapEx_AccessSystemRegsViolation sel)
       : M (unit)
    else
      (readCapReg cb) >>= fun capVal =>
      let l__66 := projT1 (uint sel) in
      (if sumbool_of_bool (Z.eqb l__66 0) then write_reg DDC_ref capVal  : M (unit)
       else if sumbool_of_bool (Z.eqb l__66 1) then write_reg CULR_ref capVal  : M (unit)
       else if sumbool_of_bool (Z.eqb l__66 8) then write_reg CPLR_ref capVal  : M (unit)
       else if sumbool_of_bool (Z.eqb l__66 22) then write_reg KR1C_ref capVal  : M (unit)
       else if sumbool_of_bool (Z.eqb l__66 23) then write_reg KR2C_ref capVal  : M (unit)
       else if sumbool_of_bool (Z.eqb l__66 28) then write_reg ErrorEPCC_ref capVal  : M (unit)
       else if sumbool_of_bool (Z.eqb l__66 29) then write_reg KCC_ref capVal  : M (unit)
       else if sumbool_of_bool (Z.eqb l__66 30) then write_reg KDC_ref capVal  : M (unit)
       else if sumbool_of_bool (Z.eqb l__66 31) then write_reg EPCC_ref capVal  : M (unit)
       else assert_exp' false "CWriteHwr: should be unreachable code" >>= fun _ => exit tt)
       : M (unit))
    : M (unit).

Definition execute_CUnseal (cd : mword 5) (cs : mword 5) (ct : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cs) >>= fun cs_val =>
   let cs_otype := projT1 (uint cs_val.(Capability_otype)) in
   (readCapReg ct) >>= fun ct_val =>
   let ct_cursor := projT1 (getCapCursor ct_val) in
   (if negb cs_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cs)  : M (unit)
    else if negb ct_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation ct)  : M (unit)
    else if negb cs_val.(Capability_sealed) then
      (raise_c2_exception CapEx_SealViolation cs)
       : M (unit)
    else if ct_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation ct)  : M (unit)
    else if hasReservedOType cs_val then (raise_c2_exception CapEx_TypeViolation cs)  : M (unit)
    else if sumbool_of_bool (projT1 (neq_int ct_cursor cs_otype)) then
      (raise_c2_exception CapEx_TypeViolation ct)
       : M (unit)
    else if negb ct_val.(Capability_permit_unseal) then
      (raise_c2_exception CapEx_PermitUnsealViolation ct)
       : M (unit)
    else if sumbool_of_bool (Z.ltb ct_cursor (projT1 (getCapBase ct_val))) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (unit)
    else if sumbool_of_bool (Z.geb ct_cursor (projT1 (getCapTop ct_val))) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (unit)
    else
      (writeCapReg cd
         {[ (unsealCap cs_val) with
           Capability_global := (andb cs_val.(Capability_global) ct_val.(Capability_global)) ]})
       : M (unit))
    : M (unit).

Definition execute_CToPtr (rd : mword 5) (cb : mword 5) (ct : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC ct) >>= fun ct_val =>
   (readCapReg cb) >>= fun cb_val =>
   (if negb ct_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation ct)  : M (unit)
    else if andb cb_val.(Capability_tag) cb_val.(Capability_sealed) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (unit)
    else
      let ctBase := projT1 (getCapBase ct_val) in
      (wGPR rd
         (if negb cb_val.(Capability_tag) then zeros_implicit 64 tt
          else to_bits 64 (Z.sub (projT1 (getCapCursor cb_val)) ctBase)))
       : M (unit))
    : M (unit).

Definition execute_CTestSubset (rd : mword 5) (cb : mword 5) (ct : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (readCapReg ct) >>= fun ct_val =>
   let ct_top := projT1 (getCapTop ct_val) in
   let ct_base := projT1 (getCapBase ct_val) in
   let ct_perms := getCapPerms ct_val in
   let cb_top := projT1 (getCapTop cb_val) in
   let cb_base := projT1 (getCapBase cb_val) in
   let cb_perms := getCapPerms cb_val in
   let result :=
     if neq_bool cb_val.(Capability_tag) ct_val.(Capability_tag) then 'b"0"  : mword 1
     else if sumbool_of_bool (Z.ltb ct_base cb_base) then 'b"0"  : mword 1
     else if sumbool_of_bool (Z.gtb ct_top cb_top) then 'b"0"  : mword 1
     else if neq_vec (and_vec ct_perms cb_perms) ct_perms then 'b"0"  : mword 1
     else 'b"1"  : mword 1 in
   (wGPR rd (mips_zero_extend 64 result))
    : M (unit).

Definition execute_CSub (rd : mword 5) (cb : mword 5) (ct : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg ct) >>= fun ct_val =>
   (readCapReg cb) >>= fun cb_val =>
   (wGPR rd (to_bits 64 (Z.sub (projT1 (getCapCursor cb_val)) (projT1 (getCapCursor ct_val)))))
    : M (unit).

Definition execute_CStoreConditional (rs : mword 5) (cb : mword 5) (rd : mword 5) (width : WordType)
: M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_store) then
      (raise_c2_exception CapEx_PermitStoreViolation cb)
       : M (unit)
    else
      let size := projT1 (wordWidthBytes width) in
      let vAddr := projT1 (getCapCursor cb_val) in
      let vAddr64 := to_bits 64 vAddr in
      (if sumbool_of_bool (Z.gtb (Z.add vAddr size) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if negb (isAddressAligned vAddr64 width) then
         (SignalExceptionBadAddr AdES vAddr64)
          : M (unit)
       else
         (TLBTranslate vAddr64 StoreData) >>= fun pAddr =>
         (rGPR rs) >>= fun rs_val =>
         ((read_reg CP0LLBit_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
         (if (bit_to_bool (access_vec_dec w__0 0))  : bool then
            (match width with
             | B => (MEMw_conditional_wrapper pAddr 1 (subrange_vec_dec rs_val 7 0))  : M (bool)
             | H => (MEMw_conditional_wrapper pAddr 2 (subrange_vec_dec rs_val 15 0))  : M (bool)
             | W => (MEMw_conditional_wrapper pAddr 4 (subrange_vec_dec rs_val 31 0))  : M (bool)
             | D => (MEMw_conditional_wrapper pAddr 8 rs_val)  : M (bool)
             end)
             : M (bool)
          else returnm false) >>= fun success : bool =>
         (wGPR rd (mips_zero_extend 64 (bool_to_bits success)))
          : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CStore
(rs : mword 5) (cb : mword 5) (rt : mword 5) (offset : mword 8) (width : WordType)
: M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_store) then
      (raise_c2_exception CapEx_PermitStoreViolation cb)
       : M (unit)
    else
      let size := projT1 (wordWidthBytes width) in
      let cursor := projT1 (getCapCursor cb_val) in
      (rGPR rt) >>= fun w__0 : mword 64 =>
      let vAddr :=
        projT1
        (emod_with_eq
           (Z.add (Z.add cursor (projT1 (uint w__0))) (Z.mul size (projT1 (sint offset))))
           (projT1
            (pow2 64))) in
      let vAddr64 := to_bits 64 vAddr in
      (if sumbool_of_bool (Z.gtb (Z.add vAddr size) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if negb (isAddressAligned vAddr64 width) then
         (SignalExceptionBadAddr AdES vAddr64)
          : M (unit)
       else
         (TLBTranslate vAddr64 StoreData) >>= fun pAddr =>
         (rGPR rs) >>= fun rs_val =>
         (match width with
          | B => (MEMw_wrapper pAddr 1 (subrange_vec_dec rs_val 7 0))  : M (unit)
          | H => (MEMw_wrapper pAddr 2 (subrange_vec_dec rs_val 15 0))  : M (unit)
          | W => (MEMw_wrapper pAddr 4 (subrange_vec_dec rs_val 31 0))  : M (unit)
          | D => (MEMw_wrapper pAddr 8 rs_val)  : M (unit)
          end)
          : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CSetOffset (cd : mword 5) (cb : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (rGPR rt) >>= fun rt_val =>
   (if andb cb_val.(Capability_tag) cb_val.(Capability_sealed) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (unit)
    else
      let '(success, newCap) := setCapOffset cb_val rt_val in
      (if sumbool_of_bool success then (writeCapReg cd newCap)  : M (unit)
       else (writeCapReg cd (unrepCap newCap))  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CSetFlags (cd : mword 5) (cb : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (rGPR rt) >>= fun rt_val =>
   (if andb cb_val.(Capability_tag) cb_val.(Capability_sealed) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (unit)
    else
      let newCap := setCapFlags cb_val (vector_truncate rt_val num_flags) in
      (writeCapReg cd newCap)
       : M (unit))
    : M (unit).

Definition execute_CSetCause (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (pcc_access_system_regs tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (negb w__0) then
      (raise_c2_exception_noreg CapEx_AccessSystemRegsViolation)
       : M (unit)
    else
      (rGPR rt) >>= fun rt_val =>
      (_set_CapCauseReg_ExcCode CapCause_ref (subrange_vec_dec rt_val 15 8)) >>
      (_set_CapCauseReg_RegNum CapCause_ref (subrange_vec_dec rt_val 7 0))
       : M (unit))
    : M (unit).

Definition execute_CSetCID (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_set_CID) then
      (raise_c2_exception CapEx_PermitSetCIDViolation cb)
       : M (unit)
    else
      let addr := projT1 (getCapCursor cb_val) in
      (if sumbool_of_bool (Z.ltb addr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.geb addr (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else write_reg CID_ref (to_bits 64 addr)  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CSetBoundsImmediate (cd : mword 5) (cb : mword 5) (imm : mword 11) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   let immU := projT1 (uint imm) in
   let cursor := projT1 (getCapCursor cb_val) in
   let base := projT1 (getCapBase cb_val) in
   let top := projT1 (getCapTop cb_val) in
   let newTop := Z.add cursor immU in
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if sumbool_of_bool (Z.ltb cursor base) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else if sumbool_of_bool (Z.gtb newTop top) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else
      let '(_, newCap) := setCapBounds cb_val (to_bits 64 cursor) (to_bits 65 newTop) in
      (writeCapReg cd newCap)
       : M (unit))
    : M (unit).

Definition execute_CSetBoundsExact (cd : mword 5) (cb : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (rGPR rt) >>= fun w__0 : mword 64 =>
   let rt_val := projT1 (uint w__0) in
   let cursor := projT1 (getCapCursor cb_val) in
   let base := projT1 (getCapBase cb_val) in
   let top := projT1 (getCapTop cb_val) in
   let newTop := Z.add cursor rt_val in
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if sumbool_of_bool (Z.ltb cursor base) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else if sumbool_of_bool (Z.gtb newTop top) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else
      let '(exact, newCap) := setCapBounds cb_val (to_bits 64 cursor) (to_bits 65 newTop) in
      (if sumbool_of_bool (negb exact) then (raise_c2_exception CapEx_InexactBounds cb)  : M (unit)
       else (writeCapReg cd newCap)  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CSetBounds (cd : mword 5) (cb : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (rGPR rt) >>= fun w__0 : mword 64 =>
   let rt_val := projT1 (uint w__0) in
   let cursor := projT1 (getCapCursor cb_val) in
   let base := projT1 (getCapBase cb_val) in
   let top := projT1 (getCapTop cb_val) in
   let newTop := Z.add cursor rt_val in
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if sumbool_of_bool (Z.ltb cursor base) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else if sumbool_of_bool (Z.gtb newTop top) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else
      let '(_, newCap) := setCapBounds cb_val (to_bits 64 cursor) (to_bits 65 newTop) in
      (writeCapReg cd newCap)
       : M (unit))
    : M (unit).

Definition execute_CSetAddr (cd : mword 5) (cb : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (rGPR rt) >>= fun rt_val =>
   (if andb cb_val.(Capability_tag) cb_val.(Capability_sealed) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (unit)
    else
      let '(representable, newCap) := setCapAddr cb_val rt_val in
      (if sumbool_of_bool representable then (writeCapReg cd newCap)  : M (unit)
       else (writeCapReg cd (unrepCap newCap))  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CSealEntry (cd : mword 5) (cs : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cs) >>= fun cs_val =>
   let cs_cursor := projT1 (getCapCursor cs_val) in
   let cs_top := projT1 (getCapTop cs_val) in
   let cs_base := projT1 (getCapBase cs_val) in
   (if negb cs_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cs)  : M (unit)
    else if cs_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cs)  : M (unit)
    else if negb cs_val.(Capability_permit_execute) then
      (raise_c2_exception CapEx_PermitExecuteViolation cs)
       : M (unit)
    else
      let '(success, newCap) := sealCap cs_val (to_bits 24 otype_sentry) in
      (if sumbool_of_bool (negb success) then
         (raise_c2_exception CapEx_InexactBounds cs)
          : M (unit)
       else (writeCapReg cd newCap)  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CSeal (cd : mword 5) (cs : mword 5) (ct : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cs) >>= fun cs_val =>
   (readCapReg ct) >>= fun ct_val =>
   let ct_cursor := projT1 (getCapCursor ct_val) in
   let ct_top := projT1 (getCapTop ct_val) in
   let ct_base := projT1 (getCapBase ct_val) in
   (if negb cs_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cs)  : M (unit)
    else if negb ct_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation ct)  : M (unit)
    else if cs_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cs)  : M (unit)
    else if ct_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation ct)  : M (unit)
    else if negb ct_val.(Capability_permit_seal) then
      (raise_c2_exception CapEx_PermitSealViolation ct)
       : M (unit)
    else if sumbool_of_bool (Z.ltb ct_cursor ct_base) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (unit)
    else if sumbool_of_bool (Z.geb ct_cursor ct_top) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (unit)
    else if sumbool_of_bool (Z.gtb ct_cursor max_otype) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (unit)
    else
      let '(success, newCap) := sealCap cs_val (to_bits 24 ct_cursor) in
      (if sumbool_of_bool (negb success) then
         (raise_c2_exception CapEx_InexactBounds cs)
          : M (unit)
       else (writeCapReg cd newCap)  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CSCC (cs : mword 5) (cb : mword 5) (rd : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cs) >>= fun cs_val =>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_store) then
      (raise_c2_exception CapEx_PermitStoreViolation cb)
       : M (unit)
    else if andb (negb cb_val.(Capability_permit_store_cap)) cs_val.(Capability_tag) then
      (raise_c2_exception CapEx_PermitStoreCapViolation cb)
       : M (unit)
    else if andb (negb cb_val.(Capability_permit_store_local_cap))
              (andb cs_val.(Capability_tag) (negb cs_val.(Capability_global))) then
      (raise_c2_exception CapEx_PermitStoreLocalCapViolation cb)
       : M (unit)
    else
      let vAddr := projT1 (getCapCursor cb_val) in
      let vAddr64 := to_bits 64 vAddr in
      (if sumbool_of_bool (Z.gtb (Z.add vAddr cap_size) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (projT1 (neq_int (projT1 (emod_with_eq vAddr cap_size)) 0)) then
         (SignalExceptionBadAddr AdES vAddr64)
          : M (unit)
       else
         (TLBTranslateC vAddr64 StoreData) >>= fun '(pAddr, macr) =>
         (match (if eq_bit ((bool_to_bit cs_val.(Capability_tag))  : bitU)
                      ((bool_to_bit false)
                       : bitU) then
                   Unrestricted
                 else macr) with
          | Trap => (raise_c2_exception_badaddr CapEx_TLBNoStoreCap cs vAddr64)  : M (bool)
          | Clear => returnm false
          | Unrestricted => returnm cs_val.(Capability_tag)
          end) >>= fun mtag : bool =>
         ((read_reg CP0LLBit_ref)  : M (mword 1)) >>= fun w__1 : mword 1 =>
         (if (bit_to_bool (access_vec_dec w__1 0))  : bool then
            (MEMw_tagged_conditional pAddr cap_size mtag (capToMemBits cs_val))
             : M (bool)
          else returnm false) >>= fun success =>
         (wGPR rd (mips_zero_extend 64 (bool_to_bits success)))
          : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CSC (cs : mword 5) (cb : mword 5) (rt : mword 5) (offset : mword 11) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cs) >>= fun cs_val =>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_store) then
      (raise_c2_exception CapEx_PermitStoreViolation cb)
       : M (unit)
    else if andb (negb cb_val.(Capability_permit_store_cap)) cs_val.(Capability_tag) then
      (raise_c2_exception CapEx_PermitStoreCapViolation cb)
       : M (unit)
    else if andb (negb cb_val.(Capability_permit_store_local_cap))
              (andb cs_val.(Capability_tag) (negb cs_val.(Capability_global))) then
      (raise_c2_exception CapEx_PermitStoreLocalCapViolation cb)
       : M (unit)
    else
      let cursor := projT1 (getCapCursor cb_val) in
      (rGPR rt) >>= fun w__0 : mword 64 =>
      let vAddr :=
        projT1
        (emod_with_eq (Z.add (Z.add cursor (projT1 (uint w__0))) (Z.mul 16 (projT1 (sint offset))))
           (projT1
            (pow2 64))) in
      let vAddr64 := to_bits 64 vAddr in
      (if sumbool_of_bool (Z.gtb (Z.add vAddr cap_size) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (projT1 (neq_int (projT1 (emod_with_eq vAddr cap_size)) 0)) then
         (SignalExceptionBadAddr AdES vAddr64)
          : M (unit)
       else
         (TLBTranslateC vAddr64 StoreData) >>= fun '(pAddr, macr) =>
         (match (if eq_bit ((bool_to_bit cs_val.(Capability_tag))  : bitU)
                      ((bool_to_bit false)
                       : bitU) then
                   Unrestricted
                 else macr) with
          | Unrestricted => returnm cs_val.(Capability_tag)
          | Clear => returnm false
          | Trap => (raise_c2_exception_badaddr CapEx_TLBNoStoreCap cs vAddr64)  : M (bool)
          end) >>= fun mtag : bool =>
         (MEMw_tagged pAddr cap_size mtag (capToMemBits cs_val))
          : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CReturn '(tt : unit) : M (unit) :=
   (checkCP2usable tt) >> (raise_c2_exception_noreg CapEx_ReturnTrap)  : M (unit).

Definition execute_CReadHwr (cd : mword 5) (sel : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   let l__57 := projT1 (uint sel) in
   (if sumbool_of_bool (Z.eqb l__57 0) then returnm (false, false)
    else if sumbool_of_bool (Z.eqb l__57 1) then returnm (false, false)
    else if sumbool_of_bool (Z.eqb l__57 8) then returnm (false, true)
    else if sumbool_of_bool (Z.eqb l__57 22) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__57 23) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__57 28) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__57 29) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__57 30) then returnm (true, true)
    else if sumbool_of_bool (Z.eqb l__57 31) then returnm (true, true)
    else (SignalException ResI)  : M ((bool * bool))) >>= fun '((needSup, needAccessSys)
   : (bool * bool)) =>
   (and_boolMP
      ((returnm (build_ex needAccessSys)) : M ({_bool : bool & ArithFact (Bool.eqb needAccessSys _bool)}))
      (build_trivial_ex
      ((pcc_access_system_regs tt) >>= fun w__9 : bool => returnm ((negb w__9)  : bool))) : M ({_bool : bool & ArithFactP (exists simp_1 , Bool.eqb (needAccessSys &&
     simp_1) _bool = true)})) >>= fun '(existT _ w__10 _) =>
   (if sumbool_of_bool w__10 then
      (raise_c2_exception CapEx_AccessSystemRegsViolation sel)
       : M (unit)
    else
    (and_boolMP
       ((returnm (build_ex needSup)) : M ({_bool : bool & ArithFact (Bool.eqb needSup _bool)}))
       (build_trivial_ex
       ((getAccessLevel tt) >>= fun w__11 : AccessLevel =>
        returnm ((negb (grantsAccess w__11 Supervisor))  : bool))) : M ({_bool : bool & ArithFactP (exists simp_1 , Bool.eqb (needSup &&
      simp_1) _bool = true)})) >>= fun '(existT _ w__12 _) =>
    if sumbool_of_bool w__12 then
      (raise_c2_exception CapEx_AccessSystemRegsViolation sel)
       : M (unit)
    else
      let l__48 := projT1 (uint sel) in
      (if sumbool_of_bool (Z.eqb l__48 0) then read_reg DDC_ref  : M (Capability)
       else if sumbool_of_bool (Z.eqb l__48 1) then read_reg CULR_ref  : M (Capability)
       else if sumbool_of_bool (Z.eqb l__48 8) then read_reg CPLR_ref  : M (Capability)
       else if sumbool_of_bool (Z.eqb l__48 22) then read_reg KR1C_ref  : M (Capability)
       else if sumbool_of_bool (Z.eqb l__48 23) then read_reg KR2C_ref  : M (Capability)
       else if sumbool_of_bool (Z.eqb l__48 28) then read_reg ErrorEPCC_ref  : M (Capability)
       else if sumbool_of_bool (Z.eqb l__48 29) then read_reg KCC_ref  : M (Capability)
       else if sumbool_of_bool (Z.eqb l__48 30) then read_reg KDC_ref  : M (Capability)
       else if sumbool_of_bool (Z.eqb l__48 31) then read_reg EPCC_ref  : M (Capability)
       else assert_exp' false "CReadHwr: should be unreachable code" >>= fun _ => exit tt) >>= fun capVal : Capability =>
      (writeCapReg cd capVal)
       : M (unit))
    : M (unit).

Definition execute_CRAP (rt : mword 5) (rs : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (rGPR rs) >>= fun len => (wGPR rt (getRepresentableLength len))  : M (unit).

Definition execute_CRAM (rt : mword 5) (rs : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (rGPR rs) >>= fun len => (wGPR rt (getRepresentableAlignmentMask len))  : M (unit).

Definition execute_CPtrCmp (rd : mword 5) (cb : mword 5) (ct : mword 5) (op : CPtrCmpOp) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (readCapReg ct) >>= fun ct_val =>
   let equal : bool := eq_vec cb_val.(Capability_address) ct_val.(Capability_address) in
   let ltu : bool := zopz0zI_u cb_val.(Capability_address) ct_val.(Capability_address) in
   let lts : bool := zopz0zI_s cb_val.(Capability_address) ct_val.(Capability_address) in
   let cmp : bool :=
     match op with
     | CEQ => equal
     | CNE => negb equal
     | CLT => lts
     | CLE => orb lts equal
     | CLTU => ltu
     | CLEU => orb ltu equal
     | CEXEQ => generic_eq cb_val ct_val
     | CNEXEQ => generic_neq cb_val ct_val
     end in
   (wGPR rd (mips_zero_extend 64 (bool_to_bits cmp)))
    : M (unit).

Definition execute_CMove (cd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun w__0 : Capability => (writeCapReg cd w__0)  : M (unit).

Definition execute_CMOVX (cd : mword 5) (cb : mword 5) (rt : mword 5) (ismovn : bool) : M (unit) :=
   (checkCP2usable tt) >>
   (rGPR rt) >>= fun w__0 : mword 64 =>
   (if (bits_to_bool
          (xor_vec (bool_to_bits (eq_vec w__0 (zeros_implicit 64 tt)))
             ((bool_to_bits ismovn)
              : mword 1)))
       : bool then
      (readCapReg cb) >>= fun w__1 : Capability => (writeCapReg cd w__1)  : M (unit)
    else returnm tt)
    : M (unit).

Definition execute_CLoadTags (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_load) then
      (raise_c2_exception CapEx_PermitLoadViolation cb)
       : M (unit)
    else if negb cb_val.(Capability_permit_load_cap) then
      (raise_c2_exception CapEx_PermitLoadCapViolation cb)
       : M (unit)
    else
      let vAddr := projT1 (getCapCursor cb_val) in
      let vAddr64 := to_bits 64 (projT1 (getCapCursor cb_val)) in
      (if sumbool_of_bool
         (Z.gtb (Z.add vAddr (Z.mul caps_per_cacheline cap_size)) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool
         (negb (Z.eqb (projT1 (emod_with_eq vAddr (Z.mul cap_size caps_per_cacheline))) 0)) then
         (SignalExceptionBadAddr AdEL vAddr64)
          : M (unit)
       else
         (TLBTranslateC vAddr64 LoadData) >>= fun '(pAddr, macr) =>
         (match macr with
          | Clear => (raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64)  : M (unit)
          | Trap => (raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64)  : M (unit)
          | Unrestricted =>
             let x : bits 64 := zeros_implicit 64 tt in
             (let loop_i_lower := 0 in
             let loop_i_upper := Z.sub caps_per_cacheline 1 in
             (foreach_ZM_up loop_i_lower loop_i_upper 1 x
               (fun i _ x =>
                 (MEMr_tagged (add_vec_int pAddr (Z.mul i cap_size)) cap_size true) >>= fun '(tag, _) =>
                 let x : bits 64 := update_vec_dec x i ((bool_to_bit tag)  : bitU) in
                 returnm x))) >>= fun x : mword 64 =>
             (wGPR rd x)
              : M (unit)
          end)
          : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CLoadLinked (rd : mword 5) (cb : mword 5) (signext : bool) (width : WordType)
: M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_load) then
      (raise_c2_exception CapEx_PermitLoadViolation cb)
       : M (unit)
    else
      let size := projT1 (wordWidthBytes width) in
      let vAddr := projT1 (getCapCursor cb_val) in
      let vAddr64 := to_bits 64 vAddr in
      (if sumbool_of_bool (Z.gtb (Z.add vAddr size) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if negb (isAddressAligned vAddr64 width) then
         (SignalExceptionBadAddr AdEL vAddr64)
          : M (unit)
       else
         (TLBTranslate vAddr64 LoadData) >>= fun pAddr =>
         (MEMr_reserve_wrapper pAddr size) >>= fun w__0 : mword (8 * size) =>
         let memResult : bits 64 := extendLoad w__0 signext in
         write_reg CP0LLBit_ref ('b"1"  : mword 1) >>
         write_reg CP0LLAddr_ref pAddr >> (wGPR rd memResult)  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CLoad
(rd : mword 5) (cb : mword 5) (rt : mword 5) (offset : mword 8) (signext : bool) (width : WordType)
: M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_load) then
      (raise_c2_exception CapEx_PermitLoadViolation cb)
       : M (unit)
    else
      let size := projT1 (wordWidthBytes width) in
      let cursor := projT1 (getCapCursor cb_val) in
      (rGPR rt) >>= fun w__0 : mword 64 =>
      let vAddr :=
        projT1
        (emod_with_eq
           (Z.add (Z.add cursor (projT1 (uint w__0))) (Z.mul size (projT1 (sint offset))))
           (projT1
            (pow2 64))) in
      let vAddr64 := to_bits 64 vAddr in
      (if sumbool_of_bool (Z.gtb (Z.add vAddr size) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if negb (isAddressAligned vAddr64 width) then
         (SignalExceptionBadAddr AdEL vAddr64)
          : M (unit)
       else
         (TLBTranslate vAddr64 LoadData) >>= fun pAddr =>
         (MEMr_wrapper pAddr size) >>= fun w__1 : mword (8 * size) =>
         let memResult : bits 64 := extendLoad w__1 signext in
         (wGPR rd memResult)
          : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CLLC (cd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_load) then
      (raise_c2_exception CapEx_PermitLoadViolation cb)
       : M (unit)
    else
      let vAddr := projT1 (getCapCursor cb_val) in
      let vAddr64 := to_bits 64 vAddr in
      (if sumbool_of_bool (Z.gtb (Z.add vAddr cap_size) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (projT1 (neq_int (projT1 (emod_with_eq vAddr cap_size)) 0)) then
         (SignalExceptionBadAddr AdEL vAddr64)
          : M (unit)
       else
         (TLBTranslateC vAddr64 LoadData) >>= fun '(pAddr, macr) =>
         (MEMr_tagged_reserve pAddr cap_size
            (andb cb_val.(Capability_permit_load_cap) (negb (generic_eq macr Clear)))) >>= fun '(tag, mem) =>
         (if sumbool_of_bool (andb tag (generic_eq macr Trap)) then
            (raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64)
             : M (unit)
          else
            let cap := memBitsToCapability tag mem in
            (writeCapReg cd cap) >>
            write_reg CP0LLBit_ref ('b"1"  : mword 1) >> write_reg CP0LLAddr_ref pAddr  : M (unit))
          : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CLCBI (cd : mword 5) (cb : mword 5) (offset : mword 16) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_load) then
      (raise_c2_exception CapEx_PermitLoadViolation cb)
       : M (unit)
    else
      let cursor := projT1 (getCapCursor cb_val) in
      let vAddr :=
        projT1
        (emod_with_eq (Z.add cursor (Z.mul 16 (projT1 (sint offset)))) (projT1 (pow2 64))) in
      let vAddr64 := to_bits 64 vAddr in
      (if sumbool_of_bool (Z.gtb (Z.add vAddr cap_size) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (projT1 (neq_int (projT1 (emod_with_eq vAddr cap_size)) 0)) then
         (SignalExceptionBadAddr AdEL vAddr64)
          : M (unit)
       else
         (TLBTranslateC vAddr64 LoadData) >>= fun '(pAddr, macr) =>
         (MEMr_tagged pAddr cap_size
            (andb cb_val.(Capability_permit_load_cap) (negb (generic_eq macr Clear)))) >>= fun '(tag, mem) =>
         (if sumbool_of_bool (andb tag (generic_eq macr Trap)) then
            (raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64)
             : M (unit)
          else
            let cap := memBitsToCapability tag mem in
            (writeCapReg cd cap)
             : M (unit))
          : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CLC (cd : mword 5) (cb : mword 5) (rt : mword 5) (offset : mword 11) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_load) then
      (raise_c2_exception CapEx_PermitLoadViolation cb)
       : M (unit)
    else
      let cursor := projT1 (getCapCursor cb_val) in
      (rGPR rt) >>= fun w__0 : mword 64 =>
      let vAddr :=
        projT1
        (emod_with_eq (Z.add (Z.add cursor (projT1 (uint w__0))) (Z.mul 16 (projT1 (sint offset))))
           (projT1
            (pow2 64))) in
      let vAddr64 := to_bits 64 vAddr in
      (if sumbool_of_bool (Z.gtb (Z.add vAddr cap_size) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (projT1 (neq_int (projT1 (emod_with_eq vAddr cap_size)) 0)) then
         (SignalExceptionBadAddr AdEL vAddr64)
          : M (unit)
       else
         (TLBTranslateC vAddr64 LoadData) >>= fun '(pAddr, macr) =>
         (MEMr_tagged pAddr cap_size
            (andb cb_val.(Capability_permit_load_cap) (negb (generic_eq macr Clear)))) >>= fun '(tag, mem) =>
         (if sumbool_of_bool (andb tag (generic_eq macr Trap)) then
            (raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64)
             : M (unit)
          else
            let cap := memBitsToCapability tag mem in
            (writeCapReg cd cap)
             : M (unit))
          : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CJALR (cd : mword 5) (cb : mword 5) (link : bool) : M (unit) :=
   (checkCP2usable tt) >>
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   (readCapReg cb) >>= fun cb_val =>
   let cb_ptr := projT1 (getCapCursor cb_val) in
   let cb_top := projT1 (getCapTop cb_val) in
   let cb_base := projT1 (getCapBase cb_val) in
   let sentry := isSentryCap cb_val in
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if sumbool_of_bool (andb cb_val.(Capability_sealed) (negb sentry)) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (unit)
    else if negb cb_val.(Capability_permit_execute) then
      (raise_c2_exception CapEx_PermitExecuteViolation cb)
       : M (unit)
    else if sumbool_of_bool (Z.ltb cb_ptr cb_base) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else if sumbool_of_bool (Z.gtb (Z.add cb_ptr 4) cb_top) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else if sumbool_of_bool (projT1 (neq_int (projT1 (emod_with_eq cb_ptr 4)) 0)) then
      (SignalException AdEL)
       : M (unit)
    else
      let cb_val : Capability := if sumbool_of_bool sentry then unsealCap cb_val else cb_val in
      (if sumbool_of_bool link then
         read_reg PCC_ref >>= fun w__1 : Capability =>
         ((read_reg PC_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
         let '(success, linkCap) := setCapOffset w__1 (add_vec_int w__2 8) in
         assert_exp' success "Link cap should always be representable." >>= fun _ =>
         let '(success2, sealedLink) := sealCap linkCap (to_bits 24 otype_sentry) in
         assert_exp' success2 "Sealing should always be possible with current format." >>= fun _ =>
         (writeCapReg cd sealedLink)
          : M (unit)
       else returnm tt) >>
      (execute_branch_pcc cb_val)
       : M (unit)) >>
   write_reg NextInBranchDelay_ref ('b"1"  : mword 1)
    : M (unit).

Definition execute_CIncOffsetImmediate (cd : mword 5) (cb : mword 5) (imm : mword 11) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   let imm64 : bits 64 := mips_sign_extend 64 imm in
   (if andb cb_val.(Capability_tag) cb_val.(Capability_sealed) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (unit)
    else
      let '(success, newCap) := incCapOffset cb_val imm64 in
      (if sumbool_of_bool success then (writeCapReg cd newCap)  : M (unit)
       else (writeCapReg cd (unrepCap newCap))  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CIncOffset (cd : mword 5) (cb : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (rGPR rt) >>= fun rt_val =>
   (if andb cb_val.(Capability_tag) cb_val.(Capability_sealed) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (unit)
    else
      let '(success, newCap) := incCapOffset cb_val rt_val in
      (if sumbool_of_bool success then (writeCapReg cd newCap)  : M (unit)
       else (writeCapReg cd (unrepCap newCap))  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CGetType (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal =>
   (wGPR rd
      (if hasReservedOType capVal then mips_sign_extend 64 capVal.(Capability_otype)
       else mips_zero_extend 64 capVal.(Capability_otype)))
    : M (unit).

Definition execute_CGetTag (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal =>
   (wGPR rd (mips_zero_extend 64 (bool_to_bits capVal.(Capability_tag))))
    : M (unit).

Definition execute_CGetSealed (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal =>
   (wGPR rd (mips_zero_extend 64 (bool_to_bits capVal.(Capability_sealed))))
    : M (unit).

Definition execute_CGetPerm (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal =>
   (wGPR rd (mips_zero_extend 64 (getCapPerms capVal)))
    : M (unit).

Definition execute_CGetPCCSetOffset (cd : mword 5) (rs : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (rGPR rs) >>= fun rs_val =>
   read_reg PCC_ref >>= fun w__0 : Capability =>
   let '(success, newPCC) := setCapOffset w__0 rs_val in
   (if sumbool_of_bool success then (writeCapReg cd newPCC)  : M (unit)
    else (writeCapReg cd (unrepCap newPCC))  : M (unit))
    : M (unit).

Definition execute_CGetPCCSetAddr (cd : mword 5) (rs : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (rGPR rs) >>= fun rs_val =>
   read_reg PCC_ref >>= fun w__0 : Capability =>
   let '(success, newCap) := setCapAddr w__0 rs_val in
   (if sumbool_of_bool success then (writeCapReg cd newCap)  : M (unit)
    else (writeCapReg cd (unrepCap newCap))  : M (unit))
    : M (unit).

Definition execute_CGetPCCIncOffset (cd : mword 5) (rs : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (rGPR rs) >>= fun rs_val =>
   read_reg PCC_ref >>= fun w__0 : Capability =>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   let '(success, newCap) := setCapOffset w__0 (add_vec w__1 rs_val) in
   (if sumbool_of_bool success then (writeCapReg cd newCap)  : M (unit)
    else (writeCapReg cd (unrepCap newCap))  : M (unit))
    : M (unit).

Definition execute_CGetPCC (cd : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   read_reg PCC_ref >>= fun w__0 : Capability =>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   let '(success, pcc) := setCapOffset w__0 w__1 in
   assert_exp' success "PCC with offset PC should always be representable" >>= fun _ =>
   (writeCapReg cd pcc)
    : M (unit).

Definition execute_CGetOffset (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal =>
   (wGPR rd (to_bits 64 (projT1 (getCapOffset capVal))))
    : M (unit).

Definition execute_CGetLen (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal =>
   let len65 := projT1 (getCapLength capVal) in
   (wGPR rd (to_bits 64 (if sumbool_of_bool (Z.gtb len65 MAX_U64) then MAX_U64 else len65)))
    : M (unit).

Definition execute_CGetFlags (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal =>
   (wGPR rd (mips_zero_extend 64 (getCapFlags capVal)))
    : M (unit).

Definition execute_CGetCause (rd : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (pcc_access_system_regs tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (negb w__0) then
      (raise_c2_exception_noreg CapEx_AccessSystemRegsViolation)
       : M (unit)
    else
      read_reg CapCause_ref >>= fun w__1 : CapCauseReg =>
      (wGPR rd (mips_zero_extend 64 (_get_CapCauseReg_bits w__1)))
       : M (unit))
    : M (unit).

Definition execute_CGetCID (rd : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   ((read_reg CID_ref)  : M (mword 64)) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit).

Definition execute_CGetBase (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal => (wGPR rd (to_bits 64 (projT1 (getCapBase capVal))))  : M (unit).

Definition execute_CGetAndAddr (rd : mword 5) (cb : mword 5) (rs : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal =>
   (rGPR rs) >>= fun rs_val => (wGPR rd (and_vec capVal.(Capability_address) rs_val))  : M (unit).

Definition execute_CGetAddr (rd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun capVal => (wGPR rd capVal.(Capability_address))  : M (unit).

Definition execute_CFromPtr (cd : mword 5) (cb : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (rGPR rt) >>= fun rt_val =>
   (if eq_vec rt_val (Ox"0000000000000000"  : mword 64) then (writeCapReg cd null_cap)  : M (unit)
    else if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else
      let '(success, newCap) := setCapOffset cb_val rt_val in
      (if sumbool_of_bool success then (writeCapReg cd newCap)  : M (unit)
       else (writeCapReg cd (unrepCap newCap))  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CCopyType (cd : mword 5) (cb : mword 5) (ct : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (readCapReg ct) >>= fun ct_val =>
   let cb_base := projT1 (getCapBase cb_val) in
   let cb_top := projT1 (getCapTop cb_val) in
   let ct_otype := projT1 (uint ct_val.(Capability_otype)) in
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if orb (negb ct_val.(Capability_sealed)) (hasReservedOType ct_val) then
      (writeCapReg cd
         {[ null_cap with Capability_address := (mips_sign_extend 64 ct_val.(Capability_otype)) ]})
       : M (unit)
    else if sumbool_of_bool (Z.ltb ct_otype cb_base) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else if sumbool_of_bool (Z.geb ct_otype cb_top) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else
      let '(success, cap) := setCapOffset cb_val (to_bits 64 (Z.sub ct_otype cb_base)) in
      assert_exp' success "CopyType: offset is in bounds so should be representable" >>= fun _ =>
      (writeCapReg cd cap)
       : M (unit))
    : M (unit).

Definition execute_CClearTags (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if negb cb_val.(Capability_permit_store) then
      (raise_c2_exception CapEx_PermitStoreViolation cb)
       : M (unit)
    else
      let vAddr := projT1 (getCapCursor cb_val) in
      let vAddr64 := to_bits 64 (projT1 (getCapCursor cb_val)) in
      (if sumbool_of_bool
         (Z.gtb (Z.add vAddr (Z.mul caps_per_cacheline cap_size)) (projT1 (getCapTop cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb vAddr (projT1 (getCapBase cb_val))) then
         (raise_c2_exception CapEx_LengthViolation cb)
          : M (unit)
       else if sumbool_of_bool
         (negb (Z.eqb (projT1 (emod_with_eq vAddr (Z.mul cap_size caps_per_cacheline))) 0)) then
         (SignalExceptionBadAddr AdEL vAddr64)
          : M (unit)
       else
         (TLBTranslate vAddr64 StoreData) >>= fun pAddr =>
         let loop_i_lower := 0 in
         let loop_i_upper := Z.sub caps_per_cacheline 1 in
         (foreach_ZM_up loop_i_lower loop_i_upper 1 tt
           (fun i _ _ =>
             (MEMr_tagged (add_vec_int pAddr (Z.mul i cap_size)) cap_size false) >>= fun '(_, mem) =>
             (MEMw_tagged (add_vec_int pAddr (Z.mul i cap_size)) cap_size false mem)
              : M (unit))))
       : M (unit))
    : M (unit).

Definition execute_CClearTag (cd : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (writeCapReg cd {[ cb_val with Capability_tag := false ]})
    : M (unit).

Definition execute_CCheckType (cs : mword 5) (cb : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cs) >>= fun cs_val =>
   (readCapReg cb) >>= fun cb_val =>
   (if negb cs_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cs)  : M (unit)
    else if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if orb (negb cs_val.(Capability_sealed)) (hasReservedOType cs_val) then
      (raise_c2_exception CapEx_SealViolation cs)
       : M (unit)
    else if orb (negb cb_val.(Capability_sealed)) (hasReservedOType cb_val) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (unit)
    else if neq_vec cs_val.(Capability_otype) cb_val.(Capability_otype) then
      (raise_c2_exception CapEx_TypeViolation cs)
       : M (unit)
    else returnm tt)
    : M (unit).

Definition execute_CCheckTag (cs : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cs) >>= fun cs_val =>
   (if negb cs_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cs)  : M (unit)
    else returnm tt)
    : M (unit).

Definition execute_CCheckPerm (cs : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cs) >>= fun cs_val =>
   let cs_perms : bits 64 := mips_zero_extend 64 (getCapPerms cs_val) in
   (rGPR rt) >>= fun rt_perms =>
   (if negb cs_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cs)  : M (unit)
    else if neq_vec (and_vec cs_perms rt_perms) rt_perms then
      (raise_c2_exception CapEx_UserDefViolation cs)
       : M (unit)
    else returnm tt)
    : M (unit).

Definition execute_CCall (cs : mword 5) (cb : mword 5) (b__107 : mword 11) : M (unit) :=
   (if eq_vec b__107 ('b"00000000000"  : mword 11) then
      (checkCP2usable tt) >>
      ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
      (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
       else returnm tt) >>
      (readCapReg cs) >>= fun cs_val =>
      (readCapReg cb) >>= fun cb_val =>
      let cs_cursor := projT1 (getCapCursor cs_val) in
      (if negb cs_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cs)  : M (unit)
       else if negb cb_val.(Capability_tag) then
         (raise_c2_exception CapEx_TagViolation cb)
          : M (unit)
       else if orb (negb cs_val.(Capability_sealed)) (hasReservedOType cs_val) then
         (raise_c2_exception CapEx_SealViolation cs)
          : M (unit)
       else if orb (negb cb_val.(Capability_sealed)) (hasReservedOType cb_val) then
         (raise_c2_exception CapEx_SealViolation cb)
          : M (unit)
       else if neq_vec cs_val.(Capability_otype) cb_val.(Capability_otype) then
         (raise_c2_exception CapEx_TypeViolation cs)
          : M (unit)
       else if negb cs_val.(Capability_permit_execute) then
         (raise_c2_exception CapEx_PermitExecuteViolation cs)
          : M (unit)
       else if cb_val.(Capability_permit_execute) then
         (raise_c2_exception CapEx_PermitExecuteViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb cs_cursor (projT1 (getCapBase cs_val))) then
         (raise_c2_exception CapEx_LengthViolation cs)
          : M (unit)
       else if sumbool_of_bool (Z.geb cs_cursor (projT1 (getCapTop cs_val))) then
         (raise_c2_exception CapEx_LengthViolation cs)
          : M (unit)
       else (raise_c2_exception CapEx_CallTrap cs)  : M (unit))
       : M (unit)
    else if eq_vec b__107 ('b"00000000001"  : mword 11) then
      (checkCP2usable tt) >>
      ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__1 : mword 1 =>
      (if (bits_to_bool w__1)  : bool then (SignalException ResI)  : M (unit)
       else returnm tt) >>
      (readCapReg cs) >>= fun cs_val =>
      (readCapReg cb) >>= fun cb_val =>
      let cs_cursor := projT1 (getCapCursor cs_val) in
      (if negb cs_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cs)  : M (unit)
       else if negb cb_val.(Capability_tag) then
         (raise_c2_exception CapEx_TagViolation cb)
          : M (unit)
       else if hasReservedOType cs_val then (raise_c2_exception CapEx_SealViolation cs)  : M (unit)
       else if hasReservedOType cb_val then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
       else if neq_vec cs_val.(Capability_otype) cb_val.(Capability_otype) then
         (raise_c2_exception CapEx_TypeViolation cs)
          : M (unit)
       else if negb cs_val.(Capability_permit_ccall) then
         (raise_c2_exception CapEx_PermitCCallViolation cs)
          : M (unit)
       else if negb cb_val.(Capability_permit_ccall) then
         (raise_c2_exception CapEx_PermitCCallViolation cb)
          : M (unit)
       else if negb cs_val.(Capability_permit_execute) then
         (raise_c2_exception CapEx_PermitExecuteViolation cs)
          : M (unit)
       else if cb_val.(Capability_permit_execute) then
         (raise_c2_exception CapEx_PermitExecuteViolation cb)
          : M (unit)
       else if sumbool_of_bool (Z.ltb cs_cursor (projT1 (getCapBase cs_val))) then
         (raise_c2_exception CapEx_LengthViolation cs)
          : M (unit)
       else if sumbool_of_bool (Z.geb cs_cursor (projT1 (getCapTop cs_val))) then
         (raise_c2_exception CapEx_LengthViolation cs)
          : M (unit)
       else
         (set_next_pcc (unsealCap cs_val)) >>
         write_reg C26_ref (unsealCap cb_val) >>
         write_reg NextPC_ref (to_bits 64 (projT1 (getCapOffset cs_val)))
          : M (unit))
       : M (unit)
    else
      assert_exp' false "Pattern match failure at ../mips/mips_ri.sail 41:16 - 45:1" >>= fun _ =>
      exit tt)
    : M (unit).

Definition execute_CCSeal (cd : mword 5) (cs : mword 5) (ct : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cs) >>= fun cs_val =>
   (readCapReg ct) >>= fun ct_val =>
   let ct_cursor := projT1 (getCapCursor ct_val) in
   let ct_top := projT1 (getCapTop ct_val) in
   let ct_base := projT1 (getCapBase ct_val) in
   (if negb cs_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cs)  : M (unit)
    else if eq_vec ct_val.(Capability_address) otype_sentry_bits then
      (if cs_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cs)  : M (unit)
       else if negb cs_val.(Capability_permit_execute) then
         (raise_c2_exception CapEx_PermitExecuteViolation cs)
          : M (unit)
       else
         let '(success, newCap) := sealCap cs_val (to_bits 24 otype_sentry) in
         (if sumbool_of_bool (negb success) then
            (raise_c2_exception CapEx_InexactBounds cs)
             : M (unit)
          else (writeCapReg cd newCap)  : M (unit))
          : M (unit))
       : M (unit)
    else if orb (negb ct_val.(Capability_tag))
              (eq_vec ct_val.(Capability_address) otype_unsealed_bits) then
      (writeCapReg cd cs_val)
       : M (unit)
    else if cs_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cs)  : M (unit)
    else if ct_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation ct)  : M (unit)
    else if negb ct_val.(Capability_permit_seal) then
      (raise_c2_exception CapEx_PermitSealViolation ct)
       : M (unit)
    else if sumbool_of_bool (Z.ltb ct_cursor ct_base) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (unit)
    else if sumbool_of_bool (Z.geb ct_cursor ct_top) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (unit)
    else if sumbool_of_bool (Z.gtb ct_cursor max_otype) then
      (raise_c2_exception CapEx_TypeViolation ct)
       : M (unit)
    else
      let '(success, newCap) := sealCap cs_val (to_bits 24 ct_cursor) in
      (if sumbool_of_bool (negb success) then
         (raise_c2_exception CapEx_InexactBounds cs)
          : M (unit)
       else (writeCapReg cd newCap)  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CBuildCap (cd : mword 5) (cb : mword 5) (ct : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapRegDDC cb) >>= fun cb_val =>
   (readCapReg ct) >>= fun ct_val =>
   let cb_base := projT1 (getCapBase cb_val) in
   let ct_base := projT1 (getCapBase ct_val) in
   let cb_top := projT1 (getCapTop cb_val) in
   let ct_top := projT1 (getCapTop ct_val) in
   let cb_perms := getCapPerms cb_val in
   let ct_perms := getCapPerms ct_val in
   let ct_offset := projT1 (getCapOffset ct_val) in
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else if sumbool_of_bool (Z.ltb ct_base cb_base) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else if sumbool_of_bool (Z.gtb ct_top cb_top) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (unit)
    else if sumbool_of_bool (Z.gtb ct_base ct_top) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (unit)
    else if neq_vec (and_vec ct_perms cb_perms) ct_perms then
      (raise_c2_exception CapEx_UserDefViolation cb)
       : M (unit)
    else
      let '(exact, cd1) := setCapBounds cb_val (to_bits 64 ct_base) (to_bits 65 ct_top) in
      let '(representable, cd2) := setCapOffset cd1 (to_bits 64 ct_offset) in
      let cd3 := setCapPerms cd2 ct_perms in
      assert_exp' exact "CBuildCap: setCapBounds was not exact" >>= fun _ =>
      assert_exp' representable "CBuildCap: offset was not representable" >>= fun _ =>
      (writeCapReg cd cd3)
       : M (unit))
    : M (unit).

Definition execute_CBZ (cb : mword 5) (imm : mword 16) (notzero : bool) : M (unit) :=
   (checkCP2usable tt) >>
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (if (bits_to_bool
          (xor_vec (bool_to_bits (eq_vec cb_val.(Capability_address) (zeros_implicit 64 tt)))
             ((bool_to_bits notzero)
              : mword 1)))
       : bool then
      let offset : bits 64 :=
        add_vec_int (mips_sign_extend 64 (concat_vec imm ('b"00"  : mword 2))) 4 in
      ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
      (execute_branch (add_vec w__1 offset))
       : M (unit)
    else returnm tt) >>
   write_reg NextInBranchDelay_ref ('b"1"  : mword 1)
    : M (unit).

Definition execute_CBX (cb : mword 5) (imm : mword 16) (notset : bool) : M (unit) :=
   (checkCP2usable tt) >>
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (if (bits_to_bool
          (xor_vec (bool_to_bits cb_val.(Capability_tag)) ((bool_to_bits notset)  : mword 1)))
       : bool then
      let offset : bits 64 :=
        add_vec_int (mips_sign_extend 64 (concat_vec imm ('b"00"  : mword 2))) 4 in
      ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
      (execute_branch (add_vec w__1 offset))
       : M (unit)
    else returnm tt) >>
   write_reg NextInBranchDelay_ref ('b"1"  : mword 1)
    : M (unit).

Definition execute_CAndPerm (cd : mword 5) (cb : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (rGPR rt) >>= fun rt_val =>
   (if negb cb_val.(Capability_tag) then (raise_c2_exception CapEx_TagViolation cb)  : M (unit)
    else if cb_val.(Capability_sealed) then (raise_c2_exception CapEx_SealViolation cb)  : M (unit)
    else
      let perms := getCapPerms cb_val in
      let newCap := setCapPerms cb_val (and_vec perms (subrange_vec_dec rt_val 30 0)) in
      (writeCapReg cd newCap)
       : M (unit))
    : M (unit).

Definition execute_CAndAddr (cd : mword 5) (cb : mword 5) (rt : mword 5) : M (unit) :=
   (checkCP2usable tt) >>
   (readCapReg cb) >>= fun cb_val =>
   (rGPR rt) >>= fun rt_val =>
   (if andb cb_val.(Capability_tag) cb_val.(Capability_sealed) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (unit)
    else
      let newAddr := and_vec cb_val.(Capability_address) rt_val in
      let '(representable, newCap) := setCapAddr cb_val newAddr in
      (if sumbool_of_bool representable then (writeCapReg cd newCap)  : M (unit)
       else (writeCapReg cd (unrepCap newCap))  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_CACHE (base : mword 5) (op : mword 5) (imm : mword 16) : M (unit) :=
   (checkCP0Access tt)  : M (unit).

Definition execute_C2Dump (rt : mword 5) : unit := tt.

Definition execute_BREAK '(tt : unit) : M (unit) := (SignalException Bp)  : M (unit).

Definition execute_BEQ (rs : mword 5) (rd : mword 5) (imm : mword 16) (ne : bool) (likely : bool)
: M (unit) :=
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   (rGPR rs) >>= fun w__1 : mword 64 =>
   (rGPR rd) >>= fun w__2 : mword 64 =>
   (if (bits_to_bool (xor_vec (bool_to_bits (eq_vec w__1 w__2)) ((bool_to_bits ne)  : mword 1)))
       : bool then
      let offset : bits 64 :=
        add_vec_int (mips_sign_extend 64 (concat_vec imm ('b"00"  : mword 2))) 4 in
      ((read_reg PC_ref)  : M (mword 64)) >>= fun w__3 : mword 64 =>
      (execute_branch (add_vec w__3 offset))
       : M (unit)
    else if sumbool_of_bool likely then
      ((read_reg PC_ref)  : M (mword 64)) >>= fun w__4 : mword 64 =>
      write_reg NextPC_ref (add_vec_int w__4 8)
       : M (unit)
    else write_reg NextInBranchDelay_ref ('b"1"  : mword 1)  : M (unit))
    : M (unit).

Definition execute_BCMPZ
(rs : mword 5) (imm : mword 16) (cmp : Comparison) (link : bool) (likely : bool)
: M (unit) :=
   ((read_reg InBranchDelay_ref)  : M (mword 1)) >>= fun w__0 : mword 1 =>
   (if (bits_to_bool w__0)  : bool then (SignalException ResI)  : M (unit)
    else returnm tt) >>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   let linkVal := add_vec_int w__1 8 in
   (rGPR rs) >>= fun regVal =>
   let condition := compare cmp regVal (mips_zero_extend 64 ('b"0"  : mword 1)) in
   (if sumbool_of_bool condition then
      let offset : bits 64 :=
        add_vec_int (mips_sign_extend 64 (concat_vec imm ('b"00"  : mword 2))) 4 in
      ((read_reg PC_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
      (execute_branch (add_vec w__2 offset))
       : M (unit)
    else if sumbool_of_bool likely then
      ((read_reg PC_ref)  : M (mword 64)) >>= fun w__3 : mword 64 =>
      write_reg NextPC_ref (add_vec_int w__3 8)
       : M (unit)
    else write_reg NextInBranchDelay_ref ('b"1"  : mword 1)  : M (unit)) >>
   (if sumbool_of_bool link then (wGPR ('b"11111"  : mword 5) linkVal)  : M (unit)
    else returnm tt)
    : M (unit).

Definition execute_ANDI (rs : mword 5) (rt : mword 5) (imm : mword 16) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (wGPR rt (and_vec w__0 (mips_zero_extend 64 imm)))
    : M (unit).

Definition execute_AND (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun w__0 : mword 64 =>
   (rGPR rt) >>= fun w__1 : mword 64 => (wGPR rd (and_vec w__0 w__1))  : M (unit).

Definition execute_ADDU (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun opA =>
   (rGPR rt) >>= fun opB =>
   (if orb (NotWordVal opA) (NotWordVal opB) then
      (undefined_bitvector 64) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit)
    else
      (wGPR rd
         (mips_sign_extend 64 (add_vec (subrange_vec_dec opA 31 0) (subrange_vec_dec opB 31 0))))
       : M (unit))
    : M (unit).

Definition execute_ADDIU (rs : mword 5) (rt : mword 5) (imm : mword 16) : M (unit) :=
   (rGPR rs) >>= fun opA =>
   (if NotWordVal opA then
      (undefined_bitvector 64) >>= fun w__0 : mword 64 => (wGPR rt w__0)  : M (unit)
    else
      (wGPR rt
         (mips_sign_extend 64
            (add_vec (subrange_vec_dec opA 31 0) (mips_sign_extend (Z.add (Z.sub 31 0) 1) imm))))
       : M (unit))
    : M (unit).

Definition execute_ADDI (rs : mword 5) (rt : mword 5) (imm : mword 16) : M (unit) :=
   (rGPR rs) >>= fun opA =>
   (if NotWordVal opA then
      (undefined_bitvector 64) >>= fun w__0 : mword 64 => (wGPR rt w__0)  : M (unit)
    else
      let sum33 : bits 33 :=
        add_vec (mips_sign_extend 33 (subrange_vec_dec opA 31 0)) (mips_sign_extend 33 imm) in
      (if neq_bool (bit_to_bool (access_vec_dec sum33 32)) (bit_to_bool (access_vec_dec sum33 31))
       then
         (SignalException Ov)
          : M (unit)
       else (wGPR rt (mips_sign_extend 64 (subrange_vec_dec sum33 31 0)))  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_ADD (rs : mword 5) (rt : mword 5) (rd : mword 5) : M (unit) :=
   (rGPR rs) >>= fun opA : bits 64 =>
   (rGPR rt) >>= fun opB : bits 64 =>
   (if orb (NotWordVal opA) (NotWordVal opB) then
      (undefined_bitvector 64) >>= fun w__0 : mword 64 => (wGPR rd w__0)  : M (unit)
    else
      let sum33 : bits 33 :=
        add_vec (mips_sign_extend 33 (subrange_vec_dec opA 31 0))
          (mips_sign_extend 33 (subrange_vec_dec opB 31 0)) in
      (if neq_bool (bit_to_bool (access_vec_dec sum33 32)) (bit_to_bool (access_vec_dec sum33 31))
       then
         (SignalException Ov)
          : M (unit)
       else (wGPR rd (mips_sign_extend 64 (subrange_vec_dec sum33 31 0)))  : M (unit))
       : M (unit))
    : M (unit).

Definition execute_measure (instr : ast) : Z :=
   match instr with | CLCNT (cd, cb, rt) => 1 | _ => 0 end.

Fixpoint _rec_execute (merge_var : ast) (_reclimit : Z) (_acc : Acc (Zwf 0) _reclimit)
{struct _acc} : M (unit).
exact (
   assert_exp' (Z.geb _reclimit 0) "recursion limit reached" >>= fun _ =>
   (match merge_var with
    | CLCNT (cd, cb, rt) =>
       (_rec_execute (CLC (cd, cb, rt, to_bits 11 0)) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (unit)
    | DADDIU (rs, rt, imm) => (execute_DADDIU rs rt imm)  : M (unit)
    | DADDU (rs, rt, rd) => (execute_DADDU rs rt rd)  : M (unit)
    | DADDI (rs, rt, imm) => (execute_DADDI rs rt imm)  : M (unit)
    | DADD (rs, rt, rd) => (execute_DADD rs rt rd)  : M (unit)
    | ADD (rs, rt, rd) => (execute_ADD rs rt rd)  : M (unit)
    | ADDI (rs, rt, imm) => (execute_ADDI rs rt imm)  : M (unit)
    | ADDU (rs, rt, rd) => (execute_ADDU rs rt rd)  : M (unit)
    | ADDIU (rs, rt, imm) => (execute_ADDIU rs rt imm)  : M (unit)
    | DSUBU (rs, rt, rd) => (execute_DSUBU rs rt rd)  : M (unit)
    | DSUB (rs, rt, rd) => (execute_DSUB rs rt rd)  : M (unit)
    | SUB (rs, rt, rd) => (execute_SUB rs rt rd)  : M (unit)
    | SUBU (rs, rt, rd) => (execute_SUBU rs rt rd)  : M (unit)
    | AND (rs, rt, rd) => (execute_AND rs rt rd)  : M (unit)
    | ANDI (rs, rt, imm) => (execute_ANDI rs rt imm)  : M (unit)
    | OR (rs, rt, rd) => (execute_OR rs rt rd)  : M (unit)
    | ORI (rs, rt, imm) => (execute_ORI rs rt imm)  : M (unit)
    | NOR (rs, rt, rd) => (execute_NOR rs rt rd)  : M (unit)
    | XOR (rs, rt, rd) => (execute_XOR rs rt rd)  : M (unit)
    | XORI (rs, rt, imm) => (execute_XORI rs rt imm)  : M (unit)
    | LUI (rt, imm) => (execute_LUI rt imm)  : M (unit)
    | DSLL (rt, rd, sa) => (execute_DSLL rt rd sa)  : M (unit)
    | DSLL32 (rt, rd, sa) => (execute_DSLL32 rt rd sa)  : M (unit)
    | DSLLV (rs, rt, rd) => (execute_DSLLV rs rt rd)  : M (unit)
    | DSRA (rt, rd, sa) => (execute_DSRA rt rd sa)  : M (unit)
    | DSRA32 (rt, rd, sa) => (execute_DSRA32 rt rd sa)  : M (unit)
    | DSRAV (rs, rt, rd) => (execute_DSRAV rs rt rd)  : M (unit)
    | DSRL (rt, rd, sa) => (execute_DSRL rt rd sa)  : M (unit)
    | DSRL32 (rt, rd, sa) => (execute_DSRL32 rt rd sa)  : M (unit)
    | DSRLV (rs, rt, rd) => (execute_DSRLV rs rt rd)  : M (unit)
    | SLL (rt, rd, sa) => (execute_SLL rt rd sa)  : M (unit)
    | SLLV (rs, rt, rd) => (execute_SLLV rs rt rd)  : M (unit)
    | SRA (rt, rd, sa) => (execute_SRA rt rd sa)  : M (unit)
    | SRAV (rs, rt, rd) => (execute_SRAV rs rt rd)  : M (unit)
    | SRL (rt, rd, sa) => (execute_SRL rt rd sa)  : M (unit)
    | SRLV (rs, rt, rd) => (execute_SRLV rs rt rd)  : M (unit)
    | SLT (rs, rt, rd) => (execute_SLT rs rt rd)  : M (unit)
    | SLTI (rs, rt, imm) => (execute_SLTI rs rt imm)  : M (unit)
    | SLTU (rs, rt, rd) => (execute_SLTU rs rt rd)  : M (unit)
    | SLTIU (rs, rt, imm) => (execute_SLTIU rs rt imm)  : M (unit)
    | MOVN (rs, rt, rd) => (execute_MOVN rs rt rd)  : M (unit)
    | MOVZ (rs, rt, rd) => (execute_MOVZ rs rt rd)  : M (unit)
    | MFHI rd => (execute_MFHI rd)  : M (unit)
    | MFLO rd => (execute_MFLO rd)  : M (unit)
    | MTHI rs => (execute_MTHI rs)  : M (unit)
    | MTLO rs => (execute_MTLO rs)  : M (unit)
    | MUL (rs, rt, rd) => (execute_MUL rs rt rd)  : M (unit)
    | MULT (rs, rt) => (execute_MULT rs rt)  : M (unit)
    | MULTU (rs, rt) => (execute_MULTU rs rt)  : M (unit)
    | DMULT (rs, rt) => (execute_DMULT rs rt)  : M (unit)
    | DMULTU (rs, rt) => (execute_DMULTU rs rt)  : M (unit)
    | MADD (rs, rt) => (execute_MADD rs rt)  : M (unit)
    | MADDU (rs, rt) => (execute_MADDU rs rt)  : M (unit)
    | MSUB (rs, rt) => (execute_MSUB rs rt)  : M (unit)
    | MSUBU (rs, rt) => (execute_MSUBU rs rt)  : M (unit)
    | DIV (rs, rt) => (execute_DIV rs rt)  : M (unit)
    | DIVU (rs, rt) => (execute_DIVU rs rt)  : M (unit)
    | DDIV (rs, rt) => (execute_DDIV rs rt)  : M (unit)
    | DDIVU (rs, rt) => (execute_DDIVU rs rt)  : M (unit)
    | J offset => (execute_J offset)  : M (unit)
    | JAL offset => (execute_JAL offset)  : M (unit)
    | JR rs => (execute_JR rs)  : M (unit)
    | JALR (rs, rd) => (execute_JALR rs rd)  : M (unit)
    | BEQ (rs, rd, imm, ne, likely) => (execute_BEQ rs rd imm ne likely)  : M (unit)
    | BCMPZ (rs, imm, cmp, link, likely) => (execute_BCMPZ rs imm cmp link likely)  : M (unit)
    | SYSCALL arg0 => (execute_SYSCALL arg0)  : M (unit)
    | BREAK arg0 => (execute_BREAK arg0)  : M (unit)
    | WAIT arg0 => (execute_WAIT arg0)  : M (unit)
    | TRAPREG (rs, rt, cmp) => (execute_TRAPREG rs rt cmp)  : M (unit)
    | TRAPIMM (rs, imm, cmp) => (execute_TRAPIMM rs imm cmp)  : M (unit)
    | Load (width, sign, linked, base, rt, offset) =>
       (execute_Load width sign linked base rt offset)  : M (unit)
    | Store (width, conditional, base, rt, offset) =>
       (execute_Store width conditional base rt offset)  : M (unit)
    | LWL (base, rt, offset) => (execute_LWL base rt offset)  : M (unit)
    | LWR (base, rt, offset) => (execute_LWR base rt offset)  : M (unit)
    | SWL (base, rt, offset) => (execute_SWL base rt offset)  : M (unit)
    | SWR (base, rt, offset) => (execute_SWR base rt offset)  : M (unit)
    | LDL (base, rt, offset) => (execute_LDL base rt offset)  : M (unit)
    | LDR (base, rt, offset) => (execute_LDR base rt offset)  : M (unit)
    | SDL (base, rt, offset) => (execute_SDL base rt offset)  : M (unit)
    | SDR (base, rt, offset) => (execute_SDR base rt offset)  : M (unit)
    | CACHE (base, op, imm) => (execute_CACHE base op imm)  : M (unit)
    | SYNC arg0 => (execute_SYNC arg0)  : M (unit)
    | MFC0 (rt, rd, sel, double) => (execute_MFC0 rt rd sel double)  : M (unit)
    | HCF arg0 => returnm (execute_HCF arg0)
    | MTC0 (rt, rd, sel, double) => (execute_MTC0 rt rd sel double)  : M (unit)
    | TLBWI arg0 => (execute_TLBWI arg0)  : M (unit)
    | TLBWR arg0 => (execute_TLBWR arg0)  : M (unit)
    | TLBR arg0 => (execute_TLBR arg0)  : M (unit)
    | TLBP arg0 => (execute_TLBP arg0)  : M (unit)
    | RDHWR (rt, rd) => (execute_RDHWR rt rd)  : M (unit)
    | ERET arg0 => (execute_ERET arg0)  : M (unit)
    | CGetPerm (rd, cb) => (execute_CGetPerm rd cb)  : M (unit)
    | CGetFlags (rd, cb) => (execute_CGetFlags rd cb)  : M (unit)
    | CGetType (rd, cb) => (execute_CGetType rd cb)  : M (unit)
    | CGetBase (rd, cb) => (execute_CGetBase rd cb)  : M (unit)
    | CGetOffset (rd, cb) => (execute_CGetOffset rd cb)  : M (unit)
    | CGetLen (rd, cb) => (execute_CGetLen rd cb)  : M (unit)
    | CGetTag (rd, cb) => (execute_CGetTag rd cb)  : M (unit)
    | CGetSealed (rd, cb) => (execute_CGetSealed rd cb)  : M (unit)
    | CGetAddr (rd, cb) => (execute_CGetAddr rd cb)  : M (unit)
    | CGetAndAddr (rd, cb, rs) => (execute_CGetAndAddr rd cb rs)  : M (unit)
    | CGetPCC cd => (execute_CGetPCC cd)  : M (unit)
    | CGetPCCSetOffset (cd, rs) => (execute_CGetPCCSetOffset cd rs)  : M (unit)
    | CGetPCCIncOffset (cd, rs) => (execute_CGetPCCIncOffset cd rs)  : M (unit)
    | CGetPCCSetAddr (cd, rs) => (execute_CGetPCCSetAddr cd rs)  : M (unit)
    | CGetCause rd => (execute_CGetCause rd)  : M (unit)
    | CSetCause rt => (execute_CSetCause rt)  : M (unit)
    | CGetCID rd => (execute_CGetCID rd)  : M (unit)
    | CSetCID cb => (execute_CSetCID cb)  : M (unit)
    | CRAP (rt, rs) => (execute_CRAP rt rs)  : M (unit)
    | CRAM (rt, rs) => (execute_CRAM rt rs)  : M (unit)
    | CReadHwr (cd, sel) => (execute_CReadHwr cd sel)  : M (unit)
    | CWriteHwr (cb, sel) => (execute_CWriteHwr cb sel)  : M (unit)
    | CAndPerm (cd, cb, rt) => (execute_CAndPerm cd cb rt)  : M (unit)
    | CSetFlags (cd, cb, rt) => (execute_CSetFlags cd cb rt)  : M (unit)
    | CToPtr (rd, cb, ct) => (execute_CToPtr rd cb ct)  : M (unit)
    | CSub (rd, cb, ct) => (execute_CSub rd cb ct)  : M (unit)
    | CPtrCmp (rd, cb, ct, op) => (execute_CPtrCmp rd cb ct op)  : M (unit)
    | CIncOffset (cd, cb, rt) => (execute_CIncOffset cd cb rt)  : M (unit)
    | CIncOffsetImmediate (cd, cb, imm) => (execute_CIncOffsetImmediate cd cb imm)  : M (unit)
    | CSetOffset (cd, cb, rt) => (execute_CSetOffset cd cb rt)  : M (unit)
    | CSetAddr (cd, cb, rt) => (execute_CSetAddr cd cb rt)  : M (unit)
    | CAndAddr (cd, cb, rt) => (execute_CAndAddr cd cb rt)  : M (unit)
    | CSetBounds (cd, cb, rt) => (execute_CSetBounds cd cb rt)  : M (unit)
    | CSetBoundsImmediate (cd, cb, imm) => (execute_CSetBoundsImmediate cd cb imm)  : M (unit)
    | CSetBoundsExact (cd, cb, rt) => (execute_CSetBoundsExact cd cb rt)  : M (unit)
    | CClearTag (cd, cb) => (execute_CClearTag cd cb)  : M (unit)
    | CMOVX (cd, cb, rt, ismovn) => (execute_CMOVX cd cb rt ismovn)  : M (unit)
    | CMove (cd, cb) => (execute_CMove cd cb)  : M (unit)
    | ClearRegs (regset, m) => (execute_ClearRegs regset m)  : M (unit)
    | CFromPtr (cd, cb, rt) => (execute_CFromPtr cd cb rt)  : M (unit)
    | CBuildCap (cd, cb, ct) => (execute_CBuildCap cd cb ct)  : M (unit)
    | CCopyType (cd, cb, ct) => (execute_CCopyType cd cb ct)  : M (unit)
    | CCheckPerm (cs, rt) => (execute_CCheckPerm cs rt)  : M (unit)
    | CCheckType (cs, cb) => (execute_CCheckType cs cb)  : M (unit)
    | CCheckTag cs => (execute_CCheckTag cs)  : M (unit)
    | CTestSubset (rd, cb, ct) => (execute_CTestSubset rd cb ct)  : M (unit)
    | CSeal (cd, cs, ct) => (execute_CSeal cd cs ct)  : M (unit)
    | CCSeal (cd, cs, ct) => (execute_CCSeal cd cs ct)  : M (unit)
    | CSealEntry (cd, cs) => (execute_CSealEntry cd cs)  : M (unit)
    | CUnseal (cd, cs, ct) => (execute_CUnseal cd cs ct)  : M (unit)
    | CCall (cs, cb, b__107) => (execute_CCall cs cb b__107)  : M (unit)
    | CReturn arg0 => (execute_CReturn arg0)  : M (unit)
    | CBX (cb, imm, notset) => (execute_CBX cb imm notset)  : M (unit)
    | CBZ (cb, imm, notzero) => (execute_CBZ cb imm notzero)  : M (unit)
    | CJALR (cd, cb, link) => (execute_CJALR cd cb link)  : M (unit)
    | CLoad (rd, cb, rt, offset, signext, width) =>
       (execute_CLoad rd cb rt offset signext width)  : M (unit)
    | CLoadLinked (rd, cb, signext, width) => (execute_CLoadLinked rd cb signext width)  : M (unit)
    | CLoadTags (rd, cb) => (execute_CLoadTags rd cb)  : M (unit)
    | CStore (rs, cb, rt, offset, width) => (execute_CStore rs cb rt offset width)  : M (unit)
    | CStoreConditional (rs, cb, rd, width) =>
       (execute_CStoreConditional rs cb rd width)  : M (unit)
    | CSC (cs, cb, rt, offset) => (execute_CSC cs cb rt offset)  : M (unit)
    | CSCC (cs, cb, rd) => (execute_CSCC cs cb rd)  : M (unit)
    | CLC (cd, cb, rt, offset) => (execute_CLC cd cb rt offset)  : M (unit)
    | CLCBI (cd, cb, offset) => (execute_CLCBI cd cb offset)  : M (unit)
    | CLLC (cd, cb) => (execute_CLLC cd cb)  : M (unit)
    | CClearTags cb => (execute_CClearTags cb)  : M (unit)
    | C2Dump rt => returnm (execute_C2Dump rt)
    | RI arg0 => (execute_RI arg0)  : M (unit)
    end)
    : M (unit)
).
Defined.


Definition execute (i : ast) : M (unit) :=
   (_rec_execute i ((execute_measure i)  : Z) (Zwf_guarded _))  : M (unit).

Definition assembly (merge_var : ast) : string :=
   match merge_var with
   | DADDIU (rs, rt, imm) => String.append "daddiu " (strRRIArgs rs rt imm)
   | DADDU (rs, rt, rd) => String.append "daddu " (strRRRArgs rs rt rd)
   | DADDI (rs, rt, imm) => String.append "daddi " (strRRIArgs rs rt imm)
   | DADD (rs, rt, rd) => String.append "dadd " (strRRRArgs rs rt rd)
   | ADD (rs, rt, rd) => String.append "add " (strRRRArgs rs rt rd)
   | ADDI (rs, rt, imm) => String.append "addi " (strRRIArgs rs rt imm)
   | ADDU (rs, rt, rd) => String.append "addu " (strRRRArgs rs rt rd)
   | ADDIU (rs, rt, imm) => String.append "addiu " (strRRIArgs rs rt imm)
   | DSUBU (rs, rt, rd) => String.append "dsubu " (strRRRArgs rs rt rd)
   | DSUB (rs, rt, rd) => String.append "dsub " (strRRRArgs rs rt rd)
   | SUB (rs, rt, rd) => String.append "sub " (strRRRArgs rs rt rd)
   | SUBU (rs, rt, rd) => String.append "subu " (strRRRArgs rs rt rd)
   | AND (rs, rt, rd) => String.append "and " (strRRRArgs rs rt rd)
   | ANDI (rs, rt, imm) => String.append "andi " (strRRIUArgs rs rt imm)
   | OR (rs, rt, rd) => String.append "or " (strRRRArgs rs rt rd)
   | ORI (rs, rt, imm) => String.append "ori " (strRRIUArgs rs rt imm)
   | NOR (rs, rt, rd) => String.append "nor " (strRRRArgs rs rt rd)
   | XOR (rs, rt, rd) => String.append "xor " (strRRRArgs rs rt rd)
   | XORI (rs, rt, imm) => String.append "xori " (strRRIUArgs rs rt imm)
   | LUI (rt, imm) => String.append "lui " (strRIArgs rt imm)
   | DSLL (rs, rd, sa) => String.append "dsll " (strRRIUArgs rs rd sa)
   | DSLL32 (rs, rd, sa) => String.append "dsll32 " (strRRIUArgs rs rd sa)
   | DSLLV (rs, rt, rd) => String.append "dsllv " (strRRRArgs rs rt rd)
   | DSRA (rt, rd, sa) => String.append "dsra " (strRRIUArgs rt rd sa)
   | DSRA32 (rt, rd, sa) => String.append "dsra32 " (strRRIUArgs rt rd sa)
   | DSRAV (rs, rt, rd) => String.append "dsrav " (strRRRArgs rs rt rd)
   | DSRL (rt, rd, sa) => String.append "dsrl " (strRRIUArgs rt rd sa)
   | DSRL32 (rt, rd, sa) => String.append "dsrl32 " (strRRIUArgs rt rd sa)
   | DSRLV (rs, rt, rd) => String.append "dsrlv " (strRRRArgs rs rt rd)
   | SLL (rt, rd, sa) => String.append "sll " (strRRIUArgs rt rd sa)
   | SLLV (rs, rt, rd) => String.append "sllv " (strRRRArgs rs rt rd)
   | SRA (rt, rd, sa) => String.append "sra " (strRRIUArgs rt rd sa)
   | SRAV (rs, rt, rd) => String.append "srav " (strRRRArgs rs rt rd)
   | SRL (rt, rd, sa) => String.append "srl " (strRRIUArgs rt rd sa)
   | SRLV (rs, rt, rd) => String.append "srlv " (strRRRArgs rs rt rd)
   | SLT (rs, rt, rd) => String.append "slt " (strRRRArgs rs rt rd)
   | SLTI (rs, rd, imm) => String.append "slti " (strRRIArgs rs rd imm)
   | SLTU (rs, rt, rd) => String.append "sltu " (strRRRArgs rs rt rd)
   | SLTIU (rs, rd, imm) => String.append "sltiu " (strRRIUArgs rs rd imm)
   | MOVN (rs, rt, rd) => String.append "movn " (strRRRArgs rs rt rd)
   | MOVZ (rs, rt, rd) => String.append "movz " (strRRRArgs rs rt rd)
   | MFHI rd => String.append "mfhi " (strReg rd)
   | MFLO rd => String.append "mflo " (strReg rd)
   | MTHI rs => String.append "mthi " (strReg rs)
   | MTLO rs => String.append "mtlo " (strReg rs)
   | MUL (rs, rt, rd) => String.append "mul " (strRRRArgs rs rt rd)
   | MULT (rs, rt) =>
      String.append "mult " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | MULTU (rs, rt) =>
      String.append "multu " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | DMULT (rs, rt) =>
      String.append "dmult " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | DMULTU (rs, rt) =>
      String.append "dmultu " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | MADD (rs, rt) =>
      String.append "madd " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | MADDU (rs, rt) =>
      String.append "maddu " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | MSUB (rs, rt) =>
      String.append "msub " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | MSUBU (rs, rt) =>
      String.append "msubu " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | DIV (rs, rt) =>
      String.append "div " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | DIVU (rs, rt) =>
      String.append "divu " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | DDIV (rs, rt) =>
      String.append "ddiv " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | DDIVU (rs, rt) =>
      String.append "ddivu " (String.append (strReg rs) (String.append ", " (strReg rt)))
   | J offset => String.append "j " (hex_str (projT1 (uint offset)))
   | JAL offset => String.append "jal " (hex_str (projT1 (uint offset)))
   | JR rs => String.append "jr " (strReg rs)
   | JALR (rs, rd) =>
      String.append "jalr " (String.append (strReg rd) (String.append ", " (strReg rs)))
   | BEQ (rs, rt, imm, ne, likely) =>
      let op := if sumbool_of_bool ne then "bne" else "beq" in
      let l := if sumbool_of_bool likely then "l " else " " in
      String.append op
        (String.append l
           (String.append (strReg rs)
              (String.append ", "
                 (String.append (strReg rt) (String.append ", " (hex_str (projT1 (sint imm))))))))
   | BCMPZ (rs, imm, cmp, link, likely) =>
      let op := String.append "b" (String.append (strCmp cmp) "z") in
      let al := if sumbool_of_bool link then "al" else "" in
      let l := if sumbool_of_bool likely then "l " else " " in
      String.append op
        (String.append al
           (String.append l
              (String.append (strReg rs) (String.append ", " (hex_str (projT1 (sint imm)))))))
   | SYSCALL tt => "syscall"
   | BREAK tt => "break"
   | WAIT tt => "wait"
   | TRAPREG (rs, rt, cmp) =>
      let op := String.append "t" (String.append (strCmp cmp) " ") in
      String.append op (String.append (strReg rs) (String.append ", " (strReg rt)))
   | TRAPIMM (rs, imm, cmp) =>
      let op := String.append "t" (String.append (strCmp cmp) "i ") in
      String.append op
        (String.append (strReg rs) (String.append ", " (hex_str (projT1 (uint imm)))))
   | Load (width, sign, linked, base, rt, offset) =>
      let op : string :=
        match (width, sign, linked) with
        | (B, true, false) => "lb "
        | (B, false, false) => "lbu "
        | (H, true, false) => "lh "
        | (H, false, false) => "lhu "
        | (W, true, false) => "lw "
        | (W, false, false) => "lwu "
        | (D, false, false) => "ld "
        | (W, true, true) => "ll "
        | (D, false, true) => "lld "
        | _ => "invalid load"
        end in
      String.append op (strMemArgs base rt offset)
   | Store (width, conditional, base, rt, offset) =>
      let op : string :=
        if sumbool_of_bool conditional then
          match width with | W => "sc" | D => "scd" | _ => "invalid sc" end
        else String.append "s" (strWordType width) in
      String.append op (String.append " " (strMemArgs base rt offset))
   | LWL (base, rt, offset) => String.append "lwl " (strMemArgs base rt offset)
   | LWR (base, rt, offset) => String.append "lwr " (strMemArgs base rt offset)
   | SWL (base, rt, offset) => String.append "swl " (strMemArgs base rt offset)
   | SWR (base, rt, offset) => String.append "swr " (strMemArgs base rt offset)
   | LDL (base, rt, offset) => String.append "ldl " (strMemArgs base rt offset)
   | LDR (base, rt, offset) => String.append "ldr " (strMemArgs base rt offset)
   | SDL (base, rt, offset) => String.append "sdl " (strMemArgs base rt offset)
   | SDR (base, rt, offset) => String.append "sdr " (strMemArgs base rt offset)
   | CACHE (base, op, imm) => String.append "cache " (strMemArgs base op imm)
   | SYNC tt => "sync"
   | MFC0 (rt, rd, sel, double) =>
      let op := if sumbool_of_bool double then "dmfc0 " else "mfc0 " in
      String.append op
        (String.append (strReg rt)
           (String.append ", "
              (String.append (strReg rd) (String.append ", $" (dec_str (projT1 (uint sel)))))))
   | MTC0 (rt, rd, sel, double) =>
      let op := if sumbool_of_bool double then "dmtc0 " else "mtc0 " in
      String.append op
        (String.append (strReg rt)
           (String.append ", "
              (String.append (strReg rd) (String.append ", $" (dec_str (projT1 (uint sel)))))))
   | TLBWI tt => "tlbwi"
   | TLBWR tt => "tlbwr"
   | TLBR tt => "tlbr"
   | TLBP tt => "tlbp"
   | RDHWR (rt, rd) =>
      String.append "rdhwr" (String.append (strReg rt) (String.append ", " (strReg rd)))
   | ERET tt => "eret"
   | CGetCause rd => String.append "cgetcause " (strReg rd)
   | CSetCause rs => String.append "csetcause " (strReg rs)
   | CGetPCC cd => String.append "cgetpcc " (strCReg cd)
   | CJALR (b__0, cb, false) =>
      if eq_vec b__0 ('b"00000"  : mword 5) then String.append "cjr " (strCReg cb)
      else "assembly unimplemented"
   | CGetCID rd => String.append "cgetcid " (strReg rd)
   | CSetCID cb => String.append "csetcid " (strCReg cb)
   | CClearTags cb => String.append "ccleartags " (strCReg cb)
   | CCheckPerm (cs, rt) => String.append "ccheckperm " (strCRArgs cs rt)
   | CCheckType (cs, cb) => String.append "cchecktype " (strCCArgs cs cb)
   | CClearTag (cd, cb) => String.append "ccleartag " (strCCArgs cd cb)
   | CMove (cd, cs) => String.append "cmove " (strCCArgs cd cs)
   | CJALR (cd, cb, true) => String.append "cjalr " (strCCArgs cd cb)
   | CSealEntry (cd, cb) => String.append "csealentry " (strCCArgs cd cb)
   | CLoadTags (rd, cb) => String.append "cloadtags " (strRCArgs rd cb)
   | CGetPerm (rd, cb) => String.append "cgetperm " (strRCArgs rd cb)
   | CGetType (rd, cb) => String.append "cgettype " (strRCArgs rd cb)
   | CGetBase (rd, cb) => String.append "cgetbase " (strRCArgs rd cb)
   | CGetLen (rd, cb) => String.append "cgetlen " (strRCArgs rd cb)
   | CGetTag (rd, cb) => String.append "cgettag " (strRCArgs rd cb)
   | CGetSealed (rd, cb) => String.append "cgetsealed " (strRCArgs rd cb)
   | CGetOffset (rd, cb) => String.append "cgetoffset " (strRCArgs rd cb)
   | CGetPCCSetOffset (cd, rs) => String.append "cgetpccsetoffset " (strCRArgs cd rs)
   | CReadHwr (cd, sel) => String.append "creadhwr " (strCRArgs cd sel)
   | CWriteHwr (cb, sel) => String.append "cwritehwr " (strCRArgs cb sel)
   | CGetAddr (rd, cb) => String.append "cgetaddr " (strRCArgs rd cb)
   | CGetFlags (rd, cb) => String.append "cgetflags " (strRCArgs rd cb)
   | CGetPCCIncOffset (cd, rs) => String.append "cgetpccincoffset " (strCRArgs cd rs)
   | CGetPCCSetAddr (cd, rs) => String.append "cgetpccsetaddr " (strCRArgs cd rs)
   | CRAP (rt, rs) => String.append "crrl " (strRRArgs rt rs)
   | CRAM (rt, rs) => String.append "cram " (strRRArgs rt rs)
   | CSeal (cd, cs, ct) => String.append "cseal " (strCCCArgs cd cs ct)
   | CUnseal (cd, cs, ct) => String.append "cunseal " (strCCCArgs cd cs ct)
   | CAndPerm (cd, cs, rt) => String.append "candperm " (strCCRArgs cd cs rt)
   | CSetOffset (cd, cs, rt) => String.append "csetoffset " (strCCRArgs cd cs rt)
   | CSetBounds (cd, cs, rt) => String.append "csetbounds " (strCCRArgs cd cs rt)
   | CSetBoundsExact (cd, cs, rt) => String.append "csetboundsexact " (strCCRArgs cd cs rt)
   | CSetFlags (cd, cs, rt) => String.append "csetflags " (strCCRArgs cd cs rt)
   | CIncOffset (cd, cs, rt) => String.append "cincoffset " (strCCRArgs cd cs rt)
   | CBuildCap (cd, cs, ct) => String.append "cbuildcap " (strCCCArgs cd cs ct)
   | CCopyType (cd, cs, ct) => String.append "ccopytype " (strCCCArgs cd cs ct)
   | CCSeal (cd, cs, ct) => String.append "ccseal " (strCCCArgs cd cs ct)
   | CToPtr (rd, cb, ct) => String.append "ctoptr " (strRCRArgs rd cb ct)
   | CFromPtr (cd, cb, rs) => String.append "cfromptr " (strCCRArgs cd cb rs)
   | CSub (rt, cb, cs) => String.append "csub " (strRCCArgs rt cb cs)
   | CMOVX (cd, cs, rs, false) => String.append "cmovz " (strCCRArgs cd cs rs)
   | CMOVX (cd, cs, rs, true) => String.append "cmovn " (strCCRArgs cd cs rs)
   | CSetAddr (cd, cs, rt) => String.append "csetaddr " (strCCRArgs cd cs rt)
   | CGetAndAddr (rd, cs, rs) => String.append "cgetandaddr " (strRCRArgs rd cs rs)
   | CAndAddr (cd, cs, rt) => String.append "candaddr " (strCCRArgs cd cs rt)
   | CReturn tt => "creturn"
   | CCall (cs, cb, selector) => String.append "ccall " (strCCIUArgs cs cb selector)
   | CIncOffsetImmediate (cd, cb, imm) => String.append "cincoffsetimm " (strCCIArgs cd cb imm)
   | CSetBoundsImmediate (cd, cb, imm) => String.append "csetboundsimm " (strCCIUArgs cd cb imm)
   | RI tt => "reserved instruction"
   | _ => "assembly unimplemented"
   end.

Definition supported_instructions (instr : ast) : option ast := Some instr.

Definition initialize_registers '(tt : unit) : M (unit) :=
   (undefined_bitvector 64) >>= fun w__0 : mword 64 =>
   write_reg PC_ref w__0 >>
   (undefined_bitvector 64) >>= fun w__1 : mword 64 =>
   write_reg NextPC_ref w__1 >>
   (undefined_bitvector 1) >>= fun w__2 : mword 1 =>
   write_reg TLBProbe_ref w__2 >>
   (undefined_bitvector 6) >>= fun w__3 : mword 6 =>
   write_reg TLBIndex_ref w__3 >>
   (undefined_bitvector 6) >>= fun w__4 : mword 6 =>
   write_reg TLBRandom_ref w__4 >>
   (undefined_TLBEntryLoReg tt) >>= fun w__5 : TLBEntryLoReg =>
   write_reg TLBEntryLo0_ref w__5 >>
   (undefined_TLBEntryLoReg tt) >>= fun w__6 : TLBEntryLoReg =>
   write_reg TLBEntryLo1_ref w__6 >>
   (undefined_ContextReg tt) >>= fun w__7 : ContextReg =>
   write_reg TLBContext_ref w__7 >>
   (undefined_bitvector 16) >>= fun w__8 : mword 16 =>
   write_reg TLBPageMask_ref w__8 >>
   (undefined_bitvector 6) >>= fun w__9 : mword 6 =>
   write_reg TLBWired_ref w__9 >>
   (undefined_TLBEntryHiReg tt) >>= fun w__10 : TLBEntryHiReg =>
   write_reg TLBEntryHi_ref w__10 >>
   (undefined_XContextReg tt) >>= fun w__11 : XContextReg =>
   write_reg TLBXContext_ref w__11 >>
   (undefined_TLBEntry tt) >>= fun w__12 : TLBEntry =>
   write_reg TLBEntry00_ref w__12 >>
   (undefined_TLBEntry tt) >>= fun w__13 : TLBEntry =>
   write_reg TLBEntry01_ref w__13 >>
   (undefined_TLBEntry tt) >>= fun w__14 : TLBEntry =>
   write_reg TLBEntry02_ref w__14 >>
   (undefined_TLBEntry tt) >>= fun w__15 : TLBEntry =>
   write_reg TLBEntry03_ref w__15 >>
   (undefined_TLBEntry tt) >>= fun w__16 : TLBEntry =>
   write_reg TLBEntry04_ref w__16 >>
   (undefined_TLBEntry tt) >>= fun w__17 : TLBEntry =>
   write_reg TLBEntry05_ref w__17 >>
   (undefined_TLBEntry tt) >>= fun w__18 : TLBEntry =>
   write_reg TLBEntry06_ref w__18 >>
   (undefined_TLBEntry tt) >>= fun w__19 : TLBEntry =>
   write_reg TLBEntry07_ref w__19 >>
   (undefined_TLBEntry tt) >>= fun w__20 : TLBEntry =>
   write_reg TLBEntry08_ref w__20 >>
   (undefined_TLBEntry tt) >>= fun w__21 : TLBEntry =>
   write_reg TLBEntry09_ref w__21 >>
   (undefined_TLBEntry tt) >>= fun w__22 : TLBEntry =>
   write_reg TLBEntry10_ref w__22 >>
   (undefined_TLBEntry tt) >>= fun w__23 : TLBEntry =>
   write_reg TLBEntry11_ref w__23 >>
   (undefined_TLBEntry tt) >>= fun w__24 : TLBEntry =>
   write_reg TLBEntry12_ref w__24 >>
   (undefined_TLBEntry tt) >>= fun w__25 : TLBEntry =>
   write_reg TLBEntry13_ref w__25 >>
   (undefined_TLBEntry tt) >>= fun w__26 : TLBEntry =>
   write_reg TLBEntry14_ref w__26 >>
   (undefined_TLBEntry tt) >>= fun w__27 : TLBEntry =>
   write_reg TLBEntry15_ref w__27 >>
   (undefined_TLBEntry tt) >>= fun w__28 : TLBEntry =>
   write_reg TLBEntry16_ref w__28 >>
   (undefined_TLBEntry tt) >>= fun w__29 : TLBEntry =>
   write_reg TLBEntry17_ref w__29 >>
   (undefined_TLBEntry tt) >>= fun w__30 : TLBEntry =>
   write_reg TLBEntry18_ref w__30 >>
   (undefined_TLBEntry tt) >>= fun w__31 : TLBEntry =>
   write_reg TLBEntry19_ref w__31 >>
   (undefined_TLBEntry tt) >>= fun w__32 : TLBEntry =>
   write_reg TLBEntry20_ref w__32 >>
   (undefined_TLBEntry tt) >>= fun w__33 : TLBEntry =>
   write_reg TLBEntry21_ref w__33 >>
   (undefined_TLBEntry tt) >>= fun w__34 : TLBEntry =>
   write_reg TLBEntry22_ref w__34 >>
   (undefined_TLBEntry tt) >>= fun w__35 : TLBEntry =>
   write_reg TLBEntry23_ref w__35 >>
   (undefined_TLBEntry tt) >>= fun w__36 : TLBEntry =>
   write_reg TLBEntry24_ref w__36 >>
   (undefined_TLBEntry tt) >>= fun w__37 : TLBEntry =>
   write_reg TLBEntry25_ref w__37 >>
   (undefined_TLBEntry tt) >>= fun w__38 : TLBEntry =>
   write_reg TLBEntry26_ref w__38 >>
   (undefined_TLBEntry tt) >>= fun w__39 : TLBEntry =>
   write_reg TLBEntry27_ref w__39 >>
   (undefined_TLBEntry tt) >>= fun w__40 : TLBEntry =>
   write_reg TLBEntry28_ref w__40 >>
   (undefined_TLBEntry tt) >>= fun w__41 : TLBEntry =>
   write_reg TLBEntry29_ref w__41 >>
   (undefined_TLBEntry tt) >>= fun w__42 : TLBEntry =>
   write_reg TLBEntry30_ref w__42 >>
   (undefined_TLBEntry tt) >>= fun w__43 : TLBEntry =>
   write_reg TLBEntry31_ref w__43 >>
   (undefined_TLBEntry tt) >>= fun w__44 : TLBEntry =>
   write_reg TLBEntry32_ref w__44 >>
   (undefined_TLBEntry tt) >>= fun w__45 : TLBEntry =>
   write_reg TLBEntry33_ref w__45 >>
   (undefined_TLBEntry tt) >>= fun w__46 : TLBEntry =>
   write_reg TLBEntry34_ref w__46 >>
   (undefined_TLBEntry tt) >>= fun w__47 : TLBEntry =>
   write_reg TLBEntry35_ref w__47 >>
   (undefined_TLBEntry tt) >>= fun w__48 : TLBEntry =>
   write_reg TLBEntry36_ref w__48 >>
   (undefined_TLBEntry tt) >>= fun w__49 : TLBEntry =>
   write_reg TLBEntry37_ref w__49 >>
   (undefined_TLBEntry tt) >>= fun w__50 : TLBEntry =>
   write_reg TLBEntry38_ref w__50 >>
   (undefined_TLBEntry tt) >>= fun w__51 : TLBEntry =>
   write_reg TLBEntry39_ref w__51 >>
   (undefined_TLBEntry tt) >>= fun w__52 : TLBEntry =>
   write_reg TLBEntry40_ref w__52 >>
   (undefined_TLBEntry tt) >>= fun w__53 : TLBEntry =>
   write_reg TLBEntry41_ref w__53 >>
   (undefined_TLBEntry tt) >>= fun w__54 : TLBEntry =>
   write_reg TLBEntry42_ref w__54 >>
   (undefined_TLBEntry tt) >>= fun w__55 : TLBEntry =>
   write_reg TLBEntry43_ref w__55 >>
   (undefined_TLBEntry tt) >>= fun w__56 : TLBEntry =>
   write_reg TLBEntry44_ref w__56 >>
   (undefined_TLBEntry tt) >>= fun w__57 : TLBEntry =>
   write_reg TLBEntry45_ref w__57 >>
   (undefined_TLBEntry tt) >>= fun w__58 : TLBEntry =>
   write_reg TLBEntry46_ref w__58 >>
   (undefined_TLBEntry tt) >>= fun w__59 : TLBEntry =>
   write_reg TLBEntry47_ref w__59 >>
   (undefined_TLBEntry tt) >>= fun w__60 : TLBEntry =>
   write_reg TLBEntry48_ref w__60 >>
   (undefined_TLBEntry tt) >>= fun w__61 : TLBEntry =>
   write_reg TLBEntry49_ref w__61 >>
   (undefined_TLBEntry tt) >>= fun w__62 : TLBEntry =>
   write_reg TLBEntry50_ref w__62 >>
   (undefined_TLBEntry tt) >>= fun w__63 : TLBEntry =>
   write_reg TLBEntry51_ref w__63 >>
   (undefined_TLBEntry tt) >>= fun w__64 : TLBEntry =>
   write_reg TLBEntry52_ref w__64 >>
   (undefined_TLBEntry tt) >>= fun w__65 : TLBEntry =>
   write_reg TLBEntry53_ref w__65 >>
   (undefined_TLBEntry tt) >>= fun w__66 : TLBEntry =>
   write_reg TLBEntry54_ref w__66 >>
   (undefined_TLBEntry tt) >>= fun w__67 : TLBEntry =>
   write_reg TLBEntry55_ref w__67 >>
   (undefined_TLBEntry tt) >>= fun w__68 : TLBEntry =>
   write_reg TLBEntry56_ref w__68 >>
   (undefined_TLBEntry tt) >>= fun w__69 : TLBEntry =>
   write_reg TLBEntry57_ref w__69 >>
   (undefined_TLBEntry tt) >>= fun w__70 : TLBEntry =>
   write_reg TLBEntry58_ref w__70 >>
   (undefined_TLBEntry tt) >>= fun w__71 : TLBEntry =>
   write_reg TLBEntry59_ref w__71 >>
   (undefined_TLBEntry tt) >>= fun w__72 : TLBEntry =>
   write_reg TLBEntry60_ref w__72 >>
   (undefined_TLBEntry tt) >>= fun w__73 : TLBEntry =>
   write_reg TLBEntry61_ref w__73 >>
   (undefined_TLBEntry tt) >>= fun w__74 : TLBEntry =>
   write_reg TLBEntry62_ref w__74 >>
   (undefined_TLBEntry tt) >>= fun w__75 : TLBEntry =>
   write_reg TLBEntry63_ref w__75 >>
   (undefined_bitvector 32) >>= fun w__76 : mword 32 =>
   write_reg CP0Compare_ref w__76 >>
   (undefined_CauseReg tt) >>= fun w__77 : CauseReg =>
   write_reg CP0Cause_ref w__77 >>
   (undefined_bitvector 1) >>= fun w__78 : mword 1 =>
   write_reg CP0LLBit_ref w__78 >>
   (undefined_bitvector 64) >>= fun w__79 : mword 64 =>
   write_reg CP0LLAddr_ref w__79 >>
   (undefined_bitvector 64) >>= fun w__80 : mword 64 =>
   write_reg CP0BadVAddr_ref w__80 >>
   (undefined_bitvector 32) >>= fun w__81 : mword 32 =>
   write_reg CurrentInstrBits_ref w__81 >>
   (undefined_bitvector 32) >>= fun w__82 : mword 32 =>
   write_reg LastInstrBits_ref w__82 >>
   (undefined_bitvector 32) >>= fun w__83 : mword 32 =>
   write_reg CP0BadInstr_ref w__83 >>
   (undefined_bitvector 32) >>= fun w__84 : mword 32 =>
   write_reg CP0BadInstrP_ref w__84 >>
   (undefined_bitvector 32) >>= fun w__85 : mword 32 =>
   write_reg CP0Count_ref w__85 >>
   (undefined_bitvector 32) >>= fun w__86 : mword 32 =>
   write_reg CP0HWREna_ref w__86 >>
   (undefined_bitvector 64) >>= fun w__87 : mword 64 =>
   write_reg CP0UserLocal_ref w__87 >>
   (undefined_bitvector 3) >>= fun w__88 : mword 3 =>
   write_reg CP0ConfigK0_ref w__88 >>
   (undefined_StatusReg tt) >>= fun w__89 : StatusReg =>
   write_reg CP0Status_ref w__89 >>
   (undefined_bitvector 1) >>= fun w__90 : mword 1 =>
   write_reg NextInBranchDelay_ref w__90 >>
   (undefined_bitvector 1) >>= fun w__91 : mword 1 =>
   write_reg InBranchDelay_ref w__91 >>
   (undefined_bitvector 1) >>= fun w__92 : mword 1 =>
   write_reg BranchPending_ref w__92 >>
   (undefined_bitvector 64) >>= fun w__93 : mword 64 =>
   write_reg DelayedPC_ref w__93 >>
   (undefined_bitvector 64) >>= fun w__94 : mword 64 =>
   write_reg HI_ref w__94 >>
   (undefined_bitvector 64) >>= fun w__95 : mword 64 =>
   write_reg LO_ref w__95 >>
   (undefined_bitvector 64) >>= fun w__96 : mword 64 =>
   (undefined_vector 32 w__96) >>= fun w__97 : vec (mword 64) 32 =>
   write_reg GPR_ref w__97 >>
   (undefined_bitvector 8) >>= fun w__98 : mword 8 =>
   write_reg UART_WDATA_ref w__98 >>
   (undefined_bitvector 1) >>= fun w__99 : mword 1 =>
   write_reg UART_WRITTEN_ref w__99 >>
   (undefined_bitvector 8) >>= fun w__100 : mword 8 =>
   write_reg UART_RDATA_ref w__100 >>
   (undefined_bitvector 1) >>= fun w__101 : mword 1 =>
   write_reg UART_RVALID_ref w__101 >>
   (undefined_Capability tt) >>= fun w__102 : Capability =>
   write_reg PCC_ref w__102 >>
   (undefined_Capability tt) >>= fun w__103 : Capability =>
   write_reg NextPCC_ref w__103 >>
   (undefined_Capability tt) >>= fun w__104 : Capability =>
   write_reg DelayedPCC_ref w__104 >>
   (undefined_Capability tt) >>= fun w__105 : Capability =>
   write_reg DDC_ref w__105 >>
   (undefined_Capability tt) >>= fun w__106 : Capability =>
   write_reg C01_ref w__106 >>
   (undefined_Capability tt) >>= fun w__107 : Capability =>
   write_reg C02_ref w__107 >>
   (undefined_Capability tt) >>= fun w__108 : Capability =>
   write_reg C03_ref w__108 >>
   (undefined_Capability tt) >>= fun w__109 : Capability =>
   write_reg C04_ref w__109 >>
   (undefined_Capability tt) >>= fun w__110 : Capability =>
   write_reg C05_ref w__110 >>
   (undefined_Capability tt) >>= fun w__111 : Capability =>
   write_reg C06_ref w__111 >>
   (undefined_Capability tt) >>= fun w__112 : Capability =>
   write_reg C07_ref w__112 >>
   (undefined_Capability tt) >>= fun w__113 : Capability =>
   write_reg C08_ref w__113 >>
   (undefined_Capability tt) >>= fun w__114 : Capability =>
   write_reg C09_ref w__114 >>
   (undefined_Capability tt) >>= fun w__115 : Capability =>
   write_reg C10_ref w__115 >>
   (undefined_Capability tt) >>= fun w__116 : Capability =>
   write_reg C11_ref w__116 >>
   (undefined_Capability tt) >>= fun w__117 : Capability =>
   write_reg C12_ref w__117 >>
   (undefined_Capability tt) >>= fun w__118 : Capability =>
   write_reg C13_ref w__118 >>
   (undefined_Capability tt) >>= fun w__119 : Capability =>
   write_reg C14_ref w__119 >>
   (undefined_Capability tt) >>= fun w__120 : Capability =>
   write_reg C15_ref w__120 >>
   (undefined_Capability tt) >>= fun w__121 : Capability =>
   write_reg C16_ref w__121 >>
   (undefined_Capability tt) >>= fun w__122 : Capability =>
   write_reg C17_ref w__122 >>
   (undefined_Capability tt) >>= fun w__123 : Capability =>
   write_reg C18_ref w__123 >>
   (undefined_Capability tt) >>= fun w__124 : Capability =>
   write_reg C19_ref w__124 >>
   (undefined_Capability tt) >>= fun w__125 : Capability =>
   write_reg C20_ref w__125 >>
   (undefined_Capability tt) >>= fun w__126 : Capability =>
   write_reg C21_ref w__126 >>
   (undefined_Capability tt) >>= fun w__127 : Capability =>
   write_reg C22_ref w__127 >>
   (undefined_Capability tt) >>= fun w__128 : Capability =>
   write_reg C23_ref w__128 >>
   (undefined_Capability tt) >>= fun w__129 : Capability =>
   write_reg C24_ref w__129 >>
   (undefined_Capability tt) >>= fun w__130 : Capability =>
   write_reg C25_ref w__130 >>
   (undefined_Capability tt) >>= fun w__131 : Capability =>
   write_reg C26_ref w__131 >>
   (undefined_Capability tt) >>= fun w__132 : Capability =>
   write_reg C27_ref w__132 >>
   (undefined_Capability tt) >>= fun w__133 : Capability =>
   write_reg C28_ref w__133 >>
   (undefined_Capability tt) >>= fun w__134 : Capability =>
   write_reg C29_ref w__134 >>
   (undefined_Capability tt) >>= fun w__135 : Capability =>
   write_reg C30_ref w__135 >>
   (undefined_Capability tt) >>= fun w__136 : Capability =>
   write_reg C31_ref w__136 >>
   (undefined_Capability tt) >>= fun w__137 : Capability =>
   write_reg CULR_ref w__137 >>
   (undefined_Capability tt) >>= fun w__138 : Capability =>
   write_reg CPLR_ref w__138 >>
   (undefined_Capability tt) >>= fun w__139 : Capability =>
   write_reg KR1C_ref w__139 >>
   (undefined_Capability tt) >>= fun w__140 : Capability =>
   write_reg KR2C_ref w__140 >>
   (undefined_Capability tt) >>= fun w__141 : Capability =>
   write_reg KCC_ref w__141 >>
   (undefined_Capability tt) >>= fun w__142 : Capability =>
   write_reg KDC_ref w__142 >>
   (undefined_Capability tt) >>= fun w__143 : Capability =>
   write_reg EPCC_ref w__143 >>
   (undefined_Capability tt) >>= fun w__144 : Capability =>
   write_reg ErrorEPCC_ref w__144 >>
   (undefined_CapCauseReg tt) >>= fun w__145 : CapCauseReg =>
   write_reg CapCause_ref w__145 >>
   (undefined_bitvector 64) >>= fun w__146 : mword 64 => write_reg CID_ref w__146  : M (unit).

Definition initial_CauseReg : CauseReg :=
{| CauseReg_CauseReg_chunk_0 := (Ox"00000000"  : mword 32) |}.
Hint Unfold initial_CauseReg : sail.
Definition initial_TLBEntryLoReg : TLBEntryLoReg :=
{| TLBEntryLoReg_TLBEntryLoReg_chunk_0 := (Ox"0000000000000000"  : mword 64) |}.
Hint Unfold initial_TLBEntryLoReg : sail.
Definition initial_TLBEntryHiReg : TLBEntryHiReg :=
{| TLBEntryHiReg_TLBEntryHiReg_chunk_0 := (Ox"0000000000000000"  : mword 64) |}.
Hint Unfold initial_TLBEntryHiReg : sail.
Definition initial_ContextReg : ContextReg :=
{| ContextReg_ContextReg_chunk_0 := (Ox"0000000000000000"  : mword 64) |}.
Hint Unfold initial_ContextReg : sail.
Definition initial_XContextReg : XContextReg :=
{| XContextReg_XContextReg_chunk_0 := (Ox"0000000000000000"  : mword 64) |}.
Hint Unfold initial_XContextReg : sail.
Definition initial_TLBEntry : TLBEntry :=
{| TLBEntry_TLBEntry_chunk_1 :=
     ('b"0000000000000000000000000000000000000000000000000000000"
      : mword 55); 
   TLBEntry_TLBEntry_chunk_0 := (Ox"0000000000000000"  : mword 64) |}.
Hint Unfold initial_TLBEntry : sail.
Definition initial_StatusReg : StatusReg :=
{| StatusReg_StatusReg_chunk_0 := (Ox"00000000"  : mword 32) |}.
Hint Unfold initial_StatusReg : sail.
Definition initial_Capability : Capability :=
{| Capability_tag := false; 
   Capability_padding := (Ox"00"  : mword 8); 
   Capability_otype := (Ox"000000"  : mword 24); 
   Capability_uperms := (Ox"0000"  : mword 16); 
   Capability_perm_reserved12_14 := ('b"000"  : mword 3); 
   Capability_permit_set_CID := false; 
   Capability_access_system_regs := false; 
   Capability_permit_unseal := false; 
   Capability_permit_ccall := false; 
   Capability_permit_seal := false; 
   Capability_permit_store_local_cap := false; 
   Capability_permit_store_cap := false; 
   Capability_permit_load_cap := false; 
   Capability_permit_store := false; 
   Capability_permit_load := false; 
   Capability_permit_execute := false; 
   Capability_global := false; 
   Capability_sealed := false; 
   Capability_address := (Ox"0000000000000000"  : mword 64); 
   Capability_base := (Ox"0000000000000000"  : mword 64); 
   Capability_length := (Ox"0000000000000000"  : mword 64) |}.
Hint Unfold initial_Capability : sail.
Definition initial_CapCauseReg : CapCauseReg :=
{| CapCauseReg_CapCauseReg_chunk_0 := (Ox"0000"  : mword 16) |}.
Hint Unfold initial_CapCauseReg : sail.
Definition initial_regstate : regstate :=
{| CID := (Ox"0000000000000000"  : mword 64); 
   CapCause := initial_CapCauseReg; 
   ErrorEPCC := initial_Capability; 
   EPCC := initial_Capability; 
   KDC := initial_Capability; 
   KCC := initial_Capability; 
   KR2C := initial_Capability; 
   KR1C := initial_Capability; 
   CPLR := initial_Capability; 
   CULR := initial_Capability; 
   C31 := initial_Capability; 
   C30 := initial_Capability; 
   C29 := initial_Capability; 
   C28 := initial_Capability; 
   C27 := initial_Capability; 
   C26 := initial_Capability; 
   C25 := initial_Capability; 
   C24 := initial_Capability; 
   C23 := initial_Capability; 
   C22 := initial_Capability; 
   C21 := initial_Capability; 
   C20 := initial_Capability; 
   C19 := initial_Capability; 
   C18 := initial_Capability; 
   C17 := initial_Capability; 
   C16 := initial_Capability; 
   C15 := initial_Capability; 
   C14 := initial_Capability; 
   C13 := initial_Capability; 
   C12 := initial_Capability; 
   C11 := initial_Capability; 
   C10 := initial_Capability; 
   C09 := initial_Capability; 
   C08 := initial_Capability; 
   C07 := initial_Capability; 
   C06 := initial_Capability; 
   C05 := initial_Capability; 
   C04 := initial_Capability; 
   C03 := initial_Capability; 
   C02 := initial_Capability; 
   C01 := initial_Capability; 
   DDC := initial_Capability; 
   DelayedPCC := initial_Capability; 
   NextPCC := initial_Capability; 
   PCC := initial_Capability; 
   UART_RVALID := ('b"0"  : mword 1); 
   UART_RDATA := (Ox"00"  : mword 8); 
   UART_WRITTEN := ('b"0"  : mword 1); 
   UART_WDATA := (Ox"00"  : mword 8); 
   GPR :=
     (vec_of_list_len [Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64;Ox"0000000000000000"  : mword 64;
                       Ox"0000000000000000"
                        : mword 64;Ox"0000000000000000"  : mword 64]); 
   LO := (Ox"0000000000000000"  : mword 64); 
   HI := (Ox"0000000000000000"  : mword 64); 
   DelayedPC := (Ox"0000000000000000"  : mword 64); 
   BranchPending := ('b"0"  : mword 1); 
   InBranchDelay := ('b"0"  : mword 1); 
   NextInBranchDelay := ('b"0"  : mword 1); 
   CP0Status := initial_StatusReg; 
   CP0ConfigK0 := ('b"000"  : mword 3); 
   CP0UserLocal := (Ox"0000000000000000"  : mword 64); 
   CP0HWREna := (Ox"00000000"  : mword 32); 
   CP0Count := (Ox"00000000"  : mword 32); 
   CP0BadInstrP := (Ox"00000000"  : mword 32); 
   CP0BadInstr := (Ox"00000000"  : mword 32); 
   LastInstrBits := (Ox"00000000"  : mword 32); 
   CurrentInstrBits := (Ox"00000000"  : mword 32); 
   CP0BadVAddr := (Ox"0000000000000000"  : mword 64); 
   CP0LLAddr := (Ox"0000000000000000"  : mword 64); 
   CP0LLBit := ('b"0"  : mword 1); 
   CP0Cause := initial_CauseReg; 
   CP0Compare := (Ox"00000000"  : mword 32); 
   TLBEntry63 := initial_TLBEntry; 
   TLBEntry62 := initial_TLBEntry; 
   TLBEntry61 := initial_TLBEntry; 
   TLBEntry60 := initial_TLBEntry; 
   TLBEntry59 := initial_TLBEntry; 
   TLBEntry58 := initial_TLBEntry; 
   TLBEntry57 := initial_TLBEntry; 
   TLBEntry56 := initial_TLBEntry; 
   TLBEntry55 := initial_TLBEntry; 
   TLBEntry54 := initial_TLBEntry; 
   TLBEntry53 := initial_TLBEntry; 
   TLBEntry52 := initial_TLBEntry; 
   TLBEntry51 := initial_TLBEntry; 
   TLBEntry50 := initial_TLBEntry; 
   TLBEntry49 := initial_TLBEntry; 
   TLBEntry48 := initial_TLBEntry; 
   TLBEntry47 := initial_TLBEntry; 
   TLBEntry46 := initial_TLBEntry; 
   TLBEntry45 := initial_TLBEntry; 
   TLBEntry44 := initial_TLBEntry; 
   TLBEntry43 := initial_TLBEntry; 
   TLBEntry42 := initial_TLBEntry; 
   TLBEntry41 := initial_TLBEntry; 
   TLBEntry40 := initial_TLBEntry; 
   TLBEntry39 := initial_TLBEntry; 
   TLBEntry38 := initial_TLBEntry; 
   TLBEntry37 := initial_TLBEntry; 
   TLBEntry36 := initial_TLBEntry; 
   TLBEntry35 := initial_TLBEntry; 
   TLBEntry34 := initial_TLBEntry; 
   TLBEntry33 := initial_TLBEntry; 
   TLBEntry32 := initial_TLBEntry; 
   TLBEntry31 := initial_TLBEntry; 
   TLBEntry30 := initial_TLBEntry; 
   TLBEntry29 := initial_TLBEntry; 
   TLBEntry28 := initial_TLBEntry; 
   TLBEntry27 := initial_TLBEntry; 
   TLBEntry26 := initial_TLBEntry; 
   TLBEntry25 := initial_TLBEntry; 
   TLBEntry24 := initial_TLBEntry; 
   TLBEntry23 := initial_TLBEntry; 
   TLBEntry22 := initial_TLBEntry; 
   TLBEntry21 := initial_TLBEntry; 
   TLBEntry20 := initial_TLBEntry; 
   TLBEntry19 := initial_TLBEntry; 
   TLBEntry18 := initial_TLBEntry; 
   TLBEntry17 := initial_TLBEntry; 
   TLBEntry16 := initial_TLBEntry; 
   TLBEntry15 := initial_TLBEntry; 
   TLBEntry14 := initial_TLBEntry; 
   TLBEntry13 := initial_TLBEntry; 
   TLBEntry12 := initial_TLBEntry; 
   TLBEntry11 := initial_TLBEntry; 
   TLBEntry10 := initial_TLBEntry; 
   TLBEntry09 := initial_TLBEntry; 
   TLBEntry08 := initial_TLBEntry; 
   TLBEntry07 := initial_TLBEntry; 
   TLBEntry06 := initial_TLBEntry; 
   TLBEntry05 := initial_TLBEntry; 
   TLBEntry04 := initial_TLBEntry; 
   TLBEntry03 := initial_TLBEntry; 
   TLBEntry02 := initial_TLBEntry; 
   TLBEntry01 := initial_TLBEntry; 
   TLBEntry00 := initial_TLBEntry; 
   TLBXContext := initial_XContextReg; 
   TLBEntryHi := initial_TLBEntryHiReg; 
   TLBWired := ('b"000000"  : mword 6); 
   TLBPageMask := (Ox"0000"  : mword 16); 
   TLBContext := initial_ContextReg; 
   TLBEntryLo1 := initial_TLBEntryLoReg; 
   TLBEntryLo0 := initial_TLBEntryLoReg; 
   TLBRandom := ('b"000000"  : mword 6); 
   TLBIndex := ('b"000000"  : mword 6); 
   TLBProbe := ('b"0"  : mword 1); 
   NextPC := (Ox"0000000000000000"  : mword 64); 
   PC := (Ox"0000000000000000"  : mword 64) |}.
Hint Unfold initial_regstate : sail.


