chapter \<open>Generated by Lem from \<open>either.lem\<close>.\<close>

theory "Lem_either" 

imports
  Main
  "Lem_bool"
  "Lem_basic_classes"
  "Lem_list"
  "Lem_tuple"

begin 

 

\<comment> \<open>\<open>open import Bool Basic_classes List Tuple\<close>\<close>
\<comment> \<open>\<open>open import {hol} `sumTheory`\<close>\<close>
\<comment> \<open>\<open>open import {ocaml} `Either`\<close>\<close>

\<comment> \<open>\<open>type either 'a 'b
  = Left  of 'a
  | Right of 'b\<close>\<close>


\<comment> \<open>\<open> -------------------------------------------------------------------------- \<close>\<close>
\<comment> \<open>\<open> Equality.                                                                  \<close>\<close>
\<comment> \<open>\<open> -------------------------------------------------------------------------- \<close>\<close>

\<comment> \<open>\<open>val eitherEqual : forall 'a 'b. Eq 'a, Eq 'b => (either 'a 'b) -> (either 'a 'b) -> bool\<close>\<close>
\<comment> \<open>\<open>val eitherEqualBy : forall 'a 'b. ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> (either 'a 'b) -> (either 'a 'b) -> bool\<close>\<close>

definition eitherEqualBy  :: \<open>('a \<Rightarrow> 'a \<Rightarrow> bool)\<Rightarrow>('b \<Rightarrow> 'b \<Rightarrow> bool)\<Rightarrow>('a,'b)sum \<Rightarrow>('a,'b)sum \<Rightarrow> bool \<close>  where 
     \<open> eitherEqualBy eql eqr (left:: ('a, 'b) sum) (right:: ('a, 'b) sum) = (
  (case  (left, right) of
      (Inl l, Inl l') => eql l l'
    | (Inr r, Inr r') => eqr r r'
    | _ => False
  ))\<close> 
  for  eql  :: " 'a \<Rightarrow> 'a \<Rightarrow> bool " 
  and  eqr  :: " 'b \<Rightarrow> 'b \<Rightarrow> bool " 
  and  left  :: "('a,'b)sum " 
  and  right  :: "('a,'b)sum "

\<comment> \<open>\<open>let eitherEqual=  eitherEqualBy (=) (=)\<close>\<close>

fun either_setElemCompare  :: \<open>('d \<Rightarrow> 'b \<Rightarrow> ordering)\<Rightarrow>('c \<Rightarrow> 'a \<Rightarrow> ordering)\<Rightarrow>('d,'c)sum \<Rightarrow>('b,'a)sum \<Rightarrow> ordering \<close>  where 
     \<open> either_setElemCompare cmpa cmpb (Inl x') (Inl y') = ( cmpa x' y' )\<close> 
  for  cmpa  :: " 'd \<Rightarrow> 'b \<Rightarrow> ordering " 
  and  cmpb  :: " 'c \<Rightarrow> 'a \<Rightarrow> ordering " 
  and  x'  :: " 'd " 
  and  y'  :: " 'b "
|\<open> either_setElemCompare cmpa cmpb (Inr x') (Inr y') = ( cmpb x' y' )\<close> 
  for  cmpa  :: " 'd \<Rightarrow> 'b \<Rightarrow> ordering " 
  and  cmpb  :: " 'c \<Rightarrow> 'a \<Rightarrow> ordering " 
  and  x'  :: " 'c " 
  and  y'  :: " 'a "
|\<open> either_setElemCompare cmpa cmpb (Inl _) (Inr _) = ( LT )\<close> 
  for  cmpa  :: " 'd \<Rightarrow> 'b \<Rightarrow> ordering " 
  and  cmpb  :: " 'c \<Rightarrow> 'a \<Rightarrow> ordering "
|\<open> either_setElemCompare cmpa cmpb (Inr _) (Inl _) = ( GT )\<close> 
  for  cmpa  :: " 'd \<Rightarrow> 'b \<Rightarrow> ordering " 
  and  cmpb  :: " 'c \<Rightarrow> 'a \<Rightarrow> ordering "

                           

\<comment> \<open>\<open> -------------------------------------------------------------------------- \<close>\<close>
\<comment> \<open>\<open> Utility functions.                                                         \<close>\<close>
\<comment> \<open>\<open> -------------------------------------------------------------------------- \<close>\<close>

\<comment> \<open>\<open>val isLeft : forall 'a 'b. either 'a 'b -> bool\<close>\<close>

\<comment> \<open>\<open>val isRight : forall 'a 'b. either 'a 'b -> bool\<close>\<close>


\<comment> \<open>\<open>val either : forall 'a 'b 'c. ('a -> 'c) -> ('b -> 'c) -> either 'a 'b -> 'c\<close>\<close>
\<comment> \<open>\<open>let either fa fb x=  match x with
  | Left a -> fa a
  | Right b -> fb b
end\<close>\<close>


\<comment> \<open>\<open>val partitionEither : forall 'a 'b. list (either 'a 'b) -> (list 'a * list 'b)\<close>\<close>
\<comment> \<open>\<open>let rec partitionEither l=  match l with
  | [] -> ([], [])
  | x :: xs -> begin
      let (ll, rl) = partitionEither xs in
      match x with 
        | Left l -> (l::ll, rl)
        | Right r -> (ll, r::rl)
      end
    end
end\<close>\<close>


\<comment> \<open>\<open>val lefts : forall 'a 'b. list (either 'a 'b) -> list 'a\<close>\<close>


\<comment> \<open>\<open>val rights : forall 'a 'b. list (either 'a 'b) -> list 'b\<close>\<close>


end
