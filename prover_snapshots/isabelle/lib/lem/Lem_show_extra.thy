chapter \<open>Generated by Lem from \<open>show_extra.lem\<close>.\<close>

theory "Lem_show_extra" 

imports
  Main
  "Lem_string"
  "Lem_maybe"
  "Lem_num"
  "Lem_basic_classes"
  "Lem_set"
  "Lem_relation"
  "Lem_show"
  "Lem_set_extra"
  "Lem_string_extra"

begin 



\<comment> \<open>\<open>open import String Maybe Num Basic_classes Set Relation Show\<close>\<close> 
\<comment> \<open>\<open>import Set_extra String_extra\<close>\<close>

definition instance_Show_Show_nat_dict  :: \<open>(nat)Show_class \<close>  where 
     \<open> instance_Show_Show_nat_dict = ((|

  show_method = Lem_string_extra.stringFromNat |) )\<close>


definition instance_Show_Show_Num_natural_dict  :: \<open>(nat)Show_class \<close>  where 
     \<open> instance_Show_Show_Num_natural_dict = ((|

  show_method = Lem_string_extra.stringFromNatural |) )\<close>


definition instance_Show_Show_Num_int_dict  :: \<open>(int)Show_class \<close>  where 
     \<open> instance_Show_Show_Num_int_dict = ((|

  show_method = Lem_string_extra.stringFromInt |) )\<close>


definition instance_Show_Show_Num_integer_dict  :: \<open>(int)Show_class \<close>  where 
     \<open> instance_Show_Show_Num_integer_dict = ((|

  show_method = Lem_string_extra.stringFromInteger |) )\<close>


definition stringFromSet  :: \<open>('a \<Rightarrow> string)\<Rightarrow> 'a set \<Rightarrow> string \<close>  where 
     \<open> stringFromSet showX xs = (
  (''{'') @ (Lem_show.stringFromListAux showX (list_of_set xs) @ (''}'')))\<close> 
  for  showX  :: " 'a \<Rightarrow> string " 
  and  xs  :: " 'a set "


\<comment> \<open>\<open> Abbreviates the representation if the relation is transitive. \<close>\<close>
definition stringFromRelation  :: \<open>('a*'a \<Rightarrow> string)\<Rightarrow>('a*'a)set \<Rightarrow> string \<close>  where 
     \<open> stringFromRelation showX rel = (
  if trans rel then
    (let pruned_rel = (LemExtraDefs.without_trans_edges rel) in
    if ((\<forall> e \<in> rel.  (e \<in> pruned_rel))) then
      \<comment> \<open>\<open> The relations are the same (there are no transitive edges),
         so we can just as well print the original one. \<close>\<close>
      stringFromSet showX rel
    else
      (''trancl of '') @ stringFromSet showX pruned_rel)
  else
    stringFromSet showX rel )\<close> 
  for  showX  :: " 'a*'a \<Rightarrow> string " 
  and  rel  :: "('a*'a)set "


definition instance_Show_Show_set_dict  :: \<open> 'a Show_class \<Rightarrow>('a set)Show_class \<close>  where 
     \<open> instance_Show_Show_set_dict dict_Show_Show_a = ((|

  show_method = ((\<lambda> xs. stringFromSet 
  (show_method   dict_Show_Show_a) xs))|) )\<close> 
  for  dict_Show_Show_a  :: " 'a Show_class "

end
