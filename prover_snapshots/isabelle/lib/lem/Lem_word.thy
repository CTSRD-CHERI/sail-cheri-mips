chapter \<open>Generated by Lem from \<open>word.lem\<close>.\<close>

theory "Lem_word" 

imports
  Main
  "Lem_bool"
  "Lem_maybe"
  "Lem_num"
  "Lem_basic_classes"
  "Lem_list"
  "HOL-Word.Word"

begin 



\<comment> \<open>\<open>open import Bool Maybe Num Basic_classes List\<close>\<close>

\<comment> \<open>\<open>open import {isabelle} `HOL-Word.Word`\<close>\<close>
\<comment> \<open>\<open>open import {hol} `wordsTheory` `wordsLib`\<close>\<close>


\<comment> \<open>\<open> ========================================================================== \<close>\<close>
\<comment> \<open>\<open> Define general purpose word, i.e. sequences of bits of arbitrary length    \<close>\<close>
\<comment> \<open>\<open> ========================================================================== \<close>\<close>

datatype bitSequence = BitSeq " 
    nat option  " " \<comment> \<open>\<open> length of the sequence, Nothing means infinite length \<close>\<close>
   bool " " bool       \<comment> \<open>\<open> sign of the word, used to fill up after concrete value is exhausted \<close>\<close>
   list "    \<comment> \<open>\<open> the initial part of the sequence, least significant bit first \<close>\<close>

\<comment> \<open>\<open>val bitSeqEq : bitSequence -> bitSequence -> bool\<close>\<close>

\<comment> \<open>\<open>val boolListFrombitSeq : nat -> bitSequence -> list bool\<close>\<close>

fun  boolListFrombitSeqAux  :: \<open> nat \<Rightarrow> 'a \<Rightarrow> 'a list \<Rightarrow> 'a list \<close>  where 
     \<open> boolListFrombitSeqAux n s bl = (
  if n =( 0 :: nat) then [] else
  (case  bl of
      []       => List.replicate n s
    | b # bl' => b # (boolListFrombitSeqAux (n-( 1 :: nat)) s bl')
  ))\<close> 
  for  n  :: " nat " 
  and  s  :: " 'a " 
  and  bl  :: " 'a list "


fun boolListFrombitSeq  :: \<open> nat \<Rightarrow> bitSequence \<Rightarrow>(bool)list \<close>  where 
     \<open> boolListFrombitSeq n (BitSeq _ s bl) = ( boolListFrombitSeqAux n s bl )\<close> 
  for  n  :: " nat " 
  and  bl  :: "(bool)list " 
  and  s  :: " bool "



\<comment> \<open>\<open>val bitSeqFromBoolList : list bool -> maybe bitSequence\<close>\<close>
definition bitSeqFromBoolList  :: \<open>(bool)list \<Rightarrow>(bitSequence)option \<close>  where 
     \<open> bitSeqFromBoolList bl = (
  (case  dest_init bl of
      None => None
    | Some (bl', s) => Some (BitSeq (Some (List.length bl)) s bl')
  ))\<close> 
  for  bl  :: "(bool)list "



\<comment> \<open>\<open> cleans up the representation of a bitSequence without changing its semantics \<close>\<close>
\<comment> \<open>\<open>val cleanBitSeq : bitSequence -> bitSequence\<close>\<close>
fun cleanBitSeq  :: \<open> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> cleanBitSeq (BitSeq len s bl) = ( (case  len of
    None => (BitSeq len s (List.rev (dropWhile ((\<longleftrightarrow>) s) (List.rev bl))))
  | Some n  => (BitSeq len s (List.rev (dropWhile ((\<longleftrightarrow>) s) (List.rev (List.take (n-( 1 :: nat)) bl)))))
))\<close> 
  for  bl  :: "(bool)list " 
  and  len  :: "(nat)option " 
  and  s  :: " bool "



\<comment> \<open>\<open>val bitSeqTestBit : bitSequence -> nat -> maybe bool\<close>\<close>
fun bitSeqTestBit  :: \<open> bitSequence \<Rightarrow> nat \<Rightarrow>(bool)option \<close>  where 
     \<open> bitSeqTestBit (BitSeq None s bl) pos = ( if pos < List.length bl then index bl pos else Some s )\<close> 
  for  bl  :: "(bool)list " 
  and  s  :: " bool " 
  and  pos  :: " nat "
|\<open> bitSeqTestBit (BitSeq(Some l) s bl) pos = ( if (pos \<ge> l) then None else
                if ((pos = (l -( 1 :: nat))) \<or> (pos \<ge> List.length bl)) then Some s else
                index bl pos )\<close> 
  for  bl  :: "(bool)list " 
  and  s  :: " bool " 
  and  l  :: " nat " 
  and  pos  :: " nat "


\<comment> \<open>\<open>val bitSeqSetBit : bitSequence -> nat -> bool -> bitSequence\<close>\<close>
fun bitSeqSetBit  :: \<open> bitSequence \<Rightarrow> nat \<Rightarrow> bool \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqSetBit (BitSeq len s bl) pos v = (
  (let bl' = (if (pos < List.length bl) then bl else bl @ List.replicate pos s) in
  (let bl'' = (List.list_update bl' pos v) in
  (let bs' = (BitSeq len s bl'') in
  cleanBitSeq bs'))))\<close> 
  for  bl  :: "(bool)list " 
  and  len  :: "(nat)option " 
  and  s  :: " bool " 
  and  pos  :: " nat " 
  and  v  :: " bool "



\<comment> \<open>\<open>val resizeBitSeq : maybe nat -> bitSequence -> bitSequence\<close>\<close>
definition resizeBitSeq  :: \<open>(nat)option \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> resizeBitSeq new_len bs = ( 
  (case  cleanBitSeq bs of
      (BitSeq len s bl) =>
  (let shorten_opt = ((case  (new_len, len) of
                            (None, _) => None
                        | (Some l1, None) => Some l1
                        | (Some l1, Some l2) =>
                      if (l1 < l2) then Some l1 else None
                      )) in
  (case  shorten_opt of
        None => BitSeq new_len s bl
    | Some l1 => (
                 (let bl' = (List.take l1 (bl @ [s])) in
                 (case  dest_init bl' of
                       None => (BitSeq len s bl) \<comment> \<open>\<open> do nothing if size 0 is requested \<close>\<close>
                   | Some (bl'', s') => cleanBitSeq (BitSeq new_len s' bl'')
                 )))
  ))
  ) )\<close> 
  for  new_len  :: "(nat)option " 
  and  bs  :: " bitSequence "
 

\<comment> \<open>\<open>val bitSeqNot : bitSequence -> bitSequence\<close>\<close>
fun bitSeqNot  :: \<open> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqNot (BitSeq len s bl) = ( BitSeq len (\<not> s) (List.map ((\<lambda> x. \<not> x)) bl))\<close> 
  for  bl  :: "(bool)list " 
  and  len  :: "(nat)option " 
  and  s  :: " bool "


\<comment> \<open>\<open>val bitSeqBinop : (bool -> bool -> bool) -> bitSequence -> bitSequence -> bitSequence\<close>\<close>

\<comment> \<open>\<open>val bitSeqBinopAux : (bool -> bool -> bool) -> bool -> list bool -> bool -> list bool -> list bool\<close>\<close>
fun  bitSeqBinopAux  :: \<open>(bool \<Rightarrow> bool \<Rightarrow> bool)\<Rightarrow> bool \<Rightarrow>(bool)list \<Rightarrow> bool \<Rightarrow>(bool)list \<Rightarrow>(bool)list \<close>  where 
     \<open> bitSeqBinopAux binop s1 ([]) s2 ([]) = ( [])\<close> 
  for  binop  :: " bool \<Rightarrow> bool \<Rightarrow> bool " 
  and  s1  :: " bool " 
  and  s2  :: " bool "
|\<open> bitSeqBinopAux binop s1 (b1 # bl1') s2 ([]) = ( (binop b1 s2) # bitSeqBinopAux binop s1 bl1' s2 [])\<close> 
  for  binop  :: " bool \<Rightarrow> bool \<Rightarrow> bool " 
  and  s1  :: " bool " 
  and  bl1'  :: "(bool)list " 
  and  b1  :: " bool " 
  and  s2  :: " bool "
|\<open> bitSeqBinopAux binop s1 ([]) s2 (b2 # bl2') = ( (binop s1 b2) # bitSeqBinopAux binop s1 []   s2 bl2' )\<close> 
  for  binop  :: " bool \<Rightarrow> bool \<Rightarrow> bool " 
  and  s1  :: " bool " 
  and  s2  :: " bool " 
  and  bl2'  :: "(bool)list " 
  and  b2  :: " bool "
|\<open> bitSeqBinopAux binop s1 (b1 # bl1') s2 (b2 # bl2') = ( (binop b1 b2) # bitSeqBinopAux binop s1 bl1' s2 bl2' )\<close> 
  for  binop  :: " bool \<Rightarrow> bool \<Rightarrow> bool " 
  and  s1  :: " bool " 
  and  bl1'  :: "(bool)list " 
  and  b1  :: " bool " 
  and  s2  :: " bool " 
  and  bl2'  :: "(bool)list " 
  and  b2  :: " bool "


definition bitSeqBinop  :: \<open>(bool \<Rightarrow> bool \<Rightarrow> bool)\<Rightarrow> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqBinop binop bs1 bs2 = ( ( 
  (case  cleanBitSeq bs1 of
      (BitSeq len1 s1 bl1) =>
  (case  cleanBitSeq bs2 of
      (BitSeq len2 s2 bl2) =>
  (let len = ((case  (len1, len2) of
                    (Some l1, Some l2) => Some (max l1 l2)
                | _ => None
              )) in
  (let s = (binop s1 s2) in
  (let bl = (bitSeqBinopAux binop s1 bl1 s2 bl2) in
  cleanBitSeq (BitSeq len s bl))))
  )
  )
))\<close> 
  for  binop  :: " bool \<Rightarrow> bool \<Rightarrow> bool " 
  and  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


definition bitSeqAnd  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqAnd = ( bitSeqBinop (\<and>))\<close>

definition bitSeqOr  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqOr = ( bitSeqBinop (\<or>))\<close>

definition bitSeqXor  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqXor = ( bitSeqBinop ((\<lambda> b1 b2. \<not> (b1 \<longleftrightarrow> b2))))\<close>


\<comment> \<open>\<open>val bitSeqShiftLeft : bitSequence -> nat -> bitSequence\<close>\<close>
fun bitSeqShiftLeft  :: \<open> bitSequence \<Rightarrow> nat \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqShiftLeft (BitSeq len s bl) n = ( cleanBitSeq (BitSeq len s (List.replicate n False @ bl)))\<close> 
  for  bl  :: "(bool)list " 
  and  len  :: "(nat)option " 
  and  s  :: " bool " 
  and  n  :: " nat "


\<comment> \<open>\<open>val bitSeqArithmeticShiftRight : bitSequence -> nat -> bitSequence\<close>\<close>
definition bitSeqArithmeticShiftRight  :: \<open> bitSequence \<Rightarrow> nat \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqArithmeticShiftRight bs n = ( 
  (case  cleanBitSeq bs of
      (BitSeq len s bl) =>
  cleanBitSeq (BitSeq len s (List.drop n bl))
  ) )\<close> 
  for  bs  :: " bitSequence " 
  and  n  :: " nat "


\<comment> \<open>\<open>val bitSeqLogicalShiftRight : bitSequence -> nat -> bitSequence\<close>\<close>
definition bitSeqLogicalShiftRight  :: \<open> bitSequence \<Rightarrow> nat \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqLogicalShiftRight bs n = ( 
  if (n =( 0 :: nat)) then cleanBitSeq bs else  
  (case  cleanBitSeq bs of
      (BitSeq len s bl) =>
  (case  len of
        None => cleanBitSeq (BitSeq len s (List.drop n bl))
    | Some l => cleanBitSeq
                  (BitSeq len False ((List.drop n bl) @ List.replicate l s))
  )
  ) )\<close> 
  for  bs  :: " bitSequence " 
  and  n  :: " nat "



\<comment> \<open>\<open> integerFromBoolList sign bl creates an integer from a list of bits
   (least significant bit first) and an explicitly given sign bit.
   It uses two's complement encoding. \<close>\<close>
\<comment> \<open>\<open>val integerFromBoolList : (bool * list bool) -> integer\<close>\<close>

fun  integerFromBoolListAux  :: \<open> int \<Rightarrow>(bool)list \<Rightarrow> int \<close>  where 
     \<open> integerFromBoolListAux (acc1 :: int) (([]) :: bool list) = ( acc1 )\<close> 
  for  acc1  :: " int "
|\<open> integerFromBoolListAux (acc1 :: int) ((True # bl') :: bool list) = ( integerFromBoolListAux ((acc1 *( 2 :: int)) +( 1 :: int)) bl' )\<close> 
  for  acc1  :: " int " 
  and  bl'  :: "(bool)list "
|\<open> integerFromBoolListAux (acc1 :: int) ((False # bl') :: bool list) = ( integerFromBoolListAux (acc1 *( 2 :: int)) bl' )\<close> 
  for  acc1  :: " int " 
  and  bl'  :: "(bool)list "


fun integerFromBoolList  :: \<open> bool*(bool)list \<Rightarrow> int \<close>  where 
     \<open> integerFromBoolList (sign, bl) = ( 
   if sign then 
     - (integerFromBoolListAux(( 0 :: int)) (List.rev (List.map ((\<lambda> x. \<not> x)) bl)) +( 1 :: int))
   else integerFromBoolListAux(( 0 :: int)) (List.rev bl))\<close> 
  for  sign  :: " bool " 
  and  bl  :: "(bool)list "


\<comment> \<open>\<open> [boolListFromInteger i] creates a sign bit and a list of booleans from an integer. The len_opt tells it when to stop.\<close>\<close>
\<comment> \<open>\<open>val boolListFromInteger :    integer -> bool * list bool\<close>\<close>

fun  boolListFromNatural  :: \<open>(bool)list \<Rightarrow> nat \<Rightarrow>(bool)list \<close>  where 
     \<open> boolListFromNatural acc1 (remainder :: nat) = (
 if (remainder >( 0 :: nat)) then 
   (boolListFromNatural (((remainder mod( 2 :: nat)) =( 1 :: nat)) # acc1) 
      (remainder div( 2 :: nat)))
 else
   List.rev acc1 )\<close> 
  for  acc1  :: "(bool)list " 
  and  remainder  :: " nat "


definition boolListFromInteger  :: \<open> int \<Rightarrow> bool*(bool)list \<close>  where 
     \<open> boolListFromInteger (i :: int) = ( 
  if (i <( 0 :: int)) then
    (True, List.map ((\<lambda> x. \<not> x)) (boolListFromNatural [] (nat (abs (- (i +( 1 :: int)))))))
  else
    (False, boolListFromNatural [] (nat (abs i))))\<close> 
  for  i  :: " int "



\<comment> \<open>\<open> [bitSeqFromInteger len_opt i] encodes [i] as a bitsequence with [len_opt] bits. If there are not enough
   bits, truncation happens \<close>\<close>
\<comment> \<open>\<open>val bitSeqFromInteger : maybe nat -> integer -> bitSequence\<close>\<close>
definition bitSeqFromInteger  :: \<open>(nat)option \<Rightarrow> int \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqFromInteger len_opt i = (
  (let (s, bl) = (boolListFromInteger i) in
  resizeBitSeq len_opt (BitSeq None s bl)))\<close> 
  for  len_opt  :: "(nat)option " 
  and  i  :: " int "



\<comment> \<open>\<open>val integerFromBitSeq : bitSequence -> integer\<close>\<close>
definition integerFromBitSeq  :: \<open> bitSequence \<Rightarrow> int \<close>  where 
     \<open> integerFromBitSeq bs = ( 
  (case  cleanBitSeq bs of (BitSeq len s bl) => integerFromBoolList (s, bl) ) )\<close> 
  for  bs  :: " bitSequence "



\<comment> \<open>\<open> Now we can via translation to integers map arithmetic operations to bitSequences \<close>\<close>

\<comment> \<open>\<open>val bitSeqArithUnaryOp : (integer -> integer) -> bitSequence -> bitSequence\<close>\<close>
definition bitSeqArithUnaryOp  :: \<open>(int \<Rightarrow> int)\<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqArithUnaryOp uop bs = ( 
  (case  bs of
      (BitSeq len _ _) =>
  bitSeqFromInteger len (uop (integerFromBitSeq bs))
  ) )\<close> 
  for  uop  :: " int \<Rightarrow> int " 
  and  bs  :: " bitSequence "


\<comment> \<open>\<open>val bitSeqArithBinOp : (integer -> integer -> integer) -> bitSequence -> bitSequence -> bitSequence\<close>\<close>
definition bitSeqArithBinOp  :: \<open>(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqArithBinOp binop bs1 bs2 = ( 
  (case  bs1 of
      (BitSeq len1 _ _) =>
  (case  bs2 of
      (BitSeq len2 _ _) =>
  (let len = ((case  (len1, len2) of
                    (Some l1, Some l2) => Some (max l1 l2)
                | _ => None
              )) in
  bitSeqFromInteger len
    (binop (integerFromBitSeq bs1) (integerFromBitSeq bs2)))
  )
  ) )\<close> 
  for  binop  :: " int \<Rightarrow> int \<Rightarrow> int " 
  and  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


\<comment> \<open>\<open>val bitSeqArithBinTest : forall 'a. (integer -> integer -> 'a) -> bitSequence -> bitSequence -> 'a\<close>\<close>
definition bitSeqArithBinTest  :: \<open>(int \<Rightarrow> int \<Rightarrow> 'a)\<Rightarrow> bitSequence \<Rightarrow> bitSequence \<Rightarrow> 'a \<close>  where 
     \<open> bitSeqArithBinTest binop bs1 bs2 = ( binop (integerFromBitSeq bs1) (integerFromBitSeq bs2))\<close> 
  for  binop  :: " int \<Rightarrow> int \<Rightarrow> 'a " 
  and  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "



\<comment> \<open>\<open> now instantiate the number interface for bit-sequences \<close>\<close>

\<comment> \<open>\<open>val bitSeqFromNumeral : numeral -> bitSequence\<close>\<close>

\<comment> \<open>\<open>val bitSeqLess : bitSequence -> bitSequence -> bool\<close>\<close>
definition bitSeqLess  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bool \<close>  where 
     \<open> bitSeqLess bs1 bs2 = ( bitSeqArithBinTest (<) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


\<comment> \<open>\<open>val bitSeqLessEqual : bitSequence -> bitSequence -> bool\<close>\<close>
definition bitSeqLessEqual  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bool \<close>  where 
     \<open> bitSeqLessEqual bs1 bs2 = ( bitSeqArithBinTest (\<le>) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


\<comment> \<open>\<open>val bitSeqGreater : bitSequence -> bitSequence -> bool\<close>\<close>
definition bitSeqGreater  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bool \<close>  where 
     \<open> bitSeqGreater bs1 bs2 = ( bitSeqArithBinTest (>) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


\<comment> \<open>\<open>val bitSeqGreaterEqual : bitSequence -> bitSequence -> bool\<close>\<close>
definition bitSeqGreaterEqual  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bool \<close>  where 
     \<open> bitSeqGreaterEqual bs1 bs2 = ( bitSeqArithBinTest (\<ge>) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


\<comment> \<open>\<open>val bitSeqCompare : bitSequence -> bitSequence -> ordering\<close>\<close>
definition bitSeqCompare  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> ordering \<close>  where 
     \<open> bitSeqCompare bs1 bs2 = ( bitSeqArithBinTest (genericCompare (<) (=)) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


definition instance_Basic_classes_Ord_Word_bitSequence_dict  :: \<open>(bitSequence)Ord_class \<close>  where 
     \<open> instance_Basic_classes_Ord_Word_bitSequence_dict = ((|

  compare_method = bitSeqCompare,

  isLess_method = bitSeqLess,

  isLessEqual_method = bitSeqLessEqual,

  isGreater_method = bitSeqGreater,

  isGreaterEqual_method = bitSeqGreaterEqual |) )\<close>


\<comment> \<open>\<open> arithmetic negation, don't mix up with bitwise negation \<close>\<close>
\<comment> \<open>\<open>val bitSeqNegate : bitSequence -> bitSequence\<close>\<close> 
definition bitSeqNegate  :: \<open> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqNegate bs = ( bitSeqArithUnaryOp ((\<lambda> i. - i)) bs )\<close> 
  for  bs  :: " bitSequence "


definition instance_Num_NumNegate_Word_bitSequence_dict  :: \<open>(bitSequence)NumNegate_class \<close>  where 
     \<open> instance_Num_NumNegate_Word_bitSequence_dict = ((|

  numNegate_method = bitSeqNegate |) )\<close>



\<comment> \<open>\<open>val bitSeqAdd : bitSequence -> bitSequence -> bitSequence\<close>\<close>
definition bitSeqAdd  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqAdd bs1 bs2 = ( bitSeqArithBinOp (+) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


definition instance_Num_NumAdd_Word_bitSequence_dict  :: \<open>(bitSequence)NumAdd_class \<close>  where 
     \<open> instance_Num_NumAdd_Word_bitSequence_dict = ((|

  numAdd_method = bitSeqAdd |) )\<close>


\<comment> \<open>\<open>val bitSeqMinus : bitSequence -> bitSequence -> bitSequence\<close>\<close>
definition bitSeqMinus  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqMinus bs1 bs2 = ( bitSeqArithBinOp (-) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


definition instance_Num_NumMinus_Word_bitSequence_dict  :: \<open>(bitSequence)NumMinus_class \<close>  where 
     \<open> instance_Num_NumMinus_Word_bitSequence_dict = ((|

  numMinus_method = bitSeqMinus |) )\<close>


\<comment> \<open>\<open>val bitSeqSucc : bitSequence -> bitSequence\<close>\<close>
definition bitSeqSucc  :: \<open> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqSucc bs = ( bitSeqArithUnaryOp ((\<lambda> n. n +( 1 :: int))) bs )\<close> 
  for  bs  :: " bitSequence "


definition instance_Num_NumSucc_Word_bitSequence_dict  :: \<open>(bitSequence)NumSucc_class \<close>  where 
     \<open> instance_Num_NumSucc_Word_bitSequence_dict = ((|

  succ_method = bitSeqSucc |) )\<close>


\<comment> \<open>\<open>val bitSeqPred : bitSequence -> bitSequence\<close>\<close>
definition bitSeqPred  :: \<open> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqPred bs = ( bitSeqArithUnaryOp ((\<lambda> n. n -( 1 :: int))) bs )\<close> 
  for  bs  :: " bitSequence "


definition instance_Num_NumPred_Word_bitSequence_dict  :: \<open>(bitSequence)NumPred_class \<close>  where 
     \<open> instance_Num_NumPred_Word_bitSequence_dict = ((|

  pred_method = bitSeqPred |) )\<close>


\<comment> \<open>\<open>val bitSeqMult : bitSequence -> bitSequence -> bitSequence\<close>\<close>
definition bitSeqMult  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqMult bs1 bs2 = ( bitSeqArithBinOp (*) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


definition instance_Num_NumMult_Word_bitSequence_dict  :: \<open>(bitSequence)NumMult_class \<close>  where 
     \<open> instance_Num_NumMult_Word_bitSequence_dict = ((|

  numMult_method = bitSeqMult |) )\<close>



\<comment> \<open>\<open>val bitSeqPow : bitSequence -> nat -> bitSequence\<close>\<close>
definition bitSeqPow  :: \<open> bitSequence \<Rightarrow> nat \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqPow bs n = ( bitSeqArithUnaryOp ((\<lambda> i .  i ^ n)) bs )\<close> 
  for  bs  :: " bitSequence " 
  and  n  :: " nat "


definition instance_Num_NumPow_Word_bitSequence_dict  :: \<open>(bitSequence)NumPow_class \<close>  where 
     \<open> instance_Num_NumPow_Word_bitSequence_dict = ((|

  numPow_method = bitSeqPow |) )\<close>


\<comment> \<open>\<open>val bitSeqDiv : bitSequence -> bitSequence -> bitSequence\<close>\<close>
definition bitSeqDiv  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqDiv bs1 bs2 = ( bitSeqArithBinOp (div) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


definition instance_Num_NumIntegerDivision_Word_bitSequence_dict  :: \<open>(bitSequence)NumIntegerDivision_class \<close>  where 
     \<open> instance_Num_NumIntegerDivision_Word_bitSequence_dict = ((|

  div_method = bitSeqDiv |) )\<close>


definition instance_Num_NumDivision_Word_bitSequence_dict  :: \<open>(bitSequence)NumDivision_class \<close>  where 
     \<open> instance_Num_NumDivision_Word_bitSequence_dict = ((|

  numDivision_method = bitSeqDiv |) )\<close>


\<comment> \<open>\<open>val bitSeqMod : bitSequence -> bitSequence -> bitSequence\<close>\<close>
definition bitSeqMod  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqMod bs1 bs2 = ( bitSeqArithBinOp (mod) bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


definition instance_Num_NumRemainder_Word_bitSequence_dict  :: \<open>(bitSequence)NumRemainder_class \<close>  where 
     \<open> instance_Num_NumRemainder_Word_bitSequence_dict = ((|

  mod_method = bitSeqMod |) )\<close>


\<comment> \<open>\<open>val bitSeqMin : bitSequence -> bitSequence -> bitSequence\<close>\<close>
definition bitSeqMin  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqMin bs1 bs2 = ( bitSeqArithBinOp min bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


\<comment> \<open>\<open>val bitSeqMax : bitSequence -> bitSequence -> bitSequence\<close>\<close>
definition bitSeqMax  :: \<open> bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqMax bs1 bs2 = ( bitSeqArithBinOp max bs1 bs2 )\<close> 
  for  bs1  :: " bitSequence " 
  and  bs2  :: " bitSequence "


definition instance_Basic_classes_OrdMaxMin_Word_bitSequence_dict  :: \<open>(bitSequence)OrdMaxMin_class \<close>  where 
     \<open> instance_Basic_classes_OrdMaxMin_Word_bitSequence_dict = ((|

  max_method = bitSeqMax,

  min_method = bitSeqMin |) )\<close>





\<comment> \<open>\<open> ========================================================================== \<close>\<close>
\<comment> \<open>\<open> Interface for bitoperations                                                \<close>\<close>
\<comment> \<open>\<open> ========================================================================== \<close>\<close>

record 'a WordNot_class= 

  lnot_method ::" 'a \<Rightarrow> 'a "



record 'a WordAnd_class= 

  land_method  ::" 'a \<Rightarrow> 'a \<Rightarrow> 'a "



record 'a WordOr_class= 

  lor_method ::" 'a \<Rightarrow> 'a \<Rightarrow> 'a "




record 'a WordXor_class= 

  lxor_method ::" 'a \<Rightarrow> 'a \<Rightarrow> 'a "



record 'a WordLsl_class= 

  lsl_method ::" 'a \<Rightarrow> nat \<Rightarrow> 'a "



record 'a WordLsr_class= 

  lsr_method ::" 'a \<Rightarrow> nat \<Rightarrow> 'a "



record 'a WordAsr_class= 

  asr_method ::" 'a \<Rightarrow> nat \<Rightarrow> 'a "



\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> bitSequence             \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

definition instance_Word_WordNot_Word_bitSequence_dict  :: \<open>(bitSequence)WordNot_class \<close>  where 
     \<open> instance_Word_WordNot_Word_bitSequence_dict = ((|

  lnot_method = bitSeqNot |) )\<close>


definition instance_Word_WordAnd_Word_bitSequence_dict  :: \<open>(bitSequence)WordAnd_class \<close>  where 
     \<open> instance_Word_WordAnd_Word_bitSequence_dict = ((|

  land_method = bitSeqAnd |) )\<close>


definition instance_Word_WordOr_Word_bitSequence_dict  :: \<open>(bitSequence)WordOr_class \<close>  where 
     \<open> instance_Word_WordOr_Word_bitSequence_dict = ((|

  lor_method = bitSeqOr |) )\<close>


definition instance_Word_WordXor_Word_bitSequence_dict  :: \<open>(bitSequence)WordXor_class \<close>  where 
     \<open> instance_Word_WordXor_Word_bitSequence_dict = ((|

  lxor_method = bitSeqXor |) )\<close>


definition instance_Word_WordLsl_Word_bitSequence_dict  :: \<open>(bitSequence)WordLsl_class \<close>  where 
     \<open> instance_Word_WordLsl_Word_bitSequence_dict = ((|

  lsl_method = bitSeqShiftLeft |) )\<close>


definition instance_Word_WordLsr_Word_bitSequence_dict  :: \<open>(bitSequence)WordLsr_class \<close>  where 
     \<open> instance_Word_WordLsr_Word_bitSequence_dict = ((|

  lsr_method = bitSeqLogicalShiftRight |) )\<close>


definition instance_Word_WordAsr_Word_bitSequence_dict  :: \<open>(bitSequence)WordAsr_class \<close>  where 
     \<open> instance_Word_WordAsr_Word_bitSequence_dict = ((|

  asr_method = bitSeqArithmeticShiftRight |) )\<close>



\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> int32                   \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open>val int32Lnot : int32 -> int32\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordNot_Num_int32_dict  :: \<open>( 32 word)WordNot_class \<close>  where 
     \<open> instance_Word_WordNot_Num_int32_dict = ((|

  lnot_method = ((\<lambda> w. (NOT w)))|) )\<close>



\<comment> \<open>\<open>val int32Lor  : int32 -> int32 -> int32\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordOr_Num_int32_dict  :: \<open>( 32 word)WordOr_class \<close>  where 
     \<open> instance_Word_WordOr_Num_int32_dict = ((|

  lor_method = (OR)|) )\<close>


\<comment> \<open>\<open>val int32Lxor : int32 -> int32 -> int32\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordXor_Num_int32_dict  :: \<open>( 32 word)WordXor_class \<close>  where 
     \<open> instance_Word_WordXor_Num_int32_dict = ((|

  lxor_method = (XOR)|) )\<close>


\<comment> \<open>\<open>val int32Land : int32 -> int32 -> int32\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordAnd_Num_int32_dict  :: \<open>( 32 word)WordAnd_class \<close>  where 
     \<open> instance_Word_WordAnd_Num_int32_dict = ((|

  land_method = (AND)|) )\<close>


\<comment> \<open>\<open>val int32Lsl  : int32 -> nat -> int32\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordLsl_Num_int32_dict  :: \<open>( 32 word)WordLsl_class \<close>  where 
     \<open> instance_Word_WordLsl_Num_int32_dict = ((|

  lsl_method = (<<)|) )\<close>


\<comment> \<open>\<open>val int32Lsr  : int32 -> nat -> int32\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordLsr_Num_int32_dict  :: \<open>( 32 word)WordLsr_class \<close>  where 
     \<open> instance_Word_WordLsr_Num_int32_dict = ((|

  lsr_method = (>>)|) )\<close>



\<comment> \<open>\<open>val int32Asr  : int32 -> nat -> int32\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordAsr_Num_int32_dict  :: \<open>( 32 word)WordAsr_class \<close>  where 
     \<open> instance_Word_WordAsr_Num_int32_dict = ((|

  asr_method = (>>>)|) )\<close>



\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> int64                   \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open>val int64Lnot : int64 -> int64\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordNot_Num_int64_dict  :: \<open>( 64 word)WordNot_class \<close>  where 
     \<open> instance_Word_WordNot_Num_int64_dict = ((|

  lnot_method = ((\<lambda> w. (NOT w)))|) )\<close>


\<comment> \<open>\<open>val int64Lor  : int64 -> int64 -> int64\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordOr_Num_int64_dict  :: \<open>( 64 word)WordOr_class \<close>  where 
     \<open> instance_Word_WordOr_Num_int64_dict = ((|

  lor_method = (OR)|) )\<close>


\<comment> \<open>\<open>val int64Lxor : int64 -> int64 -> int64\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordXor_Num_int64_dict  :: \<open>( 64 word)WordXor_class \<close>  where 
     \<open> instance_Word_WordXor_Num_int64_dict = ((|

  lxor_method = (XOR)|) )\<close>


\<comment> \<open>\<open>val int64Land : int64 -> int64 -> int64\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordAnd_Num_int64_dict  :: \<open>( 64 word)WordAnd_class \<close>  where 
     \<open> instance_Word_WordAnd_Num_int64_dict = ((|

  land_method = (AND)|) )\<close>


\<comment> \<open>\<open>val int64Lsl  : int64 -> nat -> int64\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordLsl_Num_int64_dict  :: \<open>( 64 word)WordLsl_class \<close>  where 
     \<open> instance_Word_WordLsl_Num_int64_dict = ((|

  lsl_method = (<<)|) )\<close>


\<comment> \<open>\<open>val int64Lsr  : int64 -> nat -> int64\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordLsr_Num_int64_dict  :: \<open>( 64 word)WordLsr_class \<close>  where 
     \<open> instance_Word_WordLsr_Num_int64_dict = ((|

  lsr_method = (>>)|) )\<close>


\<comment> \<open>\<open>val int64Asr  : int64 -> nat -> int64\<close>\<close> \<comment> \<open>\<open> XXX: fix \<close>\<close>

definition instance_Word_WordAsr_Num_int64_dict  :: \<open>( 64 word)WordAsr_class \<close>  where 
     \<open> instance_Word_WordAsr_Num_int64_dict = ((|

  asr_method = (>>>)|) )\<close>



\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> Words via bit sequences \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open>val defaultLnot : forall 'a. (bitSequence -> 'a) -> ('a -> bitSequence) -> 'a -> 'a\<close>\<close> 
definition defaultLnot  :: \<open>(bitSequence \<Rightarrow> 'a)\<Rightarrow>('a \<Rightarrow> bitSequence)\<Rightarrow> 'a \<Rightarrow> 'a \<close>  where 
     \<open> defaultLnot fromBitSeq toBitSeq x = ( fromBitSeq (bitSeqNegate (toBitSeq x)))\<close> 
  for  fromBitSeq  :: " bitSequence \<Rightarrow> 'a " 
  and  toBitSeq  :: " 'a \<Rightarrow> bitSequence " 
  and  x  :: " 'a "


\<comment> \<open>\<open>val defaultLand : forall 'a. (bitSequence -> 'a) -> ('a -> bitSequence) -> 'a -> 'a -> 'a\<close>\<close>
definition defaultLand  :: \<open>(bitSequence \<Rightarrow> 'a)\<Rightarrow>('a \<Rightarrow> bitSequence)\<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a \<close>  where 
     \<open> defaultLand fromBitSeq toBitSeq x1 x2 = ( fromBitSeq (bitSeqAnd (toBitSeq x1) (toBitSeq x2)))\<close> 
  for  fromBitSeq  :: " bitSequence \<Rightarrow> 'a " 
  and  toBitSeq  :: " 'a \<Rightarrow> bitSequence " 
  and  x1  :: " 'a " 
  and  x2  :: " 'a "


\<comment> \<open>\<open>val defaultLor : forall 'a. (bitSequence -> 'a) -> ('a -> bitSequence) -> 'a -> 'a -> 'a\<close>\<close>
definition defaultLor  :: \<open>(bitSequence \<Rightarrow> 'a)\<Rightarrow>('a \<Rightarrow> bitSequence)\<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a \<close>  where 
     \<open> defaultLor fromBitSeq toBitSeq x1 x2 = ( fromBitSeq (bitSeqOr (toBitSeq x1) (toBitSeq x2)))\<close> 
  for  fromBitSeq  :: " bitSequence \<Rightarrow> 'a " 
  and  toBitSeq  :: " 'a \<Rightarrow> bitSequence " 
  and  x1  :: " 'a " 
  and  x2  :: " 'a "


\<comment> \<open>\<open>val defaultLxor : forall 'a. (bitSequence -> 'a) -> ('a -> bitSequence) -> 'a -> 'a -> 'a\<close>\<close>
definition defaultLxor  :: \<open>(bitSequence \<Rightarrow> 'a)\<Rightarrow>('a \<Rightarrow> bitSequence)\<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a \<close>  where 
     \<open> defaultLxor fromBitSeq toBitSeq x1 x2 = ( fromBitSeq (bitSeqXor (toBitSeq x1) (toBitSeq x2)))\<close> 
  for  fromBitSeq  :: " bitSequence \<Rightarrow> 'a " 
  and  toBitSeq  :: " 'a \<Rightarrow> bitSequence " 
  and  x1  :: " 'a " 
  and  x2  :: " 'a "


\<comment> \<open>\<open>val defaultLsl : forall 'a. (bitSequence -> 'a) -> ('a -> bitSequence) -> 'a -> nat -> 'a\<close>\<close>
definition defaultLsl  :: \<open>(bitSequence \<Rightarrow> 'a)\<Rightarrow>('a \<Rightarrow> bitSequence)\<Rightarrow> 'a \<Rightarrow> nat \<Rightarrow> 'a \<close>  where 
     \<open> defaultLsl fromBitSeq toBitSeq x n = ( fromBitSeq (bitSeqShiftLeft (toBitSeq x) n))\<close> 
  for  fromBitSeq  :: " bitSequence \<Rightarrow> 'a " 
  and  toBitSeq  :: " 'a \<Rightarrow> bitSequence " 
  and  x  :: " 'a " 
  and  n  :: " nat "


\<comment> \<open>\<open>val defaultLsr : forall 'a. (bitSequence -> 'a) -> ('a -> bitSequence) -> 'a -> nat -> 'a\<close>\<close>
definition defaultLsr  :: \<open>(bitSequence \<Rightarrow> 'a)\<Rightarrow>('a \<Rightarrow> bitSequence)\<Rightarrow> 'a \<Rightarrow> nat \<Rightarrow> 'a \<close>  where 
     \<open> defaultLsr fromBitSeq toBitSeq x n = ( fromBitSeq (bitSeqLogicalShiftRight (toBitSeq x) n))\<close> 
  for  fromBitSeq  :: " bitSequence \<Rightarrow> 'a " 
  and  toBitSeq  :: " 'a \<Rightarrow> bitSequence " 
  and  x  :: " 'a " 
  and  n  :: " nat "


\<comment> \<open>\<open>val defaultAsr : forall 'a. (bitSequence -> 'a) -> ('a -> bitSequence) -> 'a -> nat -> 'a\<close>\<close>
definition defaultAsr  :: \<open>(bitSequence \<Rightarrow> 'a)\<Rightarrow>('a \<Rightarrow> bitSequence)\<Rightarrow> 'a \<Rightarrow> nat \<Rightarrow> 'a \<close>  where 
     \<open> defaultAsr fromBitSeq toBitSeq x n = ( fromBitSeq (bitSeqArithmeticShiftRight (toBitSeq x) n))\<close> 
  for  fromBitSeq  :: " bitSequence \<Rightarrow> 'a " 
  and  toBitSeq  :: " 'a \<Rightarrow> bitSequence " 
  and  x  :: " 'a " 
  and  n  :: " nat "


\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> integer                 \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open>val integerLnot : integer -> integer\<close>\<close>
definition integerLnot  :: \<open> int \<Rightarrow> int \<close>  where 
     \<open> integerLnot i = ( - (i +( 1 :: int)))\<close> 
  for  i  :: " int "


definition instance_Word_WordNot_Num_integer_dict  :: \<open>(int)WordNot_class \<close>  where 
     \<open> instance_Word_WordNot_Num_integer_dict = ((|

  lnot_method = integerLnot |) )\<close>



\<comment> \<open>\<open>val integerLor  : integer -> integer -> integer\<close>\<close>
definition integerLor  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> integerLor i1 i2 = ( defaultLor integerFromBitSeq (bitSeqFromInteger None) i1 i2 )\<close> 
  for  i1  :: " int " 
  and  i2  :: " int "


definition instance_Word_WordOr_Num_integer_dict  :: \<open>(int)WordOr_class \<close>  where 
     \<open> instance_Word_WordOr_Num_integer_dict = ((|

  lor_method = integerLor |) )\<close>


\<comment> \<open>\<open>val integerLxor : integer -> integer -> integer\<close>\<close>
definition integerLxor  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> integerLxor i1 i2 = ( defaultLxor integerFromBitSeq (bitSeqFromInteger None) i1 i2 )\<close> 
  for  i1  :: " int " 
  and  i2  :: " int "


definition instance_Word_WordXor_Num_integer_dict  :: \<open>(int)WordXor_class \<close>  where 
     \<open> instance_Word_WordXor_Num_integer_dict = ((|

  lxor_method = integerLxor |) )\<close>


\<comment> \<open>\<open>val integerLand : integer -> integer -> integer\<close>\<close>
definition integerLand  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> integerLand i1 i2 = ( defaultLand integerFromBitSeq (bitSeqFromInteger None) i1 i2 )\<close> 
  for  i1  :: " int " 
  and  i2  :: " int "


definition instance_Word_WordAnd_Num_integer_dict  :: \<open>(int)WordAnd_class \<close>  where 
     \<open> instance_Word_WordAnd_Num_integer_dict = ((|

  land_method = integerLand |) )\<close>


\<comment> \<open>\<open>val integerLsl  : integer -> nat -> integer\<close>\<close>
definition integerLsl  :: \<open> int \<Rightarrow> nat \<Rightarrow> int \<close>  where 
     \<open> integerLsl i n = ( defaultLsl integerFromBitSeq (bitSeqFromInteger None) i n )\<close> 
  for  i  :: " int " 
  and  n  :: " nat "


definition instance_Word_WordLsl_Num_integer_dict  :: \<open>(int)WordLsl_class \<close>  where 
     \<open> instance_Word_WordLsl_Num_integer_dict = ((|

  lsl_method = integerLsl |) )\<close>


\<comment> \<open>\<open>val integerAsr  : integer -> nat -> integer\<close>\<close>
definition integerAsr  :: \<open> int \<Rightarrow> nat \<Rightarrow> int \<close>  where 
     \<open> integerAsr i n = ( defaultAsr integerFromBitSeq (bitSeqFromInteger None) i n )\<close> 
  for  i  :: " int " 
  and  n  :: " nat "


definition instance_Word_WordLsr_Num_integer_dict  :: \<open>(int)WordLsr_class \<close>  where 
     \<open> instance_Word_WordLsr_Num_integer_dict = ((|

  lsr_method = integerAsr |) )\<close>


definition instance_Word_WordAsr_Num_integer_dict  :: \<open>(int)WordAsr_class \<close>  where 
     \<open> instance_Word_WordAsr_Num_integer_dict = ((|

  asr_method = integerAsr |) )\<close>



\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> int                     \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open> sometimes it is convenient to be able to perform bit-operations on ints.
   However, since int is not well-defined (it has different size on different systems),
   it should be used very carefully and only for operations that don't depend on the
   bitwidth of int \<close>\<close>

\<comment> \<open>\<open>val intFromBitSeq : bitSequence -> int\<close>\<close>
definition intFromBitSeq  :: \<open> bitSequence \<Rightarrow> int \<close>  where 
     \<open> intFromBitSeq bs = (  (integerFromBitSeq (resizeBitSeq (Some(( 31 :: nat))) bs)))\<close> 
  for  bs  :: " bitSequence "



\<comment> \<open>\<open>val bitSeqFromInt : int -> bitSequence\<close>\<close> 
definition bitSeqFromInt  :: \<open> int \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqFromInt i = ( bitSeqFromInteger (Some(( 31 :: nat))) ( i))\<close> 
  for  i  :: " int "



\<comment> \<open>\<open>val intLnot : int -> int\<close>\<close>
definition intLnot  :: \<open> int \<Rightarrow> int \<close>  where 
     \<open> intLnot i = ( - (i +( 1 :: int)))\<close> 
  for  i  :: " int "


definition instance_Word_WordNot_Num_int_dict  :: \<open>(int)WordNot_class \<close>  where 
     \<open> instance_Word_WordNot_Num_int_dict = ((|

  lnot_method = intLnot |) )\<close>


\<comment> \<open>\<open>val intLor  : int -> int -> int\<close>\<close>
definition intLor  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> intLor i1 i2 = ( defaultLor intFromBitSeq bitSeqFromInt i1 i2 )\<close> 
  for  i1  :: " int " 
  and  i2  :: " int "


definition instance_Word_WordOr_Num_int_dict  :: \<open>(int)WordOr_class \<close>  where 
     \<open> instance_Word_WordOr_Num_int_dict = ((|

  lor_method = intLor |) )\<close>


\<comment> \<open>\<open>val intLxor : int -> int -> int\<close>\<close>
definition intLxor  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> intLxor i1 i2 = ( defaultLxor intFromBitSeq bitSeqFromInt i1 i2 )\<close> 
  for  i1  :: " int " 
  and  i2  :: " int "


definition instance_Word_WordXor_Num_int_dict  :: \<open>(int)WordXor_class \<close>  where 
     \<open> instance_Word_WordXor_Num_int_dict = ((|

  lxor_method = intLxor |) )\<close>


\<comment> \<open>\<open>val intLand : int -> int -> int\<close>\<close>
definition intLand  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> intLand i1 i2 = ( defaultLand intFromBitSeq bitSeqFromInt i1 i2 )\<close> 
  for  i1  :: " int " 
  and  i2  :: " int "


definition instance_Word_WordAnd_Num_int_dict  :: \<open>(int)WordAnd_class \<close>  where 
     \<open> instance_Word_WordAnd_Num_int_dict = ((|

  land_method = intLand |) )\<close>


\<comment> \<open>\<open>val intLsl  : int -> nat -> int\<close>\<close>
definition intLsl  :: \<open> int \<Rightarrow> nat \<Rightarrow> int \<close>  where 
     \<open> intLsl i n = ( defaultLsl intFromBitSeq bitSeqFromInt i n )\<close> 
  for  i  :: " int " 
  and  n  :: " nat "


definition instance_Word_WordLsl_Num_int_dict  :: \<open>(int)WordLsl_class \<close>  where 
     \<open> instance_Word_WordLsl_Num_int_dict = ((|

  lsl_method = intLsl |) )\<close>


\<comment> \<open>\<open>val intAsr  : int -> nat -> int\<close>\<close>
definition intAsr  :: \<open> int \<Rightarrow> nat \<Rightarrow> int \<close>  where 
     \<open> intAsr i n = ( defaultAsr intFromBitSeq bitSeqFromInt i n )\<close> 
  for  i  :: " int " 
  and  n  :: " nat "


definition instance_Word_WordAsr_Num_int_dict  :: \<open>(int)WordAsr_class \<close>  where 
     \<open> instance_Word_WordAsr_Num_int_dict = ((|

  asr_method = intAsr |) )\<close>




\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> natural                 \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open> some operations work also on positive numbers \<close>\<close>

\<comment> \<open>\<open>val naturalFromBitSeq : bitSequence -> natural\<close>\<close>
definition naturalFromBitSeq  :: \<open> bitSequence \<Rightarrow> nat \<close>  where 
     \<open> naturalFromBitSeq bs = ( nat (abs (integerFromBitSeq bs)))\<close> 
  for  bs  :: " bitSequence "


\<comment> \<open>\<open>val bitSeqFromNatural : maybe nat -> natural -> bitSequence\<close>\<close>
definition bitSeqFromNatural  :: \<open>(nat)option \<Rightarrow> nat \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqFromNatural len n = ( bitSeqFromInteger len (int n))\<close> 
  for  len  :: "(nat)option " 
  and  n  :: " nat "


\<comment> \<open>\<open>val naturalLor  : natural -> natural -> natural\<close>\<close>
definition naturalLor  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> naturalLor i1 i2 = ( defaultLor naturalFromBitSeq (bitSeqFromNatural None) i1 i2 )\<close> 
  for  i1  :: " nat " 
  and  i2  :: " nat "


definition instance_Word_WordOr_Num_natural_dict  :: \<open>(nat)WordOr_class \<close>  where 
     \<open> instance_Word_WordOr_Num_natural_dict = ((|

  lor_method = naturalLor |) )\<close>


\<comment> \<open>\<open>val naturalLxor : natural -> natural -> natural\<close>\<close>
definition naturalLxor  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> naturalLxor i1 i2 = ( defaultLxor naturalFromBitSeq (bitSeqFromNatural None) i1 i2 )\<close> 
  for  i1  :: " nat " 
  and  i2  :: " nat "


definition instance_Word_WordXor_Num_natural_dict  :: \<open>(nat)WordXor_class \<close>  where 
     \<open> instance_Word_WordXor_Num_natural_dict = ((|

  lxor_method = naturalLxor |) )\<close>


\<comment> \<open>\<open>val naturalLand : natural -> natural -> natural\<close>\<close>
definition naturalLand  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> naturalLand i1 i2 = ( defaultLand naturalFromBitSeq (bitSeqFromNatural None) i1 i2 )\<close> 
  for  i1  :: " nat " 
  and  i2  :: " nat "


definition instance_Word_WordAnd_Num_natural_dict  :: \<open>(nat)WordAnd_class \<close>  where 
     \<open> instance_Word_WordAnd_Num_natural_dict = ((|

  land_method = naturalLand |) )\<close>


\<comment> \<open>\<open>val naturalLsl  : natural -> nat -> natural\<close>\<close>
definition naturalLsl  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> naturalLsl i n = ( defaultLsl naturalFromBitSeq (bitSeqFromNatural None) i n )\<close> 
  for  i  :: " nat " 
  and  n  :: " nat "


definition instance_Word_WordLsl_Num_natural_dict  :: \<open>(nat)WordLsl_class \<close>  where 
     \<open> instance_Word_WordLsl_Num_natural_dict = ((|

  lsl_method = naturalLsl |) )\<close>


\<comment> \<open>\<open>val naturalAsr  : natural -> nat -> natural\<close>\<close>
definition naturalAsr  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> naturalAsr i n = ( defaultAsr naturalFromBitSeq (bitSeqFromNatural None) i n )\<close> 
  for  i  :: " nat " 
  and  n  :: " nat "


definition instance_Word_WordLsr_Num_natural_dict  :: \<open>(nat)WordLsr_class \<close>  where 
     \<open> instance_Word_WordLsr_Num_natural_dict = ((|

  lsr_method = naturalAsr |) )\<close>


definition instance_Word_WordAsr_Num_natural_dict  :: \<open>(nat)WordAsr_class \<close>  where 
     \<open> instance_Word_WordAsr_Num_natural_dict = ((|

  asr_method = naturalAsr |) )\<close>



\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> nat                     \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open> sometimes it is convenient to be able to perform bit-operations on nats.
   However, since nat is not well-defined (it has different size on different systems),
   it should be used very carefully and only for operations that don't depend on the
   bitwidth of nat \<close>\<close>

\<comment> \<open>\<open>val natFromBitSeq : bitSequence -> nat\<close>\<close>
definition natFromBitSeq  :: \<open> bitSequence \<Rightarrow> nat \<close>  where 
     \<open> natFromBitSeq bs = (  (naturalFromBitSeq (resizeBitSeq (Some(( 31 :: nat))) bs)))\<close> 
  for  bs  :: " bitSequence "



\<comment> \<open>\<open>val bitSeqFromNat : nat -> bitSequence\<close>\<close> 
definition bitSeqFromNat  :: \<open> nat \<Rightarrow> bitSequence \<close>  where 
     \<open> bitSeqFromNat i = ( bitSeqFromNatural (Some(( 31 :: nat))) ( i))\<close> 
  for  i  :: " nat "



\<comment> \<open>\<open>val natLor  : nat -> nat -> nat\<close>\<close>
definition natLor  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> natLor i1 i2 = ( defaultLor natFromBitSeq bitSeqFromNat i1 i2 )\<close> 
  for  i1  :: " nat " 
  and  i2  :: " nat "


definition instance_Word_WordOr_nat_dict  :: \<open>(nat)WordOr_class \<close>  where 
     \<open> instance_Word_WordOr_nat_dict = ((|

  lor_method = natLor |) )\<close>


\<comment> \<open>\<open>val natLxor : nat -> nat -> nat\<close>\<close>
definition natLxor  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> natLxor i1 i2 = ( defaultLxor natFromBitSeq bitSeqFromNat i1 i2 )\<close> 
  for  i1  :: " nat " 
  and  i2  :: " nat "


definition instance_Word_WordXor_nat_dict  :: \<open>(nat)WordXor_class \<close>  where 
     \<open> instance_Word_WordXor_nat_dict = ((|

  lxor_method = natLxor |) )\<close>


\<comment> \<open>\<open>val natLand : nat -> nat -> nat\<close>\<close>
definition natLand  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> natLand i1 i2 = ( defaultLand natFromBitSeq bitSeqFromNat i1 i2 )\<close> 
  for  i1  :: " nat " 
  and  i2  :: " nat "


definition instance_Word_WordAnd_nat_dict  :: \<open>(nat)WordAnd_class \<close>  where 
     \<open> instance_Word_WordAnd_nat_dict = ((|

  land_method = natLand |) )\<close>


\<comment> \<open>\<open>val natLsl  : nat -> nat -> nat\<close>\<close>
definition natLsl  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> natLsl i n = ( defaultLsl natFromBitSeq bitSeqFromNat i n )\<close> 
  for  i  :: " nat " 
  and  n  :: " nat "


definition instance_Word_WordLsl_nat_dict  :: \<open>(nat)WordLsl_class \<close>  where 
     \<open> instance_Word_WordLsl_nat_dict = ((|

  lsl_method = natLsl |) )\<close>


\<comment> \<open>\<open>val natAsr  : nat -> nat -> nat\<close>\<close>
definition natAsr  :: \<open> nat \<Rightarrow> nat \<Rightarrow> nat \<close>  where 
     \<open> natAsr i n = ( defaultAsr natFromBitSeq bitSeqFromNat i n )\<close> 
  for  i  :: " nat " 
  and  n  :: " nat "


definition instance_Word_WordAsr_nat_dict  :: \<open>(nat)WordAsr_class \<close>  where 
     \<open> instance_Word_WordAsr_nat_dict = ((|

  asr_method = natAsr |) )\<close>


end
