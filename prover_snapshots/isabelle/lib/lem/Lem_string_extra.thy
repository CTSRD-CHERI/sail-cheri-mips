chapter \<open>Generated by Lem from \<open>string_extra.lem\<close>.\<close>

theory "Lem_string_extra" 

imports
  Main
  "Lem_num"
  "Lem_list"
  "Lem_basic_classes"
  "Lem_string"
  "Lem_list_extra"

begin 

\<comment> \<open>\<open>****************************************************************************\<close>\<close>
\<comment> \<open>\<open> String functions                                                           \<close>\<close>
\<comment> \<open>\<open>****************************************************************************\<close>\<close>

\<comment> \<open>\<open>open import Basic_classes\<close>\<close>
\<comment> \<open>\<open>open import Num\<close>\<close>
\<comment> \<open>\<open>open import List\<close>\<close>
\<comment> \<open>\<open>open import String\<close>\<close>
\<comment> \<open>\<open>open import List_extra\<close>\<close>
\<comment> \<open>\<open>open import {hol} `stringLib`\<close>\<close>
\<comment> \<open>\<open>open import {hol} `ASCIInumbersTheory`\<close>\<close>


\<comment> \<open>\<open>****************************************************************************\<close>\<close>
\<comment> \<open>\<open> Character's to numbers                                                     \<close>\<close>
\<comment> \<open>\<open>****************************************************************************\<close>\<close>

\<comment> \<open>\<open>val ord : char -> nat\<close>\<close>

\<comment> \<open>\<open>val chr : nat -> char\<close>\<close>

\<comment> \<open>\<open>****************************************************************************\<close>\<close>
\<comment> \<open>\<open> Converting to strings                                                      \<close>\<close>
\<comment> \<open>\<open>****************************************************************************\<close>\<close>

\<comment> \<open>\<open>val stringFromNatHelper : nat -> list char -> list char\<close>\<close>
fun  stringFromNatHelper  :: \<open> nat \<Rightarrow>(char)list \<Rightarrow>(char)list \<close>  where 
     \<open> stringFromNatHelper n acc1 = (
  if n =( 0 :: nat) then
    acc1
  else
    stringFromNatHelper (n div( 10 :: nat)) ((%n. char_of (n::nat)) ((n mod( 10 :: nat)) +( 48 :: nat)) # acc1))\<close> 
  for  n  :: " nat " 
  and  acc1  :: "(char)list "


\<comment> \<open>\<open>val stringFromNat : nat -> string\<close>\<close>
definition stringFromNat  :: \<open> nat \<Rightarrow> string \<close>  where 
     \<open> stringFromNat n = ( 
  if n =( 0 :: nat) then (''0'') else  (stringFromNatHelper n []))\<close> 
  for  n  :: " nat "


\<comment> \<open>\<open>val stringFromNaturalHelper : natural -> list char -> list char\<close>\<close>
fun  stringFromNaturalHelper  :: \<open> nat \<Rightarrow>(char)list \<Rightarrow>(char)list \<close>  where 
     \<open> stringFromNaturalHelper n acc1 = (
  if n =( 0 :: nat) then
    acc1
  else
    stringFromNaturalHelper (n div( 10 :: nat)) ((%n. char_of (n::nat)) ( ((n mod( 10 :: nat)) +( 48 :: nat))) # acc1))\<close> 
  for  n  :: " nat " 
  and  acc1  :: "(char)list "


\<comment> \<open>\<open>val stringFromNatural : natural -> string\<close>\<close>
definition stringFromNatural  :: \<open> nat \<Rightarrow> string \<close>  where 
     \<open> stringFromNatural n = ( 
  if n =( 0 :: nat) then (''0'') else  (stringFromNaturalHelper n []))\<close> 
  for  n  :: " nat "


\<comment> \<open>\<open>val stringFromInt : int -> string\<close>\<close>
definition stringFromInt  :: \<open> int \<Rightarrow> string \<close>  where 
     \<open> stringFromInt i = ( 
  if i <( 0 :: int) then 
    (''-'') @ stringFromNat (nat (abs i))
  else
    stringFromNat (nat (abs i)))\<close> 
  for  i  :: " int "


\<comment> \<open>\<open>val stringFromInteger : integer -> string\<close>\<close>
definition stringFromInteger  :: \<open> int \<Rightarrow> string \<close>  where 
     \<open> stringFromInteger i = ( 
  if i <( 0 :: int) then 
    (''-'') @ stringFromNatural (nat (abs i))
  else
    stringFromNatural (nat (abs i)))\<close> 
  for  i  :: " int "



\<comment> \<open>\<open>****************************************************************************\<close>\<close>
\<comment> \<open>\<open> List-like operations                                                       \<close>\<close>
\<comment> \<open>\<open>****************************************************************************\<close>\<close>

\<comment> \<open>\<open>val nth : string -> nat -> char\<close>\<close>
definition nth  :: \<open> string \<Rightarrow> nat \<Rightarrow> char \<close>  where 
     \<open> nth s n = ( List.nth ( s) n )\<close> 
  for  s  :: " string " 
  and  n  :: " nat "


\<comment> \<open>\<open>val stringConcat : list string -> string\<close>\<close>
definition stringConcat  :: \<open>(string)list \<Rightarrow> string \<close>  where 
     \<open> stringConcat s = (
  List.foldr (@) s (''''))\<close> 
  for  s  :: "(string)list "


\<comment> \<open>\<open>****************************************************************************\<close>\<close>
\<comment> \<open>\<open> String comparison                                                          \<close>\<close>
\<comment> \<open>\<open>****************************************************************************\<close>\<close>

\<comment> \<open>\<open>val stringCompare : string -> string -> ordering\<close>\<close>

definition stringLess  :: \<open> string \<Rightarrow> string \<Rightarrow> bool \<close>  where 
     \<open> stringLess x y = ( orderingIsLess (EQ))\<close> 
  for  x  :: " string " 
  and  y  :: " string "

definition stringLessEq  :: \<open> string \<Rightarrow> string \<Rightarrow> bool \<close>  where 
     \<open> stringLessEq x y = ( \<not> (orderingIsGreater (EQ)))\<close> 
  for  x  :: " string " 
  and  y  :: " string "

definition stringGreater  :: \<open> string \<Rightarrow> string \<Rightarrow> bool \<close>  where 
     \<open> stringGreater x y = ( stringLess y x )\<close> 
  for  x  :: " string " 
  and  y  :: " string "

definition stringGreaterEq  :: \<open> string \<Rightarrow> string \<Rightarrow> bool \<close>  where 
     \<open> stringGreaterEq x y = ( stringLessEq y x )\<close> 
  for  x  :: " string " 
  and  y  :: " string "


definition instance_Basic_classes_Ord_string_dict  :: \<open>(string)Ord_class \<close>  where 
     \<open> instance_Basic_classes_Ord_string_dict = ((|

  compare_method = ((\<lambda> x y. EQ)),

  isLess_method = stringLess,

  isLessEqual_method = stringLessEq,

  isGreater_method = stringGreater,

  isGreaterEqual_method = stringGreaterEq |) )\<close>

 
end
