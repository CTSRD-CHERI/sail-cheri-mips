chapter \<open>Generated by Lem from \<open>../../src/gen_lib/sail2_operators_mwords.lem\<close>.\<close>

theory "Sail2_operators_mwords" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "LEM.Lem_machine_word"
  "Sail2_values"
  "Sail2_operators"
  "Sail2_prompt_monad"
  "Sail2_prompt"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Machine_word\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt\<close>\<close>
definition uint_maybe  :: \<open>('a::len)Word.word \<Rightarrow>(int)option \<close>  where 
     \<open> uint_maybe v = ( Some (Word.uint v))\<close> 
  for  v  :: "('a::len)Word.word "

definition uint_fail  :: \<open>('a::len)Word.word \<Rightarrow>('c,(int),'b)monad \<close>  where 
     \<open> uint_fail v = ( return (Word.uint v))\<close> 
  for  v  :: "('a::len)Word.word "

definition uint_nondet  :: \<open>('a::len)Word.word \<Rightarrow>('c,(int),'b)monad \<close>  where 
     \<open> uint_nondet v = ( return (Word.uint v))\<close> 
  for  v  :: "('a::len)Word.word "

definition sint_maybe  :: \<open>('a::len)Word.word \<Rightarrow>(int)option \<close>  where 
     \<open> sint_maybe v = ( Some (Word.sint v))\<close> 
  for  v  :: "('a::len)Word.word "

definition sint_fail  :: \<open>('a::len)Word.word \<Rightarrow>('c,(int),'b)monad \<close>  where 
     \<open> sint_fail v = ( return (Word.sint v))\<close> 
  for  v  :: "('a::len)Word.word "

definition sint_nondet  :: \<open>('a::len)Word.word \<Rightarrow>('c,(int),'b)monad \<close>  where 
     \<open> sint_nondet v = ( return (Word.sint v))\<close> 
  for  v  :: "('a::len)Word.word "


\<comment> \<open>\<open>val vec_of_bits_maybe    : forall 'a. Size 'a => list bitU -> maybe (mword 'a)\<close>\<close>
\<comment> \<open>\<open>val vec_of_bits_fail     : forall 'rv 'a 'e. Size 'a => list bitU -> monad 'rv (mword 'a) 'e\<close>\<close>
\<comment> \<open>\<open>val vec_of_bits_nondet   : forall 'rv 'a 'e. Size 'a => list bitU -> monad 'rv (mword 'a) 'e\<close>\<close>
\<comment> \<open>\<open>val vec_of_bits_failwith : forall 'a. Size 'a => list bitU -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val vec_of_bits          : forall 'a. Size 'a => list bitU -> mword 'a\<close>\<close>
definition vec_of_bits_maybe  :: \<open>(bitU)list \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> vec_of_bits_maybe bits = ( map_option Word.of_bl (just_list (List.map bool_of_bitU bits)))\<close> 
  for  bits  :: "(bitU)list "

definition vec_of_bits_fail  :: \<open>(bitU)list \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> vec_of_bits_fail bits = ( of_bits_fail 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict bits )\<close> 
  for  bits  :: "(bitU)list "

definition vec_of_bits_nondet  :: \<open>(bitU)list \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> vec_of_bits_nondet bits = ( of_bits_nondet 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict bits )\<close> 
  for  bits  :: "(bitU)list "

definition vec_of_bits_failwith  :: \<open>(bitU)list \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> vec_of_bits_failwith bits = ( of_bits_failwith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict bits )\<close> 
  for  bits  :: "(bitU)list "

definition vec_of_bits  :: \<open>(bitU)list \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> vec_of_bits bits = ( of_bits_failwith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict bits )\<close> 
  for  bits  :: "(bitU)list "


\<comment> \<open>\<open>val access_vec_inc : forall 'a. Size 'a => mword 'a -> integer -> bitU\<close>\<close>
definition access_vec_inc  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<close>  where 
     \<open> access_vec_inc = ( 
  access_bv_inc instance_Sail2_values_Bitvector_Machine_word_mword_dict )\<close>


\<comment> \<open>\<open>val access_vec_dec : forall 'a. Size 'a => mword 'a -> integer -> bitU\<close>\<close>
definition access_vec_dec  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<close>  where 
     \<open> access_vec_dec = ( 
  access_bv_dec instance_Sail2_values_Bitvector_Machine_word_mword_dict )\<close>


definition update_vec_dec_maybe  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> update_vec_dec_maybe w i b = ( update_mword_dec w i b )\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  b  :: " bitU "

definition update_vec_dec_fail  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> update_vec_dec_fail w i b = (
  bool_of_bitU_fail b \<bind> ((\<lambda> b . 
  return (update_mword_bool_dec w i b))))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  b  :: " bitU "

definition update_vec_dec_nondet  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> update_vec_dec_nondet w i b = (
  bool_of_bitU_nondet b \<bind> ((\<lambda> b . 
  return (update_mword_bool_dec w i b))))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  b  :: " bitU "

definition update_vec_dec  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> update_vec_dec w i b = ( maybe_failwith (update_vec_dec_maybe w i b))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  b  :: " bitU "


definition update_vec_inc_maybe  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> update_vec_inc_maybe w i b = ( update_mword_inc w i b )\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  b  :: " bitU "

definition update_vec_inc_fail  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> update_vec_inc_fail w i b = (
  bool_of_bitU_fail b \<bind> ((\<lambda> b . 
  return (update_mword_bool_inc w i b))))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  b  :: " bitU "

definition update_vec_inc_nondet  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> update_vec_inc_nondet w i b = (
  bool_of_bitU_nondet b \<bind> ((\<lambda> b . 
  return (update_mword_bool_inc w i b))))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  b  :: " bitU "

definition update_vec_inc  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> update_vec_inc w i b = ( maybe_failwith (update_vec_inc_maybe w i b))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  b  :: " bitU "


\<comment> \<open>\<open>val subrange_vec_dec : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b\<close>\<close>
definition subrange_vec_dec  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> subrange_vec_dec w i j = ( Word.slice (nat_of_int j) w )\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val subrange_vec_inc : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b\<close>\<close>
definition subrange_vec_inc  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> subrange_vec_inc w i j = ( subrange_vec_dec w ((int (size w) -( 1 :: int)) - i) ((int (size w) -( 1 :: int)) - j))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val update_subrange_vec_dec : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b -> mword 'a\<close>\<close>
definition update_subrange_vec_dec  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> update_subrange_vec_dec w i j w' = ( Lem.word_update w (nat_of_int j) (nat_of_int i) w' )\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  w'  :: "('b::len)Word.word "


\<comment> \<open>\<open>val update_subrange_vec_inc : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b -> mword 'a\<close>\<close>
definition update_subrange_vec_inc  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> update_subrange_vec_inc w i j w' = ( update_subrange_vec_dec w ((int (size w) -( 1 :: int)) - i) ((int (size w) -( 1 :: int)) - j) w' )\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  w'  :: "('b::len)Word.word "


\<comment> \<open>\<open>val extz_vec : forall 'a 'b. Size 'a, Size 'b => integer -> mword 'a -> mword 'b\<close>\<close>
definition extz_vec  :: \<open> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> extz_vec _ w = ( Word.ucast w )\<close> 
  for  w  :: "('a::len)Word.word "


\<comment> \<open>\<open>val exts_vec : forall 'a 'b. Size 'a, Size 'b => integer -> mword 'a -> mword 'b\<close>\<close>
definition exts_vec  :: \<open> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> exts_vec _ w = ( Word.scast w )\<close> 
  for  w  :: "('a::len)Word.word "


\<comment> \<open>\<open>val zero_extend : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b\<close>\<close>
definition zero_extend  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> zero_extend w _ = ( Word.ucast w )\<close> 
  for  w  :: "('a::len)Word.word "


\<comment> \<open>\<open>val sign_extend : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b\<close>\<close>
definition sign_extend  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> sign_extend w _ = ( Word.scast w )\<close> 
  for  w  :: "('a::len)Word.word "


\<comment> \<open>\<open>val zeros : forall 'a. Size 'a => integer -> mword 'a\<close>\<close>
definition zeros  :: \<open> int \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> zeros _ = ( Word.word_of_int (int(( 0 :: nat))))\<close>


\<comment> \<open>\<open>val vector_truncate : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b\<close>\<close>
definition vector_truncate  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> vector_truncate w _ = ( Word.ucast w )\<close> 
  for  w  :: "('a::len)Word.word "


\<comment> \<open>\<open>val vector_truncateLSB : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b\<close>\<close>
definition vector_truncateLSB  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> vector_truncateLSB w len = (
  (let len = (nat_of_int len) in
  (let lo = (size w - len) in
  (let hi = ((lo + len) -( 1 :: nat)) in
  Word.slice lo w))))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  len  :: " int "


\<comment> \<open>\<open>val concat_vec : forall 'a 'b 'c. Size 'a, Size 'b, Size 'c => mword 'a -> mword 'b -> mword 'c\<close>\<close>
definition concat_vec  :: \<open>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('c::len)Word.word \<close>  where 
     \<open> concat_vec = ( Word.word_cat )\<close>


\<comment> \<open>\<open>val cons_vec_bool : forall 'a 'b 'c. Size 'a, Size 'b => bool -> mword 'a -> mword 'b\<close>\<close>
definition cons_vec_bool  :: \<open> bool \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> cons_vec_bool b w = ( Word.of_bl (b # Word.to_bl w))\<close> 
  for  b  :: " bool " 
  and  w  :: "('a::len)Word.word "

definition cons_vec_maybe  :: \<open> bitU \<Rightarrow>('c::len)Word.word \<Rightarrow>(('b::len)Word.word)option \<close>  where 
     \<open> cons_vec_maybe b w = ( map_option ((\<lambda> b .  cons_vec_bool b w)) (bool_of_bitU b))\<close> 
  for  b  :: " bitU " 
  and  w  :: "('c::len)Word.word "

definition cons_vec_fail  :: \<open> bitU \<Rightarrow>('c::len)Word.word \<Rightarrow>('e,(('b::len)Word.word),'d)monad \<close>  where 
     \<open> cons_vec_fail b w = ( bool_of_bitU_fail b \<bind> ((\<lambda> b .  return (cons_vec_bool b w))))\<close> 
  for  b  :: " bitU " 
  and  w  :: "('c::len)Word.word "

definition cons_vec_nondet  :: \<open> bitU \<Rightarrow>('c::len)Word.word \<Rightarrow>('e,(('b::len)Word.word),'d)monad \<close>  where 
     \<open> cons_vec_nondet b w = ( bool_of_bitU_nondet b \<bind> ((\<lambda> b .  return (cons_vec_bool b w))))\<close> 
  for  b  :: " bitU " 
  and  w  :: "('c::len)Word.word "

definition cons_vec  :: \<open> bitU \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> cons_vec b w = ( maybe_failwith (cons_vec_maybe b w))\<close> 
  for  b  :: " bitU " 
  and  w  :: "('a::len)Word.word "


\<comment> \<open>\<open>val vec_of_bool : forall 'a. Size 'a => integer -> bool -> mword 'a\<close>\<close>
definition vec_of_bool  :: \<open> int \<Rightarrow> bool \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> vec_of_bool _ b = ( Word.of_bl [b])\<close> 
  for  b  :: " bool "

definition vec_of_bit_maybe  :: \<open> int \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> vec_of_bit_maybe len b = ( map_option (vec_of_bool len) (bool_of_bitU b))\<close> 
  for  len  :: " int " 
  and  b  :: " bitU "

definition vec_of_bit_fail  :: \<open> int \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> vec_of_bit_fail len b = ( bool_of_bitU_fail b \<bind> ((\<lambda> b .  return (vec_of_bool len b))))\<close> 
  for  len  :: " int " 
  and  b  :: " bitU "

definition vec_of_bit_nondet  :: \<open> int \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> vec_of_bit_nondet len b = ( bool_of_bitU_nondet b \<bind> ((\<lambda> b .  return (vec_of_bool len b))))\<close> 
  for  len  :: " int " 
  and  b  :: " bitU "

definition vec_of_bit  :: \<open> int \<Rightarrow> bitU \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> vec_of_bit len b = ( maybe_failwith (vec_of_bit_maybe len b))\<close> 
  for  len  :: " int " 
  and  b  :: " bitU "


\<comment> \<open>\<open>val cast_bool_vec : bool -> mword ty1\<close>\<close>
definition cast_bool_vec  :: \<open> bool \<Rightarrow>(1)Word.word \<close>  where 
     \<open> cast_bool_vec b = ( vec_of_bool(( 1 :: int)) b )\<close> 
  for  b  :: " bool "

definition cast_unit_vec_maybe  :: \<open> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> cast_unit_vec_maybe b = ( vec_of_bit_maybe(( 1 :: int)) b )\<close> 
  for  b  :: " bitU "

definition cast_unit_vec_fail  :: \<open> bitU \<Rightarrow>('b,((1)Word.word),'a)monad \<close>  where 
     \<open> cast_unit_vec_fail b = ( bool_of_bitU_fail b \<bind> ((\<lambda> b .  return (cast_bool_vec b))))\<close> 
  for  b  :: " bitU "

definition cast_unit_vec_nondet  :: \<open> bitU \<Rightarrow>('b,((1)Word.word),'a)monad \<close>  where 
     \<open> cast_unit_vec_nondet b = ( bool_of_bitU_nondet b \<bind> ((\<lambda> b .  return (cast_bool_vec b))))\<close> 
  for  b  :: " bitU "

definition cast_unit_vec  :: \<open> bitU \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> cast_unit_vec b = ( maybe_failwith (cast_unit_vec_maybe b))\<close> 
  for  b  :: " bitU "


\<comment> \<open>\<open>val msb : forall 'a. Size 'a => mword 'a -> bitU\<close>\<close>
definition msb  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<close>  where 
     \<open> msb = ( 
  most_significant instance_Sail2_values_Bitvector_Machine_word_mword_dict )\<close>


\<comment> \<open>\<open>val int_of_vec : forall 'a. Size 'a => bool -> mword 'a -> integer\<close>\<close>
definition int_of_vec  :: \<open> bool \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<close>  where 
     \<open> int_of_vec sign w = (
  if sign
  then Word.sint w
  else Word.uint w )\<close> 
  for  sign  :: " bool " 
  and  w  :: "('a::len)Word.word "

definition int_of_vec_maybe  :: \<open> bool \<Rightarrow>('a::len)Word.word \<Rightarrow>(int)option \<close>  where 
     \<open> int_of_vec_maybe sign w = ( Some (int_of_vec sign w))\<close> 
  for  sign  :: " bool " 
  and  w  :: "('a::len)Word.word "

definition int_of_vec_fail  :: \<open> bool \<Rightarrow>('a::len)Word.word \<Rightarrow>('c,(int),'b)monad \<close>  where 
     \<open> int_of_vec_fail sign w = ( return (int_of_vec sign w))\<close> 
  for  sign  :: " bool " 
  and  w  :: "('a::len)Word.word "


\<comment> \<open>\<open>val string_of_bits : forall 'a. Size 'a => mword 'a -> string\<close>\<close>
definition string_of_bits  :: \<open>('a::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> string_of_bits = ( 
  string_of_bv instance_Sail2_values_Bitvector_Machine_word_mword_dict )\<close>


\<comment> \<open>\<open>val decimal_string_of_bits : forall 'a. Size 'a => mword 'a -> string\<close>\<close>
definition decimal_string_of_bits  :: \<open>('a::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> decimal_string_of_bits = ( 
  decimal_string_of_bv instance_Sail2_values_Bitvector_Machine_word_mword_dict )\<close>


\<comment> \<open>\<open>val and_vec : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val or_vec  : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val xor_vec : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val not_vec : forall 'a. Size 'a => mword 'a -> mword 'a\<close>\<close>
definition and_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> and_vec = ( Bits.bitAND )\<close>

definition or_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>   where 
     \<open> or_vec  = ( Bits.bitOR )\<close>

definition xor_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> xor_vec = ( Bits.bitXOR )\<close>

definition not_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> not_vec = ( Bits.bitNOT )\<close>


\<comment> \<open>\<open>val add_vec   : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val adds_vec  : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val sub_vec   : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val subs_vec  : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val mult_vec  : forall 'a 'b. Size 'a, Size 'b => mword 'a -> mword 'a -> mword 'b\<close>\<close>
\<comment> \<open>\<open>val mults_vec : forall 'a 'b. Size 'a, Size 'b => mword 'a -> mword 'a -> mword 'b\<close>\<close>
definition add_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> add_vec   l r = ( Word.word_of_int ((int_of_mword False l) + (int_of_mword False r)))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition adds_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> adds_vec  l r = ( Word.word_of_int ((int_of_mword True l) + (int_of_mword True r)))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition sub_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> sub_vec   l r = ( Word.word_of_int ((int_of_mword False l) - (int_of_mword False r)))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition subs_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> subs_vec  l r = ( Word.word_of_int ((int_of_mword True l) - (int_of_mword True r)))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition mult_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> mult_vec  l r = ( Word.word_of_int ((int_of_mword False (Word.ucast l :: ( 'b::len)Word.word)) * (int_of_mword False (Word.ucast r :: ( 'b::len)Word.word))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition mults_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> mults_vec l r = ( Word.word_of_int ((int_of_mword True (Word.scast l :: ( 'b::len)Word.word)) * (int_of_mword True (Word.scast r :: ( 'b::len)Word.word))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "


\<comment> \<open>\<open>val add_vec_int   : forall 'a. Size 'a => mword 'a -> integer -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val sub_vec_int   : forall 'a. Size 'a => mword 'a -> integer -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val mult_vec_int  : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b\<close>\<close>
definition add_vec_int  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> add_vec_int   l r = ( arith_op_bv_int 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (+)   False l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "

definition sub_vec_int  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> sub_vec_int   l r = ( arith_op_bv_int 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (-) False l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "

definition mult_vec_int  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> mult_vec_int  l r = ( arith_op_bv_int 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (*)  False (Word.ucast l :: ( 'b::len)Word.word) r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "


\<comment> \<open>\<open>val add_int_vec   : forall 'a. Size 'a => integer -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val sub_int_vec   : forall 'a. Size 'a => integer -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val mult_int_vec  : forall 'a 'b. Size 'a, Size 'b => integer -> mword 'a -> mword 'b\<close>\<close>
definition add_int_vec  :: \<open> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> add_int_vec   l r = ( arith_op_int_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (+)   False l r )\<close> 
  for  l  :: " int " 
  and  r  :: "('a::len)Word.word "

definition sub_int_vec  :: \<open> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> sub_int_vec   l r = ( arith_op_int_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (-) False l r )\<close> 
  for  l  :: " int " 
  and  r  :: "('a::len)Word.word "

definition mult_int_vec  :: \<open> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> mult_int_vec  l r = ( arith_op_int_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (*)  False l (Word.ucast r :: ( 'b::len)Word.word))\<close> 
  for  l  :: " int " 
  and  r  :: "('a::len)Word.word "


\<comment> \<open>\<open>val add_vec_bool  : forall 'a. Size 'a => mword 'a -> bool -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val adds_vec_bool : forall 'a. Size 'a => mword 'a -> bool -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val sub_vec_bool  : forall 'a. Size 'a => mword 'a -> bool -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val subs_vec_bool : forall 'a. Size 'a => mword 'a -> bool -> mword 'a\<close>\<close>

definition add_vec_bool  :: \<open>('a::len)Word.word \<Rightarrow> bool \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> add_vec_bool        l r = ( arith_op_bv_bool 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (+) False l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bool "

definition add_vec_bit_maybe  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> add_vec_bit_maybe   l r = ( map_option (add_vec_bool l) (bool_of_bitU r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition add_vec_bit_fail  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> add_vec_bit_fail    l r = ( bool_of_bitU_fail r \<bind> ((\<lambda> r .  return (add_vec_bool l r))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition add_vec_bit_nondet  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> add_vec_bit_nondet  l r = ( bool_of_bitU_nondet r \<bind> ((\<lambda> r .  return (add_vec_bool l r))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition add_vec_bit  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> add_vec_bit         l r = ( maybe_failwith (add_vec_bit_maybe  l r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "


definition adds_vec_bool  :: \<open>('a::len)Word.word \<Rightarrow> bool \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> adds_vec_bool       l r = ( arith_op_bv_bool 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (+) True  l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bool "

definition adds_vec_bit_maybe  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> adds_vec_bit_maybe  l r = ( map_option (adds_vec_bool l) (bool_of_bitU r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition adds_vec_bit_fail  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> adds_vec_bit_fail   l r = ( bool_of_bitU_fail r \<bind> ((\<lambda> r .  return (adds_vec_bool l r))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition adds_vec_bit_nondet  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> adds_vec_bit_nondet l r = ( bool_of_bitU_nondet r \<bind> ((\<lambda> r .  return (adds_vec_bool l r))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition adds_vec_bit  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> adds_vec_bit        l r = ( maybe_failwith (adds_vec_bit_maybe l r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "


definition sub_vec_bool  :: \<open>('a::len)Word.word \<Rightarrow> bool \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> sub_vec_bool        l r = ( arith_op_bv_bool 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (-) False l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bool "

definition sub_vec_bit_maybe  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> sub_vec_bit_maybe   l r = ( map_option (sub_vec_bool l) (bool_of_bitU r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition sub_vec_bit_fail  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> sub_vec_bit_fail    l r = ( bool_of_bitU_fail r \<bind> ((\<lambda> r .  return (sub_vec_bool l r))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition sub_vec_bit_nondet  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> sub_vec_bit_nondet  l r = ( bool_of_bitU_nondet r \<bind> ((\<lambda> r .  return (sub_vec_bool l r))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition sub_vec_bit  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> sub_vec_bit         l r = ( maybe_failwith (sub_vec_bit_maybe  l r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "


definition subs_vec_bool  :: \<open>('a::len)Word.word \<Rightarrow> bool \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> subs_vec_bool       l r = ( arith_op_bv_bool 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (-) True  l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bool "

definition subs_vec_bit_maybe  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> subs_vec_bit_maybe  l r = ( map_option (subs_vec_bool l) (bool_of_bitU r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition subs_vec_bit_fail  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> subs_vec_bit_fail   l r = ( bool_of_bitU_fail r \<bind> ((\<lambda> r .  return (subs_vec_bool l r))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition subs_vec_bit_nondet  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> subs_vec_bit_nondet l r = ( bool_of_bitU_nondet r \<bind> ((\<lambda> r .  return (subs_vec_bool l r))))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "

definition subs_vec_bit  :: \<open>('a::len)Word.word \<Rightarrow> bitU \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> subs_vec_bit        l r = ( maybe_failwith (subs_vec_bit_maybe  l r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " bitU "


\<comment> \<open>\<open> TODO
val maybe_mword_of_bits_overflow : forall 'a. Size 'a => (list bitU * bitU * bitU) -> maybe (mword 'a * bitU * bitU)
let maybe_mword_of_bits_overflow (bits, overflow, carry) =
  Maybe.map (fun w -> (w, overflow, carry)) (of_bits bits)

val add_overflow_vec   : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a * bitU * bitU)
val adds_overflow_vec  : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a * bitU * bitU)
val sub_overflow_vec   : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a * bitU * bitU)
val subs_overflow_vec  : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a * bitU * bitU)
val mult_overflow_vec  : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a * bitU * bitU)
val mults_overflow_vec : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a * bitU * bitU)
let add_overflow_vec   l r = maybe_mword_of_bits_overflow (add_overflow_bv l r)
let adds_overflow_vec  l r = maybe_mword_of_bits_overflow (adds_overflow_bv l r)
let sub_overflow_vec   l r = maybe_mword_of_bits_overflow (sub_overflow_bv l r)
let subs_overflow_vec  l r = maybe_mword_of_bits_overflow (subs_overflow_bv l r)
let mult_overflow_vec  l r = maybe_mword_of_bits_overflow (mult_overflow_bv l r)
let mults_overflow_vec l r = maybe_mword_of_bits_overflow (mults_overflow_bv l r)

val add_overflow_vec_bit         : forall 'a. Size 'a => mword 'a -> bitU -> (mword 'a * bitU * bitU)
val add_overflow_vec_bit_signed  : forall 'a. Size 'a => mword 'a -> bitU -> (mword 'a * bitU * bitU)
val sub_overflow_vec_bit         : forall 'a. Size 'a => mword 'a -> bitU -> (mword 'a * bitU * bitU)
val sub_overflow_vec_bit_signed  : forall 'a. Size 'a => mword 'a -> bitU -> (mword 'a * bitU * bitU)
let add_overflow_vec_bit         = add_overflow_bv_bit
let add_overflow_vec_bit_signed  = add_overflow_bv_bit_signed
let sub_overflow_vec_bit         = sub_overflow_bv_bit
let sub_overflow_vec_bit_signed  = sub_overflow_bv_bit_signed\<close>\<close>

\<comment> \<open>\<open>val shiftl       : forall 'a. Size 'a => mword 'a -> integer -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val shiftr       : forall 'a. Size 'a => mword 'a -> integer -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val arith_shiftr : forall 'a. Size 'a => mword 'a -> integer -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val rotl         : forall 'a. Size 'a => mword 'a -> integer -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val rotr         : forall 'a. Size 'a => mword 'a -> integer -> mword 'a\<close>\<close>
definition shiftl  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>        where 
     \<open> shiftl       = ( shiftl_mword )\<close>

definition shiftr  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>        where 
     \<open> shiftr       = ( shiftr_mword )\<close>

definition arith_shiftr  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> arith_shiftr = ( arith_shiftr_mword )\<close>

definition rotl  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>          where 
     \<open> rotl         = ( rotl_mword )\<close>

definition rotr  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>          where 
     \<open> rotr         = ( rotr_mword )\<close>


\<comment> \<open>\<open>val mod_vec        : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val mod_vec_maybe  : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a)\<close>\<close>
\<comment> \<open>\<open>val mod_vec_fail   : forall 'rv 'a 'e. Size 'a => mword 'a -> mword 'a -> monad 'rv (mword 'a) 'e\<close>\<close>
\<comment> \<open>\<open>val mod_vec_nondet : forall 'rv 'a 'e. Size 'a => mword 'a -> mword 'a -> monad 'rv (mword 'a) 'e\<close>\<close>
definition mod_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> mod_vec        l r = ( mod_mword l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition mod_vec_maybe  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> mod_vec_maybe  l r = ( mod_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition mod_vec_fail  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> mod_vec_fail   l r = ( maybe_fail (''mod_vec'') (mod_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition mod_vec_nondet  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> mod_vec_nondet l r = (
  (case  (mod_bv instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r) of
      Some w => return w
    | None => mword_nondet () 
  ))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "


\<comment> \<open>\<open>val quot_vec        : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val quot_vec_maybe  : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a)\<close>\<close>
\<comment> \<open>\<open>val quot_vec_fail   : forall 'rv 'a 'e. Size 'a => mword 'a -> mword 'a -> monad 'rv (mword 'a) 'e\<close>\<close>
\<comment> \<open>\<open>val quot_vec_nondet : forall 'rv 'a 'e. Size 'a => mword 'a -> mword 'a -> monad 'rv (mword 'a) 'e\<close>\<close>
definition quot_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> quot_vec        l r = ( quot_mword l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition quot_vec_maybe  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> quot_vec_maybe  l r = ( quot_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition quot_vec_fail  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> quot_vec_fail   l r = ( maybe_fail (''quot_vec'') (quot_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition quot_vec_nondet  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> quot_vec_nondet l r = (
  (case  (quot_bv instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r) of
      Some w => return w
    | None => mword_nondet () 
  ))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "


\<comment> \<open>\<open>val quots_vec        : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val quots_vec_maybe  : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a)\<close>\<close>
\<comment> \<open>\<open>val quots_vec_fail   : forall 'rv 'a 'e. Size 'a => mword 'a -> mword 'a -> monad 'rv (mword 'a) 'e\<close>\<close>
\<comment> \<open>\<open>val quots_vec_nondet : forall 'rv 'a 'e. Size 'a => mword 'a -> mword 'a -> monad 'rv (mword 'a) 'e\<close>\<close>
definition quots_vec  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> quots_vec        l r = ( quots_mword l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition quots_vec_maybe  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> quots_vec_maybe  l r = ( quots_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition quots_vec_fail  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> quots_vec_fail   l r = ( maybe_fail (''quots_vec'') (quots_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "

definition quots_vec_nondet  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> quots_vec_nondet l r = (
  (case  (quots_bv instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r) of
      Some w => return w
    | None => mword_nondet () 
  ))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: "('a::len)Word.word "


\<comment> \<open>\<open>val mod_vec_int        : forall 'a. Size 'a => mword 'a -> integer -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val mod_vec_int_maybe  : forall 'a. Size 'a => mword 'a -> integer -> maybe (mword 'a)\<close>\<close>
\<comment> \<open>\<open>val mod_vec_int_fail   : forall 'rv 'a 'e. Size 'a => mword 'a -> integer -> monad 'rv (mword 'a) 'e\<close>\<close>
\<comment> \<open>\<open>val mod_vec_int_nondet : forall 'rv 'a 'e. Size 'a => mword 'a -> integer -> monad 'rv (mword 'a) 'e\<close>\<close>
definition mod_vec_int  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> mod_vec_int        l r = ( mod_mword_int l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "

definition mod_vec_int_maybe  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> mod_vec_int_maybe  l r = ( mod_bv_int 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "

definition mod_vec_int_fail  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> mod_vec_int_fail   l r = ( maybe_fail (''mod_vec_int'') (mod_bv_int 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "

definition mod_vec_int_nondet  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> mod_vec_int_nondet l r = (
  (case  (mod_bv_int instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r) of
      Some w => return w
    | None => mword_nondet () 
  ))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "


\<comment> \<open>\<open>val quot_vec_int        : forall 'a. Size 'a => mword 'a -> integer -> mword 'a\<close>\<close>
\<comment> \<open>\<open>val quot_vec_int_maybe  : forall 'a. Size 'a => mword 'a -> integer -> maybe (mword 'a)\<close>\<close>
\<comment> \<open>\<open>val quot_vec_int_fail   : forall 'rv 'a 'e. Size 'a => mword 'a -> integer -> monad 'rv (mword 'a) 'e\<close>\<close>
\<comment> \<open>\<open>val quot_vec_int_nondet : forall 'rv 'a 'e. Size 'a => mword 'a -> integer -> monad 'rv (mword 'a) 'e\<close>\<close>
definition quot_vec_int  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> quot_vec_int        l r = ( quot_mword_int l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "

definition quot_vec_int_maybe  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> quot_vec_int_maybe  l r = ( quot_bv_int 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r )\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "

definition quot_vec_int_fail  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> quot_vec_int_fail   l r = ( maybe_fail (''quot_vec_int'') (quot_bv_int 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "

definition quot_vec_int_nondet  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> quot_vec_int_nondet l r = (
  (case  (quot_bv_int 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict l r) of
      Some w => return w
    | None => mword_nondet () 
  ))\<close> 
  for  l  :: "('a::len)Word.word " 
  and  r  :: " int "


\<comment> \<open>\<open>val replicate_bits : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b\<close>\<close>
definition replicate_bits  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> replicate_bits v count1 = ( Word.of_bl (repeat (Word.to_bl v) count1))\<close> 
  for  v  :: "('a::len)Word.word " 
  and  count1  :: " int "


\<comment> \<open>\<open>val duplicate_bool : forall 'a. Size 'a => bool -> integer -> mword 'a\<close>\<close>
definition duplicate_bool  :: \<open> bool \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> duplicate_bool   b n = ( Word.of_bl (repeat [b] n))\<close> 
  for  b  :: " bool " 
  and  n  :: " int "

definition duplicate_maybe  :: \<open> bitU \<Rightarrow> int \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> duplicate_maybe  b n = ( map_option ((\<lambda> b .  duplicate_bool b n)) (bool_of_bitU b))\<close> 
  for  b  :: " bitU " 
  and  n  :: " int "

definition duplicate_fail  :: \<open> bitU \<Rightarrow> int \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> duplicate_fail   b n = ( bool_of_bitU_fail b \<bind> ((\<lambda> b .  return (duplicate_bool b n))))\<close> 
  for  b  :: " bitU " 
  and  n  :: " int "

definition duplicate_nondet  :: \<open> bitU \<Rightarrow> int \<Rightarrow>('c,(('a::len)Word.word),'b)monad \<close>  where 
     \<open> duplicate_nondet b n = ( bool_of_bitU_nondet b \<bind> ((\<lambda> b .  return (duplicate_bool b n))))\<close> 
  for  b  :: " bitU " 
  and  n  :: " int "

definition duplicate  :: \<open> bitU \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> duplicate        b n = ( maybe_failwith (duplicate_maybe b n))\<close> 
  for  b  :: " bitU " 
  and  n  :: " int "


\<comment> \<open>\<open>val reverse_endianness : forall 'a. Size 'a => mword 'a -> mword 'a\<close>\<close>
definition reverse_endianness  :: \<open>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> reverse_endianness v = ( Word.of_bl (reverse_endianness_list (Word.to_bl v)))\<close> 
  for  v  :: "('a::len)Word.word "


\<comment> \<open>\<open>val get_slice_int : forall 'a. Size 'a => integer -> integer -> integer -> mword 'a\<close>\<close>
definition get_slice_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> get_slice_int = ( 
  get_slice_int_bv instance_Sail2_values_Bitvector_Machine_word_mword_dict )\<close>


\<comment> \<open>\<open>val set_slice_int : forall 'a. Size 'a => integer -> integer -> integer -> mword 'a -> integer\<close>\<close>
definition set_slice_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<close>  where 
     \<open> set_slice_int = ( 
  set_slice_int_bv instance_Sail2_values_Bitvector_Machine_word_mword_dict )\<close>


\<comment> \<open>\<open>val slice : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b\<close>\<close>
definition slice  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> slice v lo len = (
  subrange_vec_dec v ((lo + len) -( 1 :: int)) lo )\<close> 
  for  v  :: "('a::len)Word.word " 
  and  lo  :: " int " 
  and  len  :: " int "


\<comment> \<open>\<open>val set_slice : forall 'a 'b. Size 'a, Size 'b => integer -> integer -> mword 'a -> integer -> mword 'b -> mword 'a\<close>\<close>
definition set_slice  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> set_slice (out_len::ii) (slice_len::ii) out (n::ii) v = (
  update_subrange_vec_dec out ((n + slice_len) -( 1 :: int)) n v )\<close> 
  for  out_len  :: " int " 
  and  slice_len  :: " int " 
  and  out  :: "('a::len)Word.word " 
  and  n  :: " int " 
  and  v  :: "('b::len)Word.word "


\<comment> \<open>\<open>val eq_vec    : forall 'a. Size 'a => mword 'a -> mword 'a -> bool\<close>\<close>
\<comment> \<open>\<open>val neq_vec   : forall 'a. Size 'a => mword 'a -> mword 'a -> bool\<close>\<close>

\<comment> \<open>\<open>val count_leading_zeros : forall 'a. Size 'a => mword 'a -> integer\<close>\<close>
definition count_leading_zeros  :: \<open>('a::len)Word.word \<Rightarrow> int \<close>  where 
     \<open> count_leading_zeros v = ( count_leading_zeros_bv 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict v )\<close> 
  for  v  :: "('a::len)Word.word "

end
