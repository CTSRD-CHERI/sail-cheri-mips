chapter \<open>Generated by Lem from \<open>../../src/gen_lib/sail2_prompt_monad.lem\<close>.\<close>

theory "Sail2_prompt_monad" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail2_instr_kinds"
  "Sail2_values"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail_impl_base\<close>\<close>
\<comment> \<open>\<open>open import Sail2_instr_kinds\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>

type_synonym register_name =" string "
type_synonym address =" bitU list "

datatype( 'regval, 'a, 'e) monad =
    Done " 'a "
  \<comment> \<open>\<open> Read a number of bytes from memory, returned in little endian order,
     with or without a tag.  The first nat specifies the address, the second
     the number of bytes. \<close>\<close>
  | Read_mem " read_kind " " nat " " nat " " ( memory_byte list \<Rightarrow> ('regval, 'a, 'e) monad)"
  | Read_memt " read_kind " " nat " " nat " " (( memory_byte list * bitU) \<Rightarrow> ('regval, 'a, 'e) monad)"
  \<comment> \<open>\<open> Tell the system a write is imminent, at the given address and with the
     given size. \<close>\<close>
  | Write_ea " write_kind " " nat " " nat " " ('regval, 'a, 'e) monad "
  \<comment> \<open>\<open> Request the result of store-exclusive \<close>\<close>
  | Excl_res " (bool \<Rightarrow> ('regval, 'a, 'e) monad)"
  \<comment> \<open>\<open> Request to write a memory value of the given size at the given address,
     with or without a tag. \<close>\<close>
  | Write_mem " write_kind " " nat " " nat " " memory_byte list " " (bool \<Rightarrow> ('regval, 'a, 'e) monad)"
  | Write_memt " write_kind " " nat " " nat " " memory_byte list " " bitU " " (bool \<Rightarrow> ('regval, 'a, 'e) monad)"
  \<comment> \<open>\<open> Tell the system to dynamically recalculate dependency footprint \<close>\<close>
  | Footprint " ('regval, 'a, 'e) monad "
  \<comment> \<open>\<open> Request a memory barrier \<close>\<close>
  | Barrier " barrier_kind " " ('regval, 'a, 'e) monad "
  \<comment> \<open>\<open> Request to read register, will track dependency when mode.track_values \<close>\<close>
  | Read_reg " register_name " " ('regval \<Rightarrow> ('regval, 'a, 'e) monad)"
  \<comment> \<open>\<open> Request to write register \<close>\<close>
  | Write_reg " register_name " " 'regval " " ('regval, 'a, 'e) monad "
  \<comment> \<open>\<open> Request to choose a Boolean, e.g. to resolve an undefined bit. The string
     argument may be used to provide information to the system about what the
     Boolean is going to be used for. \<close>\<close>
  | Choose " string " " (bool \<Rightarrow> ('regval, 'a, 'e) monad)"
  \<comment> \<open>\<open> Print debugging or tracing information \<close>\<close>
  | Print " string " " ('regval, 'a, 'e) monad "
  \<comment> \<open>\<open>Result of a failed assert with possible error message to report\<close>\<close>
  | Fail " string "
  \<comment> \<open>\<open> Exception of type 'e \<close>\<close>
  | Exception " 'e "

datatype 'regval event =
    E_read_mem " read_kind " " nat " " nat " " memory_byte list "
  | E_read_memt " read_kind " " nat " " nat " " ( memory_byte list * bitU)"
  | E_write_mem " write_kind " " nat " " nat " " memory_byte list " " bool "
  | E_write_memt " write_kind " " nat " " nat " " memory_byte list " " bitU " " bool "
  | E_write_ea " write_kind " " nat " " nat "
  | E_excl_res " bool "
  | E_barrier " barrier_kind "
  | E_footprint
  | E_read_reg " register_name " " 'regval "
  | E_write_reg " register_name " " 'regval "
  | E_choose " string " " bool "
  | E_print " string "

type_synonym 'regval trace =" ( 'regval event) list "

\<comment> \<open>\<open>val return : forall 'rv 'a 'e. 'a -> monad 'rv 'a 'e\<close>\<close>
definition return  :: \<open> 'a \<Rightarrow>('rv,'a,'e)monad \<close>  where 
     \<open> return a = ( Done a )\<close> 
  for  a  :: " 'a "


\<comment> \<open>\<open>val bind : forall 'rv 'a 'b 'e. monad 'rv 'a 'e -> ('a -> monad 'rv 'b 'e) -> monad 'rv 'b 'e\<close>\<close>
function (sequential,domintros)  bind  :: \<open>('rv,'a,'e)monad \<Rightarrow>('a \<Rightarrow>('rv,'b,'e)monad)\<Rightarrow>('rv,'b,'e)monad \<close>  where 
     \<open> bind (Done a) f = ( f a )\<close> 
  for  a  :: " 'a " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Read_mem rk a sz k) f = (       Read_mem rk a sz       ((\<lambda> v .  bind (k v) f)))\<close> 
  for  rk  :: " read_kind " 
  and  sz  :: " nat " 
  and  k  :: "(memory_byte)list \<Rightarrow>('rv,'a,'e)monad " 
  and  a  :: " nat " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Read_memt rk a sz k) f = (      Read_memt rk a sz      ((\<lambda> v .  bind (k v) f)))\<close> 
  for  rk  :: " read_kind " 
  and  sz  :: " nat " 
  and  k  :: "(memory_byte)list*bitU \<Rightarrow>('rv,'a,'e)monad " 
  and  a  :: " nat " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Write_mem wk a sz v k) f = (    Write_mem wk a sz v    ((\<lambda> v .  bind (k v) f)))\<close> 
  for  wk  :: " write_kind " 
  and  sz  :: " nat " 
  and  k  :: " bool \<Rightarrow>('rv,'a,'e)monad " 
  and  v  :: "(memory_byte)list " 
  and  a  :: " nat " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Write_memt wk a sz v t k) f = ( Write_memt wk a sz v t ((\<lambda> v .  bind (k v) f)))\<close> 
  for  wk  :: " write_kind " 
  and  sz  :: " nat " 
  and  k  :: " bool \<Rightarrow>('rv,'a,'e)monad " 
  and  t  :: " bitU " 
  and  v  :: "(memory_byte)list " 
  and  a  :: " nat " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Read_reg descr k) f = (         Read_reg descr         ((\<lambda> v .  bind (k v) f)))\<close> 
  for  descr  :: " string " 
  and  k  :: " 'rv \<Rightarrow>('rv,'a,'e)monad " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Excl_res k) f = (               Excl_res               ((\<lambda> v .  bind (k v) f)))\<close> 
  for  k  :: " bool \<Rightarrow>('rv,'a,'e)monad " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Choose descr k) f = (           Choose descr           ((\<lambda> v .  bind (k v) f)))\<close> 
  for  descr  :: " string " 
  and  k  :: " bool \<Rightarrow>('rv,'a,'e)monad " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Write_ea wk a sz k) f = (       Write_ea wk a sz       (bind k f))\<close> 
  for  wk  :: " write_kind " 
  and  sz  :: " nat " 
  and  k  :: "('rv,'a,'e)monad " 
  and  a  :: " nat " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Footprint k) f = (              Footprint              (bind k f))\<close> 
  for  k  :: "('rv,'a,'e)monad " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Barrier bk k) f = (             Barrier bk             (bind k f))\<close> 
  for  bk  :: " barrier_kind " 
  and  k  :: "('rv,'a,'e)monad " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Write_reg r v k) f = (          Write_reg r v          (bind k f))\<close> 
  for  k  :: "('rv,'a,'e)monad " 
  and  v  :: " 'rv " 
  and  r  :: " string " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Print msg k) f = (              Print msg              (bind k f))\<close> 
  for  k  :: "('rv,'a,'e)monad " 
  and  msg  :: " string " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Fail descr) f = (               Fail descr )\<close> 
  for  descr  :: " string " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad "
|\<open> bind (Exception e) f = (              Exception e )\<close> 
  for  e  :: " 'e " 
  and  f  :: " 'a \<Rightarrow>('rv,'b,'e)monad " 
by pat_completeness auto


\<comment> \<open>\<open>val exit : forall 'rv 'a 'e. unit -> monad 'rv 'a 'e\<close>\<close>
definition exit0  :: \<open> unit \<Rightarrow>('rv,'a,'e)monad \<close>  where 
     \<open> exit0 _ = ( Fail (''exit''))\<close>


\<comment> \<open>\<open>val choose_bool : forall 'rv 'e. string -> monad 'rv bool 'e\<close>\<close>
definition choose_bool  :: \<open> string \<Rightarrow>('rv,(bool),'e)monad \<close>  where 
     \<open> choose_bool descr = ( Choose descr return )\<close> 
  for  descr  :: " string "


\<comment> \<open>\<open>val undefined_bool : forall 'rv 'e. unit -> monad 'rv bool 'e\<close>\<close>
definition undefined_bool  :: \<open> unit \<Rightarrow>('rv,(bool),'e)monad \<close>  where 
     \<open> undefined_bool _ = ( choose_bool (''undefined_bool''))\<close>


\<comment> \<open>\<open>val assert_exp : forall 'rv 'e. bool -> string -> monad 'rv unit 'e\<close>\<close>
definition assert_exp  :: \<open> bool \<Rightarrow> string \<Rightarrow>('rv,(unit),'e)monad \<close>  where 
     \<open> assert_exp exp1 msg = ( if exp1 then Done ()  else Fail msg )\<close> 
  for  exp1  :: " bool " 
  and  msg  :: " string "


\<comment> \<open>\<open>val throw : forall 'rv 'a 'e. 'e -> monad 'rv 'a 'e\<close>\<close>
definition throw  :: \<open> 'e \<Rightarrow>('rv,'a,'e)monad \<close>  where 
     \<open> throw e = ( Exception e )\<close> 
  for  e  :: " 'e "


\<comment> \<open>\<open>val try_catch : forall 'rv 'a 'e1 'e2. monad 'rv 'a 'e1 -> ('e1 -> monad 'rv 'a 'e2) -> monad 'rv 'a 'e2\<close>\<close>
function (sequential,domintros)  try_catch  :: \<open>('rv,'a,'e1)monad \<Rightarrow>('e1 \<Rightarrow>('rv,'a,'e2)monad)\<Rightarrow>('rv,'a,'e2)monad \<close>  where 
     \<open> try_catch (Done a) h = ( Done a )\<close> 
  for  a  :: " 'a " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Read_mem rk a sz k) h = (       Read_mem rk a sz       ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  rk  :: " read_kind " 
  and  sz  :: " nat " 
  and  k  :: "(memory_byte)list \<Rightarrow>('rv,'a,'e1)monad " 
  and  a  :: " nat " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Read_memt rk a sz k) h = (      Read_memt rk a sz      ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  rk  :: " read_kind " 
  and  sz  :: " nat " 
  and  k  :: "(memory_byte)list*bitU \<Rightarrow>('rv,'a,'e1)monad " 
  and  a  :: " nat " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Write_mem wk a sz v k) h = (    Write_mem wk a sz v    ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  wk  :: " write_kind " 
  and  sz  :: " nat " 
  and  k  :: " bool \<Rightarrow>('rv,'a,'e1)monad " 
  and  v  :: "(memory_byte)list " 
  and  a  :: " nat " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Write_memt wk a sz v t k) h = ( Write_memt wk a sz v t ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  wk  :: " write_kind " 
  and  sz  :: " nat " 
  and  k  :: " bool \<Rightarrow>('rv,'a,'e1)monad " 
  and  t  :: " bitU " 
  and  v  :: "(memory_byte)list " 
  and  a  :: " nat " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Read_reg descr k) h = (         Read_reg descr         ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  descr  :: " string " 
  and  k  :: " 'rv \<Rightarrow>('rv,'a,'e1)monad " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Excl_res k) h = (               Excl_res               ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  k  :: " bool \<Rightarrow>('rv,'a,'e1)monad " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Choose descr k) h = (           Choose descr           ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  descr  :: " string " 
  and  k  :: " bool \<Rightarrow>('rv,'a,'e1)monad " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Write_ea wk a sz k) h = (       Write_ea wk a sz       (try_catch k h))\<close> 
  for  wk  :: " write_kind " 
  and  sz  :: " nat " 
  and  k  :: "('rv,'a,'e1)monad " 
  and  a  :: " nat " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Footprint k) h = (              Footprint              (try_catch k h))\<close> 
  for  k  :: "('rv,'a,'e1)monad " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Barrier bk k) h = (             Barrier bk             (try_catch k h))\<close> 
  for  bk  :: " barrier_kind " 
  and  k  :: "('rv,'a,'e1)monad " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Write_reg r v k) h = (          Write_reg r v          (try_catch k h))\<close> 
  for  k  :: "('rv,'a,'e1)monad " 
  and  v  :: " 'rv " 
  and  r  :: " string " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Print msg k) h = (              Print msg              (try_catch k h))\<close> 
  for  k  :: "('rv,'a,'e1)monad " 
  and  msg  :: " string " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Fail descr) h = (               Fail descr )\<close> 
  for  descr  :: " string " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad "
|\<open> try_catch (Exception e) h = (              h e )\<close> 
  for  e  :: " 'e1 " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,'e2)monad " 
by pat_completeness auto


\<comment> \<open>\<open> For early return, we abuse exceptions by throwing and catching
   the return value. The exception type is "either 'r 'e", where "Right e"
   represents a proper exception and "Left r" an early return of value "r". \<close>\<close>
type_synonym( 'rv, 'a, 'r, 'e) monadR =" ('rv, 'a, ( ('r, 'e)sum)) monad "

\<comment> \<open>\<open>val early_return : forall 'rv 'a 'r 'e. 'r -> monadR 'rv 'a 'r 'e\<close>\<close>
definition early_return  :: \<open> 'r \<Rightarrow>('rv,'a,(('r,'e)sum))monad \<close>  where 
     \<open> early_return r = ( throw (Inl r))\<close> 
  for  r  :: " 'r "


\<comment> \<open>\<open>val catch_early_return : forall 'rv 'a 'e. monadR 'rv 'a 'a 'e -> monad 'rv 'a 'e\<close>\<close>
definition catch_early_return  :: \<open>('rv,'a,(('a,'e)sum))monad \<Rightarrow>('rv,'a,'e)monad \<close>  where 
     \<open> catch_early_return m = (
  try_catch m
    ((\<lambda>x .  (case  x of   Inl a => return a | Inr e => throw e ))))\<close> 
  for  m  :: "('rv,'a,(('a,'e)sum))monad "


\<comment> \<open>\<open> Lift to monad with early return by wrapping exceptions \<close>\<close>
\<comment> \<open>\<open>val liftR : forall 'rv 'a 'r 'e. monad 'rv 'a 'e -> monadR 'rv 'a 'r 'e\<close>\<close>
definition liftR  :: \<open>('rv,'a,'e)monad \<Rightarrow>('rv,'a,(('r,'e)sum))monad \<close>  where 
     \<open> liftR m = ( try_catch m ((\<lambda> e .  throw (Inr e))))\<close> 
  for  m  :: "('rv,'a,'e)monad "


\<comment> \<open>\<open> Catch exceptions in the presence of early returns \<close>\<close>
\<comment> \<open>\<open>val try_catchR : forall 'rv 'a 'r 'e1 'e2. monadR 'rv 'a 'r 'e1 -> ('e1 -> monadR 'rv 'a 'r 'e2) ->  monadR 'rv 'a 'r 'e2\<close>\<close>
definition try_catchR  :: \<open>('rv,'a,(('r,'e1)sum))monad \<Rightarrow>('e1 \<Rightarrow>('rv,'a,(('r,'e2)sum))monad)\<Rightarrow>('rv,'a,(('r,'e2)sum))monad \<close>  where 
     \<open> try_catchR m h = (
  try_catch m
    ((\<lambda>x .  (case  x of   Inl r => throw (Inl r) | Inr e => h e ))))\<close> 
  for  m  :: "('rv,'a,(('r,'e1)sum))monad " 
  and  h  :: " 'e1 \<Rightarrow>('rv,'a,(('r,'e2)sum))monad "


\<comment> \<open>\<open>val maybe_fail : forall 'rv 'a 'e. string -> maybe 'a -> monad 'rv 'a 'e\<close>\<close>
definition maybe_fail  :: \<open> string \<Rightarrow> 'a option \<Rightarrow>('rv,'a,'e)monad \<close>  where 
     \<open> maybe_fail msg = ( (\<lambda>x .  
  (case  x of   Some a => return a | None => Fail msg )))\<close> 
  for  msg  :: " string "


\<comment> \<open>\<open>val read_memt_bytes : forall 'rv 'a 'b 'e. Bitvector 'a, Bitvector 'b => read_kind -> 'a -> integer -> monad 'rv (list memory_byte * bitU) 'e\<close>\<close>
definition read_memt_bytes  :: \<open> 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> read_kind \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>('rv,((memory_byte)list*bitU),'e)monad \<close>  where 
     \<open> read_memt_bytes dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b rk addr sz = (
  bind
    (maybe_fail (''nat_of_bv'') (nat_of_bv 
  dict_Sail2_values_Bitvector_a addr))
    ((\<lambda> addr .  Read_memt rk addr (nat_of_int sz) return)))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  rk  :: " read_kind " 
  and  addr  :: " 'a " 
  and  sz  :: " int "


\<comment> \<open>\<open>val read_memt : forall 'rv 'a 'b 'e. Bitvector 'a, Bitvector 'b => read_kind -> 'a -> integer -> monad 'rv ('b * bitU) 'e\<close>\<close>
definition read_memt  :: \<open> 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> read_kind \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>('rv,('b*bitU),'e)monad \<close>  where 
     \<open> read_memt dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b rk addr sz = (
  bind
    (read_memt_bytes dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_a rk addr sz)
    ( (\<lambda>x .  (case  x of
     (bytes, tag) =>
 (case (of_bits_method   dict_Sail2_values_Bitvector_b)
         (bits_of_mem_bytes bytes) of
       Some v => return (v, tag)
   | None => Fail (''bits_of_mem_bytes'')
 )
 ))))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  rk  :: " read_kind " 
  and  addr  :: " 'a " 
  and  sz  :: " int "


\<comment> \<open>\<open>val read_mem_bytes : forall 'rv 'a 'b 'e. Bitvector 'a, Bitvector 'b => read_kind -> 'a -> integer -> monad 'rv (list memory_byte) 'e\<close>\<close>
definition read_mem_bytes  :: \<open> 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> read_kind \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>('rv,((memory_byte)list),'e)monad \<close>  where 
     \<open> read_mem_bytes dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b rk addr sz = (
  bind
    (maybe_fail (''nat_of_bv'') (nat_of_bv 
  dict_Sail2_values_Bitvector_a addr))
    ((\<lambda> addr .  Read_mem rk addr (nat_of_int sz) return)))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  rk  :: " read_kind " 
  and  addr  :: " 'a " 
  and  sz  :: " int "


\<comment> \<open>\<open>val read_mem : forall 'rv 'a 'b 'e 'addrsize. Bitvector 'a, Bitvector 'b => read_kind -> 'addrsize -> 'a -> integer -> monad 'rv 'b 'e\<close>\<close>
definition read_mem  :: \<open> 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> read_kind \<Rightarrow> 'addrsize \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>('rv,'b,'e)monad \<close>  where 
     \<open> read_mem dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b rk addr_sz addr sz = (
  bind
    (read_mem_bytes dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_a rk addr sz)
    ((\<lambda> bytes . 
       (case  (of_bits_method   dict_Sail2_values_Bitvector_b) (bits_of_mem_bytes bytes) of
           Some v => return v
         | None => Fail (''bits_of_mem_bytes'')
       ))))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  rk  :: " read_kind " 
  and  addr_sz  :: " 'addrsize " 
  and  addr  :: " 'a " 
  and  sz  :: " int "


\<comment> \<open>\<open>val excl_result : forall 'rv 'e. unit -> monad 'rv bool 'e\<close>\<close>
definition excl_result  :: \<open> unit \<Rightarrow>('rv,(bool),'e)monad \<close>  where 
     \<open> excl_result _ = ( 
  (let k = ((\<lambda> successful .  (return successful))) in Excl_res k) )\<close>


\<comment> \<open>\<open>val write_mem_ea : forall 'rv 'a 'e 'addrsize. Bitvector 'a => write_kind -> 'addrsize -> 'a -> integer -> monad 'rv unit 'e\<close>\<close>
definition write_mem_ea  :: \<open> 'a Bitvector_class \<Rightarrow> write_kind \<Rightarrow> 'addrsize \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>('rv,(unit),'e)monad \<close>  where 
     \<open> write_mem_ea dict_Sail2_values_Bitvector_a wk addr_size addr sz = (
  bind
    (maybe_fail (''nat_of_bv'') (nat_of_bv 
  dict_Sail2_values_Bitvector_a addr))
    ((\<lambda> addr .  Write_ea wk addr (nat_of_int sz) (Done () ))))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  wk  :: " write_kind " 
  and  addr_size  :: " 'addrsize " 
  and  addr  :: " 'a " 
  and  sz  :: " int "


\<comment> \<open>\<open>val write_mem : forall 'rv 'a 'b 'e 'addrsize. Bitvector 'a, Bitvector 'b =>
  write_kind -> 'addrsize -> 'a -> integer -> 'b -> monad 'rv bool 'e\<close>\<close>
definition write_mem  :: \<open> 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> write_kind \<Rightarrow> 'addrsize \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> 'b \<Rightarrow>('rv,(bool),'e)monad \<close>  where 
     \<open> write_mem dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b wk addr_size addr sz v = (
  (case  (mem_bytes_of_bits 
  dict_Sail2_values_Bitvector_b v, nat_of_bv dict_Sail2_values_Bitvector_a addr) of
      (Some v, Some addr) =>
       Write_mem wk addr (nat_of_int sz) v return
    | _ => Fail (''write_mem'')
  ))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  wk  :: " write_kind " 
  and  addr_size  :: " 'addrsize " 
  and  addr  :: " 'a " 
  and  sz  :: " int " 
  and  v  :: " 'b "


\<comment> \<open>\<open>val write_memt : forall 'rv 'a 'b 'e. Bitvector 'a, Bitvector 'b =>
  write_kind -> 'a -> integer -> 'b -> bitU -> monad 'rv bool 'e\<close>\<close>
definition write_memt  :: \<open> 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> write_kind \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> 'b \<Rightarrow> bitU \<Rightarrow>('rv,(bool),'e)monad \<close>  where 
     \<open> write_memt dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b wk addr sz v tag = (
  (case  (mem_bytes_of_bits 
  dict_Sail2_values_Bitvector_b v, nat_of_bv dict_Sail2_values_Bitvector_a addr) of
      (Some v, Some addr) =>
       Write_memt wk addr (nat_of_int sz) v tag return
    | _ => Fail (''write_mem'')
  ))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  wk  :: " write_kind " 
  and  addr  :: " 'a " 
  and  sz  :: " int " 
  and  v  :: " 'b " 
  and  tag  :: " bitU "


\<comment> \<open>\<open>val read_reg : forall 's 'rv 'a 'e. register_ref 's 'rv 'a -> monad 'rv 'a 'e\<close>\<close>
definition read_reg  :: \<open>('s,'rv,'a)register_ref \<Rightarrow>('rv,'a,'e)monad \<close>  where 
     \<open> read_reg reg = ( 
  (let k = ((\<lambda> v . 
            (case (of_regval   reg) v of
                  Some v => Done v
              | None => Fail (''read_reg: unrecognised value'')
            ))) in Read_reg (name   reg) k) )\<close> 
  for  reg  :: "('s,'rv,'a)register_ref "


\<comment> \<open>\<open>val write_reg : forall 's 'rv 'a 'e. register_ref 's 'rv 'a -> 'a -> monad 'rv unit 'e\<close>\<close>
definition write_reg  :: \<open>('s,'rv,'a)register_ref \<Rightarrow> 'a \<Rightarrow>('rv,(unit),'e)monad \<close>  where 
     \<open> write_reg reg v = ( Write_reg(name   reg) ((regval_of   reg) v) (Done () ))\<close> 
  for  reg  :: "('s,'rv,'a)register_ref " 
  and  v  :: " 'a "


\<comment> \<open>\<open> TODO
let write_reg reg v =
  write_reg_aux (external_reg_whole reg) v
let write_reg_range reg i j v =
  write_reg_aux (external_reg_slice reg (nat_of_int i,nat_of_int j)) v
let write_reg_pos reg i v =
  let iN = nat_of_int i in
  write_reg_aux (external_reg_slice reg (iN,iN)) [v]
let write_reg_bit = write_reg_pos
let write_reg_field reg regfield v =
  write_reg_aux (external_reg_field_whole reg regfield.field_name) v
let write_reg_field_bit reg regfield bit =
  write_reg_aux (external_reg_field_whole reg regfield.field_name)
                (Vector [bit] 0 (is_inc_of_reg reg))
let write_reg_field_range reg regfield i j v =
  write_reg_aux (external_reg_field_slice reg regfield.field_name (nat_of_int i,nat_of_int j)) v
let write_reg_field_pos reg regfield i v =
  write_reg_field_range reg regfield i i [v]
let write_reg_field_bit = write_reg_field_pos\<close>\<close>

\<comment> \<open>\<open>val barrier : forall 'rv 'e. barrier_kind -> monad 'rv unit 'e\<close>\<close>
definition barrier  :: \<open> barrier_kind \<Rightarrow>('rv,(unit),'e)monad \<close>  where 
     \<open> barrier bk = ( Barrier bk (Done () ))\<close> 
  for  bk  :: " barrier_kind "


\<comment> \<open>\<open>val footprint : forall 'rv 'e. unit -> monad 'rv unit 'e\<close>\<close>
definition footprint  :: \<open> unit \<Rightarrow>('rv,(unit),'e)monad \<close>  where 
     \<open> footprint _ = ( Footprint (Done () ))\<close>


\<comment> \<open>\<open> Event traces \<close>\<close>

\<comment> \<open>\<open>val emitEvent : forall 'regval 'a 'e. Eq 'regval => monad 'regval 'a 'e -> event 'regval -> maybe (monad 'regval 'a 'e)\<close>\<close>
definition emitEvent  :: \<open>('regval,'a,'e)monad \<Rightarrow> 'regval event \<Rightarrow>(('regval,'a,'e)monad)option \<close>  where 
     \<open> emitEvent m e = ( (case  (e, m) of
    (E_read_mem rk a sz v, Read_mem rk' a' sz' k) =>
     if (rk' = rk) \<and> ((a' = a) \<and> (sz' = sz)) then Some (k v) else None
  | (E_read_memt rk a sz vt, Read_memt rk' a' sz' k) =>
     if (rk' = rk) \<and> ((a' = a) \<and> (sz' = sz)) then Some (k vt) else None
  | (E_write_mem wk a sz v r, Write_mem wk' a' sz' v' k) =>
     if (wk' = wk) \<and> ((a' = a) \<and> ((sz' = sz) \<and> (v' = v))) then Some (k r) else None
  | (E_write_memt wk a sz v tag r, Write_memt wk' a' sz' v' tag' k) =>
     if (wk' = wk) \<and> ((a' = a) \<and> ((sz' = sz) \<and> ((v' = v) \<and> (tag' = tag)))) then Some (k r) else None
  | (E_read_reg r v, Read_reg r' k) =>
     if r' = r then Some (k v) else None
  | (E_write_reg r v, Write_reg r' v' k) =>
     if (r' = r) \<and> (v' = v) then Some k else None
  | (E_write_ea wk a sz, Write_ea wk' a' sz' k) =>
     if (wk' = wk) \<and> ((a' = a) \<and> (sz' = sz)) then Some k else None
  | (E_barrier bk, Barrier bk' k) =>
     if bk' = bk then Some k else None
  | (E_print m, Print m' k) =>
     if m' = m then Some k else None
  | (E_excl_res v, Excl_res k) => Some (k v)
  | (E_choose descr v, Choose descr' k) => if descr' = descr then Some (k v) else None
  | (E_footprint, Footprint k) => Some k
  | _ => None
))\<close> 
  for  m  :: "('regval,'a,'e)monad " 
  and  e  :: " 'regval event "


\<comment> \<open>\<open>val runTrace : forall 'regval 'a 'e. Eq 'regval => trace 'regval -> monad 'regval 'a 'e -> maybe (monad 'regval 'a 'e)\<close>\<close>
fun  runTrace  :: \<open>('regval event)list \<Rightarrow>('regval,'a,'e)monad \<Rightarrow>(('regval,'a,'e)monad)option \<close>  where 
     \<open> runTrace ([]) m = ( Some m )\<close> 
  for  m  :: "('regval,'a,'e)monad "
|\<open> runTrace (e # t') m = ( Option.bind (emitEvent m e) (runTrace t'))\<close> 
  for  t'  :: "('regval event)list " 
  and  e  :: " 'regval event " 
  and  m  :: "('regval,'a,'e)monad "


\<comment> \<open>\<open>val final : forall 'regval 'a 'e. monad 'regval 'a 'e -> bool\<close>\<close>
definition final  :: \<open>('regval,'a,'e)monad \<Rightarrow> bool \<close>  where 
     \<open> final = ( (\<lambda>x .  
  (case  x of
        Done _ => True
    | Fail _ => True
    | Exception _ => True
    | _ => False
  )))\<close>


\<comment> \<open>\<open>val hasTrace : forall 'regval 'a 'e. Eq 'regval => trace 'regval -> monad 'regval 'a 'e -> bool\<close>\<close>
definition hasTrace  :: \<open>('regval event)list \<Rightarrow>('regval,'a,'e)monad \<Rightarrow> bool \<close>  where 
     \<open> hasTrace t m = ( (case  runTrace t m of
    Some m => final m
  | None => False
))\<close> 
  for  t  :: "('regval event)list " 
  and  m  :: "('regval,'a,'e)monad "


\<comment> \<open>\<open>val hasException : forall 'regval 'a 'e. Eq 'regval => trace 'regval -> monad 'regval 'a 'e -> bool\<close>\<close>
definition hasException  :: \<open>('regval event)list \<Rightarrow>('regval,'a,'e)monad \<Rightarrow> bool \<close>  where 
     \<open> hasException t m = ( (case  runTrace t m of
    Some (Exception _) => True
  | _ => False
))\<close> 
  for  t  :: "('regval event)list " 
  and  m  :: "('regval,'a,'e)monad "


\<comment> \<open>\<open>val hasFailure : forall 'regval 'a 'e. Eq 'regval => trace 'regval -> monad 'regval 'a 'e -> bool\<close>\<close>
definition hasFailure  :: \<open>('regval event)list \<Rightarrow>('regval,'a,'e)monad \<Rightarrow> bool \<close>  where 
     \<open> hasFailure t m = ( (case  runTrace t m of
    Some (Fail _) => True
  | _ => False
))\<close> 
  for  t  :: "('regval event)list " 
  and  m  :: "('regval,'a,'e)monad "


\<comment> \<open>\<open> Define a type synonym that also takes the register state as a type parameter,
   in order to make switching to the state monad without changing generated
   definitions easier, see also lib/hol/prompt_monad.lem. \<close>\<close>

type_synonym( 'regval, 'regstate, 'a, 'e) base_monad =" ('regval, 'a, 'e) monad "
type_synonym( 'regval, 'regstate, 'a, 'r, 'e) base_monadR =" ('regval, 'a, 'r, 'e) monadR "
end
