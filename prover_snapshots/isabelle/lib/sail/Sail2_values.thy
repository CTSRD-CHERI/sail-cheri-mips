chapter \<open>Generated by Lem from \<open>../../src/gen_lib/sail2_values.lem\<close>.\<close>

theory "Sail2_values" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "LEM.Lem_machine_word"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Machine_word\<close>\<close>
\<comment> \<open>\<open>open import Sail_impl_base\<close>\<close>


type_synonym ii =" int "
type_synonym nn =" nat "

\<comment> \<open>\<open>val nat_of_int : integer -> nat\<close>\<close>
definition nat_of_int  :: \<open> int \<Rightarrow> nat \<close>  where 
     \<open> nat_of_int i = ( if i <( 0 :: int) then( 0 :: nat) else nat (abs ( i)))\<close> 
  for  i  :: " int "


\<comment> \<open>\<open>val pow : integer -> integer -> integer\<close>\<close>
definition pow  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> pow m n = ( m ^ (nat_of_int n))\<close> 
  for  m  :: " int " 
  and  n  :: " int "


definition pow2  :: \<open> int \<Rightarrow> int \<close>  where 
     \<open> pow2 n = ( pow(( 2 :: int)) n )\<close> 
  for  n  :: " int "


\<comment> \<open>\<open>val eq : forall 'a. Eq 'a => 'a -> 'a -> bool\<close>\<close>

\<comment> \<open>\<open>val neq : forall 'a. Eq 'a => 'a -> 'a -> bool\<close>\<close>

\<comment> \<open>\<open>val print_endline : string -> unit\<close>\<close>
definition print_endline  :: \<open> string \<Rightarrow> unit \<close>  where 
     \<open> print_endline _ = ( ()  )\<close>


\<comment> \<open>\<open>val print : string -> unit\<close>\<close>
definition print  :: \<open> string \<Rightarrow> unit \<close>  where 
     \<open> print _ = ( ()  )\<close>


\<comment> \<open>\<open>val prerr_endline : string -> unit\<close>\<close>
definition prerr_endline  :: \<open> string \<Rightarrow> unit \<close>  where 
     \<open> prerr_endline _ = ( ()  )\<close>


definition prerr  :: \<open> string \<Rightarrow> unit \<close>  where 
     \<open> prerr x = ( prerr_endline x )\<close> 
  for  x  :: " string "


\<comment> \<open>\<open>val print_int : string -> integer -> unit\<close>\<close>
definition print_int  :: \<open> string \<Rightarrow> int \<Rightarrow> unit \<close>  where 
     \<open> print_int msg i = ( print_endline (msg @ (stringFromInteger i)))\<close> 
  for  msg  :: " string " 
  and  i  :: " int "


\<comment> \<open>\<open>val prerr_int : string -> integer -> unit\<close>\<close>
definition prerr_int  :: \<open> string \<Rightarrow> int \<Rightarrow> unit \<close>  where 
     \<open> prerr_int msg i = ( prerr_endline (msg @ (stringFromInteger i)))\<close> 
  for  msg  :: " string " 
  and  i  :: " int "


\<comment> \<open>\<open>val putchar : integer -> unit\<close>\<close>
definition putchar  :: \<open> int \<Rightarrow> unit \<close>  where 
     \<open> putchar _ = ( ()  )\<close>


\<comment> \<open>\<open>val shr_int : ii -> ii -> ii\<close>\<close>
function (sequential,domintros)  shr_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> shr_int x s = ( if s >( 0 :: int) then shr_int (x div( 2 :: int)) (s -( 1 :: int)) else x )\<close> 
  for  x  :: " int " 
  and  s  :: " int " 
by pat_completeness auto


\<comment> \<open>\<open>val shl_int : integer -> integer -> integer\<close>\<close>
function (sequential,domintros)  shl_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> shl_int i shift = ( if shift >( 0 :: int) then( 2 :: int) * shl_int i (shift -( 1 :: int)) else i )\<close> 
  for  i  :: " int " 
  and  shift  :: " int " 
by pat_completeness auto

definition take_list  :: \<open> int \<Rightarrow> 'a list \<Rightarrow> 'a list \<close>  where 
     \<open> take_list n xs = ( List.take (nat_of_int n) xs )\<close> 
  for  n  :: " int " 
  and  xs  :: " 'a list "

definition drop_list  :: \<open> int \<Rightarrow> 'a list \<Rightarrow> 'a list \<close>  where 
     \<open> drop_list n xs = ( List.drop (nat_of_int n) xs )\<close> 
  for  n  :: " int " 
  and  xs  :: " 'a list "


\<comment> \<open>\<open>val repeat : forall 'a. list 'a -> integer -> list 'a\<close>\<close>
fun  repeat  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> 'a list \<close>  where 
     \<open> repeat xs n = (
  if n \<le>( 0 :: int) then []
  else xs @ repeat xs (n-( 1 :: int)))\<close> 
  for  xs  :: " 'a list " 
  and  n  :: " int "


definition duplicate_to_list  :: \<open> 'a \<Rightarrow> int \<Rightarrow> 'a list \<close>  where 
     \<open> duplicate_to_list bit length1 = ( repeat [bit] length1 )\<close> 
  for  bit  :: " 'a " 
  and  length1  :: " int "


fun  replace  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a list \<close>  where 
     \<open> replace ([]) (n :: int) b' = ( [])\<close> 
  for  n  :: " int " 
  and  b'  :: " 'a "
|\<open> replace (b # bs) (n :: int) b' = (
     if n =( 0 :: int) then b' # bs
              else b # replace bs (n -( 1 :: int)) b' )\<close> 
  for  bs  :: " 'a list " 
  and  b  :: " 'a " 
  and  n  :: " int " 
  and  b'  :: " 'a "


definition upper  :: \<open> 'a \<Rightarrow> 'a \<close>  where 
     \<open> upper n = ( n )\<close> 
  for  n  :: " 'a "


\<comment> \<open>\<open> Modulus operation corresponding to quot below -- result
   has sign of dividend. \<close>\<close>
definition tmod_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> tmod_int (a:: int) (b::int) = (
  (let m = ((abs a) mod (abs b)) in
  if a <( 0 :: int) then - m else m))\<close> 
  for  a  :: " int " 
  and  b  :: " int "


definition hardware_mod  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> hardware_mod = ( tmod_int )\<close>


\<comment> \<open>\<open> There are different possible answers for integer divide regarding
rounding behaviour on negative operands. Positive operands always
round down so derive the one we want (trucation towards zero) from
that \<close>\<close>
definition tdiv_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> tdiv_int (a::int) (b::int) = (
  (let q = ((abs a) div (abs b)) in
  if ((a<( 0 :: int)) \<longleftrightarrow> (b<( 0 :: int))) then
    q  \<comment> \<open>\<open> same sign -- result positive \<close>\<close>
  else
    - q))\<close> 
  for  a  :: " int " 
  and  b  :: " int "
 \<comment> \<open>\<open> different sign -- result negative \<close>\<close>

definition hardware_quot  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> hardware_quot = ( tdiv_int )\<close>


definition max_64u  :: \<open> int \<close>  where 
     \<open> max_64u = ( ((( 2 :: int))^(( 64 :: nat))) -( 1 :: int))\<close>

definition max_64  :: \<open> int \<close>   where 
     \<open> max_64  = ( ((( 2 :: int))^(( 63 :: nat))) -( 1 :: int))\<close>

definition min_64  :: \<open> int \<close>   where 
     \<open> min_64  = (( 0 :: int) - ((( 2 :: int))^(( 63 :: nat))))\<close>

definition max_32u  :: \<open> int \<close>  where 
     \<open> max_32u = ( (( 4294967295 :: int) :: int))\<close>

definition max_32  :: \<open> int \<close>   where 
     \<open> max_32  = ( (( 2147483647 :: int) :: int))\<close>

definition min_32  :: \<open> int \<close>   where 
     \<open> min_32  = ( (( 0 :: int) -( 2147483648 :: int) :: int))\<close>

definition max_8  :: \<open> int \<close>    where 
     \<open> max_8   = ( (( 127 :: int) :: int))\<close>

definition min_8  :: \<open> int \<close>    where 
     \<open> min_8   = ( (( 0 :: int) -( 128 :: int) :: int))\<close>

definition max_5  :: \<open> int \<close>    where 
     \<open> max_5   = ( (( 31 :: int) :: int))\<close>

definition min_5  :: \<open> int \<close>    where 
     \<open> min_5   = ( (( 0 :: int) -( 32 :: int) :: int))\<close>


\<comment> \<open>\<open> just_list takes a list of maybes and returns Just xs if all elements have
   a value, and Nothing if one of the elements is Nothing. \<close>\<close>
\<comment> \<open>\<open>val just_list : forall 'a. list (maybe 'a) -> maybe (list 'a)\<close>\<close>
fun  just_list  :: \<open>('a option)list \<Rightarrow>('a list)option \<close>  where 
     \<open> just_list ([]) = ( Some [])\<close>
|\<open> just_list (x # xs) = (
    (case  (x, just_list xs) of
        (Some x, Some xs) => Some (x # xs)
      | (_, _) => None
    ))\<close> 
  for  xs  :: "('a option)list " 
  and  x  :: " 'a option "


\<comment> \<open>\<open>val maybe_failwith : forall 'a. maybe 'a -> 'a\<close>\<close>
definition maybe_failwith  :: \<open> 'a option \<Rightarrow> 'a \<close>  where 
     \<open> maybe_failwith = ( (\<lambda>x .  
  (case  x of   Some a => a | None => failwith (''maybe_failwith'') )))\<close>


\<comment> \<open>\<open>** Bits \<close>\<close>
datatype bitU = B0 | B1 | BU

definition showBitU  :: \<open> bitU \<Rightarrow> string \<close>  where 
     \<open> showBitU = ( (\<lambda>x .  
  (case  x of   B0 => (''O'') | B1 => (''I'') | BU => (''U'') )))\<close>


definition bitU_char  :: \<open> bitU \<Rightarrow> char \<close>  where 
     \<open> bitU_char = ( (\<lambda>x .  
  (case  x of   B0 => (CHR ''0'') | B1 => (CHR ''1'') | BU => (CHR ''?'') )))\<close>


definition instance_Show_Show_Sail2_values_bitU_dict  :: \<open>(bitU)Show_class \<close>  where 
     \<open> instance_Show_Show_Sail2_values_bitU_dict = ((|

  show_method = showBitU |) )\<close>


\<comment> \<open>\<open>val compare_bitU : bitU -> bitU -> ordering\<close>\<close>
fun compare_bitU  :: \<open> bitU \<Rightarrow> bitU \<Rightarrow> ordering \<close>  where 
     \<open> compare_bitU BU BU = ( EQ )\<close>
|\<open> compare_bitU B0 B0 = ( EQ )\<close>
|\<open> compare_bitU B1 B1 = ( EQ )\<close>
|\<open> compare_bitU BU _ = ( LT )\<close>
|\<open> compare_bitU _ BU = ( GT )\<close>
|\<open> compare_bitU B0 _ = ( LT )\<close>
|\<open> compare_bitU _ _ = ( GT )\<close>


definition instance_Basic_classes_Ord_Sail2_values_bitU_dict  :: \<open>(bitU)Ord_class \<close>  where 
     \<open> instance_Basic_classes_Ord_Sail2_values_bitU_dict = ((|

  compare_method = compare_bitU,

  isLess_method = ((\<lambda>  l r. (compare_bitU l r) = LT)),

  isLessEqual_method = ((\<lambda> l r. (compare_bitU l r) \<noteq> GT)),

  isGreater_method = ((\<lambda>  l r. (compare_bitU l r) = GT)),

  isGreaterEqual_method = ((\<lambda> l r. (compare_bitU l r) \<noteq> LT))|) )\<close>


record 'a BitU_class=

  to_bitU_method ::" 'a \<Rightarrow> bitU " 

  of_bitU_method ::" bitU \<Rightarrow> 'a "



definition instance_Sail2_values_BitU_Sail2_values_bitU_dict  :: \<open>(bitU)BitU_class \<close>  where 
     \<open> instance_Sail2_values_BitU_Sail2_values_bitU_dict = ((|

  to_bitU_method = ((\<lambda> b. b)),

  of_bitU_method = ((\<lambda> b. b))|) )\<close>


definition bool_of_bitU  :: \<open> bitU \<Rightarrow>(bool)option \<close>  where 
     \<open> bool_of_bitU = ( (\<lambda>x .  
  (case  x of   B0 => Some False | B1 => Some True | BU => None )))\<close>


definition bitU_of_bool  :: \<open> bool \<Rightarrow> bitU \<close>  where 
     \<open> bitU_of_bool b = ( if b then B1 else B0 )\<close> 
  for  b  :: " bool "


\<comment> \<open>\<open>instance (BitU bool)
  let to_bitU = bitU_of_bool
  let of_bitU = bool_of_bitU
end\<close>\<close>

definition cast_bit_bool  :: \<open> bitU \<Rightarrow>(bool)option \<close>  where 
     \<open> cast_bit_bool = ( bool_of_bitU )\<close>


definition not_bit  :: \<open> bitU \<Rightarrow> bitU \<close>  where 
     \<open> not_bit = ( (\<lambda>x .  
  (case  x of   B1 => B0 | B0 => B1 | BU => BU )))\<close>


\<comment> \<open>\<open>val is_one : integer -> bitU\<close>\<close>
definition is_one  :: \<open> int \<Rightarrow> bitU \<close>  where 
     \<open> is_one i = (
  if i =( 1 :: int) then B1 else B0 )\<close> 
  for  i  :: " int "


\<comment> \<open>\<open>val and_bit : bitU -> bitU -> bitU\<close>\<close>
fun and_bit  :: \<open> bitU \<Rightarrow> bitU \<Rightarrow> bitU \<close>  where 
     \<open> and_bit B0 _ = ( B0 )\<close>
|\<open> and_bit _ B0 = ( B0 )\<close>
|\<open> and_bit B1 B1 = ( B1 )\<close>
|\<open> and_bit _ _ = ( BU )\<close>


\<comment> \<open>\<open>val or_bit : bitU -> bitU -> bitU\<close>\<close>
fun or_bit  :: \<open> bitU \<Rightarrow> bitU \<Rightarrow> bitU \<close>  where 
     \<open> or_bit B1 _ = ( B1 )\<close>
|\<open> or_bit _ B1 = ( B1 )\<close>
|\<open> or_bit B0 B0 = ( B0 )\<close>
|\<open> or_bit _ _ = ( BU )\<close>


\<comment> \<open>\<open>val xor_bit : bitU -> bitU -> bitU\<close>\<close>
fun xor_bit  :: \<open> bitU \<Rightarrow> bitU \<Rightarrow> bitU \<close>  where 
     \<open> xor_bit B0 B0 = ( B0 )\<close>
|\<open> xor_bit B0 B1 = ( B1 )\<close>
|\<open> xor_bit B1 B0 = ( B1 )\<close>
|\<open> xor_bit B1 B1 = ( B0 )\<close>
|\<open> xor_bit _ _ = ( BU )\<close>


\<comment> \<open>\<open>val &. : bitU -> bitU -> bitU\<close>\<close>

\<comment> \<open>\<open>val |. : bitU -> bitU -> bitU\<close>\<close>

\<comment> \<open>\<open>val +. : bitU -> bitU -> bitU\<close>\<close>


\<comment> \<open>\<open>** Bool lists **\<close>\<close>

\<comment> \<open>\<open>val bools_of_nat_aux : integer -> natural -> list bool -> list bool\<close>\<close>
fun  bools_of_nat_aux  :: \<open> int \<Rightarrow> nat \<Rightarrow>(bool)list \<Rightarrow>(bool)list \<close>  where 
     \<open> bools_of_nat_aux len x acc1 = (
  if len \<le>( 0 :: int) then acc1
  else bools_of_nat_aux (len -( 1 :: int)) (x div( 2 :: nat)) ((if (x mod( 2 :: nat)) =( 1 :: nat) then True else False) # acc1))\<close> 
  for  len  :: " int " 
  and  x  :: " nat " 
  and  acc1  :: "(bool)list "

definition bools_of_nat  :: \<open> int \<Rightarrow> nat \<Rightarrow>(bool)list \<close>  where 
     \<open> bools_of_nat len n = ( bools_of_nat_aux len n [])\<close> 
  for  len  :: " int " 
  and  n  :: " nat "
 \<comment> \<open>\<open>List.reverse (bools_of_nat_aux n)\<close>\<close>

\<comment> \<open>\<open>val nat_of_bools_aux : natural -> list bool -> natural\<close>\<close>
fun  nat_of_bools_aux  :: \<open> nat \<Rightarrow>(bool)list \<Rightarrow> nat \<close>  where 
     \<open> nat_of_bools_aux acc1 ([]) = ( acc1 )\<close> 
  for  acc1  :: " nat "
|\<open> nat_of_bools_aux acc1 (True # bs) = ( nat_of_bools_aux ((( 2 :: nat) * acc1) +( 1 :: nat)) bs )\<close> 
  for  acc1  :: " nat " 
  and  bs  :: "(bool)list "
|\<open> nat_of_bools_aux acc1 (False # bs) = ( nat_of_bools_aux (( 2 :: nat) * acc1) bs )\<close> 
  for  acc1  :: " nat " 
  and  bs  :: "(bool)list "

definition nat_of_bools  :: \<open>(bool)list \<Rightarrow> nat \<close>  where 
     \<open> nat_of_bools bs = ( nat_of_bools_aux(( 0 :: nat)) bs )\<close> 
  for  bs  :: "(bool)list "


\<comment> \<open>\<open>val unsigned_of_bools : list bool -> integer\<close>\<close>
definition unsigned_of_bools  :: \<open>(bool)list \<Rightarrow> int \<close>  where 
     \<open> unsigned_of_bools bs = ( int (nat_of_bools bs))\<close> 
  for  bs  :: "(bool)list "


\<comment> \<open>\<open>val signed_of_bools : list bool -> integer\<close>\<close>
definition signed_of_bools  :: \<open>(bool)list \<Rightarrow> int \<close>  where 
     \<open> signed_of_bools bs = (
  (case  bs of
      True # _  =>( 0 :: int) - (( 1 :: int) + (unsigned_of_bools (List.map ((\<lambda> x. \<not> x)) bs)))
    | False # _ => unsigned_of_bools bs
    | [] =>( 0 :: int) \<comment> \<open>\<open> Treat empty list as all zeros \<close>\<close>
  ))\<close> 
  for  bs  :: "(bool)list "


\<comment> \<open>\<open>val int_of_bools : bool -> list bool -> integer\<close>\<close>
definition int_of_bools  :: \<open> bool \<Rightarrow>(bool)list \<Rightarrow> int \<close>  where 
     \<open> int_of_bools sign bs = ( if sign then signed_of_bools bs else unsigned_of_bools bs )\<close> 
  for  sign  :: " bool " 
  and  bs  :: "(bool)list "


\<comment> \<open>\<open>val pad_list : forall 'a. 'a -> list 'a -> integer -> list 'a\<close>\<close>
fun  pad_list  :: \<open> 'a \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> 'a list \<close>  where 
     \<open> pad_list x xs n = (
  if n \<le>( 0 :: int) then xs else pad_list x (x # xs) (n -( 1 :: int)))\<close> 
  for  x  :: " 'a " 
  and  xs  :: " 'a list " 
  and  n  :: " int "


definition ext_list  :: \<open> 'a \<Rightarrow> int \<Rightarrow> 'a list \<Rightarrow> 'a list \<close>  where 
     \<open> ext_list pad len xs = (
  (let longer = (len - (int (List.length xs))) in
  if longer <( 0 :: int) then List.drop (nat_of_int (abs (longer))) xs
  else pad_list pad xs longer))\<close> 
  for  pad  :: " 'a " 
  and  len  :: " int " 
  and  xs  :: " 'a list "


definition extz_bools  :: \<open> int \<Rightarrow>(bool)list \<Rightarrow>(bool)list \<close>  where 
     \<open> extz_bools len bs = ( ext_list False len bs )\<close> 
  for  len  :: " int " 
  and  bs  :: "(bool)list "

definition exts_bools  :: \<open> int \<Rightarrow>(bool)list \<Rightarrow>(bool)list \<close>  where 
     \<open> exts_bools len bs = (
  (case  bs of
      True # _ => ext_list True len bs
    | _ => ext_list False len bs
  ))\<close> 
  for  len  :: " int " 
  and  bs  :: "(bool)list "


fun  add_one_bool_ignore_overflow_aux  :: \<open>(bool)list \<Rightarrow>(bool)list \<close>  where 
     \<open> add_one_bool_ignore_overflow_aux ([]) = ( [])\<close>
|\<open> add_one_bool_ignore_overflow_aux (False # bits) = ( True # bits )\<close> 
  for  bits  :: "(bool)list "
|\<open> add_one_bool_ignore_overflow_aux (True # bits) = ( False # add_one_bool_ignore_overflow_aux bits )\<close> 
  for  bits  :: "(bool)list "


definition add_one_bool_ignore_overflow  :: \<open>(bool)list \<Rightarrow>(bool)list \<close>  where 
     \<open> add_one_bool_ignore_overflow bits = (
  List.rev (add_one_bool_ignore_overflow_aux (List.rev bits)))\<close> 
  for  bits  :: "(bool)list "


\<comment> \<open>\<open>let bool_list_of_int n =
  let bs_abs = false :: bools_of_nat (naturalFromInteger (abs n)) in
  if n >= (0 : integer) then bs_abs
  else add_one_bool_ignore_overflow (List.map not bs_abs)
let bools_of_int len n = exts_bools len (bool_list_of_int n)\<close>\<close>
definition bools_of_int  :: \<open> int \<Rightarrow> int \<Rightarrow>(bool)list \<close>  where 
     \<open> bools_of_int len n = (
  (let bs_abs = (bools_of_nat len (nat (abs (abs n)))) in
  if n \<ge> (( 0 :: int) :: int) then bs_abs
  else add_one_bool_ignore_overflow (List.map ((\<lambda> x. \<not> x)) bs_abs)))\<close> 
  for  len  :: " int " 
  and  n  :: " int "


\<comment> \<open>\<open>** Bit lists **\<close>\<close>

\<comment> \<open>\<open>val has_undefined_bits : list bitU -> bool\<close>\<close>
definition has_undefined_bits  :: \<open>(bitU)list \<Rightarrow> bool \<close>  where 
     \<open> has_undefined_bits bs = ( ((\<exists> x \<in> (set bs).  ((\<lambda>x .  
  (case  x of BU => True | _ => False ))) x)))\<close> 
  for  bs  :: "(bitU)list "


definition bits_of_nat  :: \<open> int \<Rightarrow> nat \<Rightarrow>(bitU)list \<close>  where 
     \<open> bits_of_nat len n = ( List.map bitU_of_bool (bools_of_nat len n))\<close> 
  for  len  :: " int " 
  and  n  :: " nat "


definition nat_of_bits  :: \<open>(bitU)list \<Rightarrow>(nat)option \<close>  where 
     \<open> nat_of_bits bits = (
  (case  (just_list (List.map bool_of_bitU bits)) of
      Some bs => Some (nat_of_bools bs)
    | None => None
  ))\<close> 
  for  bits  :: "(bitU)list "


definition not_bits  :: \<open>(bitU)list \<Rightarrow>(bitU)list \<close>  where 
     \<open> not_bits = ( List.map not_bit )\<close>


\<comment> \<open>\<open>val binop_list : forall 'a. ('a -> 'a -> 'a) -> list 'a -> list 'a -> list 'a\<close>\<close>
definition binop_list  :: \<open>('a \<Rightarrow> 'a \<Rightarrow> 'a)\<Rightarrow> 'a list \<Rightarrow> 'a list \<Rightarrow> 'a list \<close>  where 
     \<open> binop_list op1 xs ys = (
  List.foldr ( (\<lambda>x .  
  (case  x of (x, y) => (\<lambda> acc1 .  op1 x y # acc1) ))) (List.zip xs ys) [])\<close> 
  for  op1  :: " 'a \<Rightarrow> 'a \<Rightarrow> 'a " 
  and  xs  :: " 'a list " 
  and  ys  :: " 'a list "


definition unsigned_of_bits  :: \<open>(bitU)list \<Rightarrow>(int)option \<close>  where 
     \<open> unsigned_of_bits bits = (
  (case  (just_list (List.map bool_of_bitU bits)) of
      Some bs => Some (unsigned_of_bools bs)
    | None => None
  ))\<close> 
  for  bits  :: "(bitU)list "


definition signed_of_bits  :: \<open>(bitU)list \<Rightarrow>(int)option \<close>  where 
     \<open> signed_of_bits bits = (
  (case  (just_list (List.map bool_of_bitU bits)) of
      Some bs => Some (signed_of_bools bs)
    | None => None
  ))\<close> 
  for  bits  :: "(bitU)list "


\<comment> \<open>\<open>val int_of_bits : bool -> list bitU -> maybe integer\<close>\<close>
definition int_of_bits  :: \<open> bool \<Rightarrow>(bitU)list \<Rightarrow>(int)option \<close>  where 
     \<open> int_of_bits sign bs = ( if sign then signed_of_bits bs else unsigned_of_bits bs )\<close> 
  for  sign  :: " bool " 
  and  bs  :: "(bitU)list "


definition extz_bits  :: \<open> int \<Rightarrow>(bitU)list \<Rightarrow>(bitU)list \<close>  where 
     \<open> extz_bits len bits = ( ext_list B0 len bits )\<close> 
  for  len  :: " int " 
  and  bits  :: "(bitU)list "

definition exts_bits  :: \<open> int \<Rightarrow>(bitU)list \<Rightarrow>(bitU)list \<close>  where 
     \<open> exts_bits len bits = (
  (case  bits of
    BU # _ => ext_list BU len bits
  | B1 # _ => ext_list B1 len bits
  | _ => ext_list B0 len bits
  ))\<close> 
  for  len  :: " int " 
  and  bits  :: "(bitU)list "


fun  add_one_bit_ignore_overflow_aux  :: \<open>(bitU)list \<Rightarrow>(bitU)list \<close>  where 
     \<open> add_one_bit_ignore_overflow_aux ([]) = ( [])\<close>
|\<open> add_one_bit_ignore_overflow_aux (B0 # bits) = ( B1 # bits )\<close> 
  for  bits  :: "(bitU)list "
|\<open> add_one_bit_ignore_overflow_aux (B1 # bits) = ( B0 # add_one_bit_ignore_overflow_aux bits )\<close> 
  for  bits  :: "(bitU)list "
|\<open> add_one_bit_ignore_overflow_aux (BU # bits) = ( BU # List.map ( (\<lambda>x .  
  (case  x of _ => BU ))) bits )\<close> 
  for  bits  :: "(bitU)list "


definition add_one_bit_ignore_overflow  :: \<open>(bitU)list \<Rightarrow>(bitU)list \<close>  where 
     \<open> add_one_bit_ignore_overflow bits = (
  List.rev (add_one_bit_ignore_overflow_aux (List.rev bits)))\<close> 
  for  bits  :: "(bitU)list "


\<comment> \<open>\<open>let bit_list_of_int n = List.map bitU_of_bool (bool_list_of_int n)
let bits_of_int len n = exts_bits len (bit_list_of_int n)\<close>\<close>
definition bits_of_int  :: \<open> int \<Rightarrow> int \<Rightarrow>(bitU)list \<close>  where 
     \<open> bits_of_int len n = ( List.map bitU_of_bool (bools_of_int len n))\<close> 
  for  len  :: " int " 
  and  n  :: " int "


\<comment> \<open>\<open>val arith_op_bits :
  (integer -> integer -> integer) -> bool -> list bitU -> list bitU -> list bitU\<close>\<close>
definition arith_op_bits  :: \<open>(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> bool \<Rightarrow>(bitU)list \<Rightarrow>(bitU)list \<Rightarrow>(bitU)list \<close>  where 
     \<open> arith_op_bits op1 sign l r = (
  (case  (int_of_bits sign l, int_of_bits sign r) of
      (Some li, Some ri) => bits_of_int (int (List.length l)) (op1 li ri)
    | (_, _) => repeat [BU] (int (List.length l))
  ))\<close> 
  for  op1  :: " int \<Rightarrow> int \<Rightarrow> int " 
  and  sign  :: " bool " 
  and  l  :: "(bitU)list " 
  and  r  :: "(bitU)list "


definition char_of_nibble  :: \<open> bitU*bitU*bitU*bitU \<Rightarrow>(char)option \<close>  where 
     \<open> char_of_nibble = ( (\<lambda>x .  
  (case  x of
        (B0, B0, B0, B0) => Some (CHR ''0'')
    | (B0, B0, B0, B1) => Some (CHR ''1'')
    | (B0, B0, B1, B0) => Some (CHR ''2'')
    | (B0, B0, B1, B1) => Some (CHR ''3'')
    | (B0, B1, B0, B0) => Some (CHR ''4'')
    | (B0, B1, B0, B1) => Some (CHR ''5'')
    | (B0, B1, B1, B0) => Some (CHR ''6'')
    | (B0, B1, B1, B1) => Some (CHR ''7'')
    | (B1, B0, B0, B0) => Some (CHR ''8'')
    | (B1, B0, B0, B1) => Some (CHR ''9'')
    | (B1, B0, B1, B0) => Some (CHR ''A'')
    | (B1, B0, B1, B1) => Some (CHR ''B'')
    | (B1, B1, B0, B0) => Some (CHR ''C'')
    | (B1, B1, B0, B1) => Some (CHR ''D'')
    | (B1, B1, B1, B0) => Some (CHR ''E'')
    | (B1, B1, B1, B1) => Some (CHR ''F'')
    | _ => None
  )))\<close>


definition nibble_of_char  :: \<open> char \<Rightarrow>(bitU*bitU*bitU*bitU)option \<close>  where 
     \<open> nibble_of_char = ( (\<lambda>x .  
  (case  x of
        (CHR ''0'') => Some (B0, B0, B0, B0)
    | (CHR ''1'') => Some (B0, B0, B0, B1)
    | (CHR ''2'') => Some (B0, B0, B1, B0)
    | (CHR ''3'') => Some (B0, B0, B1, B1)
    | (CHR ''4'') => Some (B0, B1, B0, B0)
    | (CHR ''5'') => Some (B0, B1, B0, B1)
    | (CHR ''6'') => Some (B0, B1, B1, B0)
    | (CHR ''7'') => Some (B0, B1, B1, B1)
    | (CHR ''8'') => Some (B1, B0, B0, B0)
    | (CHR ''9'') => Some (B1, B0, B0, B1)
    | (CHR ''A'') => Some (B1, B0, B1, B0)
    | (CHR ''B'') => Some (B1, B0, B1, B1)
    | (CHR ''C'') => Some (B1, B1, B0, B0)
    | (CHR ''D'') => Some (B1, B1, B0, B1)
    | (CHR ''E'') => Some (B1, B1, B1, B0)
    | (CHR ''F'') => Some (B1, B1, B1, B1)
    | _ => None
  )))\<close>


fun  hexstring_of_bits  :: \<open>(bitU)list \<Rightarrow>((char)list)option \<close>  where 
     \<open> hexstring_of_bits (b1 # b2 # b3 # b4 # bs) = (
     (let n = (char_of_nibble (b1, b2, b3, b4)) in
     (let s = (hexstring_of_bits bs) in
     (case  (n, s) of
       (Some n, Some s) => Some (n # s)
     | _ => None
     ))))\<close> 
  for  b4  :: " bitU " 
  and  b3  :: " bitU " 
  and  bs  :: "(bitU)list " 
  and  b1  :: " bitU " 
  and  b2  :: " bitU "
|\<open> hexstring_of_bits ([]) = ( Some [])\<close>
|\<open> hexstring_of_bits _ = ( None )\<close>


definition show_bitlist_prefix  :: \<open> char \<Rightarrow>(bitU)list \<Rightarrow> string \<close>  where 
     \<open> show_bitlist_prefix c bs = (
  (case  hexstring_of_bits bs of
    Some s => (c # ((CHR ''x'') # s))
  | None => (c # ((CHR ''b'') # List.map bitU_char bs))
  ))\<close> 
  for  c  :: " char " 
  and  bs  :: "(bitU)list "


definition show_bitlist  :: \<open>(bitU)list \<Rightarrow> string \<close>  where 
     \<open> show_bitlist bs = ( show_bitlist_prefix (CHR ''0'') bs )\<close> 
  for  bs  :: "(bitU)list "


\<comment> \<open>\<open>val hex_char : natural -> char\<close>\<close>

definition hex_char  :: \<open> nat \<Rightarrow> char \<close>  where 
     \<open> hex_char n = ( 
  if(n = ( 0 :: nat)) then (CHR ''0'') else
    (
    if(n = ( 1 :: nat)) then (CHR ''1'') else
      (
      if(n = ( 2 :: nat)) then (CHR ''2'') else
        (
        if(n = ( 3 :: nat)) then (CHR ''3'') else
          (
          if(n = ( 4 :: nat)) then (CHR ''4'') else
            (
            if(n = ( 5 :: nat)) then (CHR ''5'') else
              (
              if(n = ( 6 :: nat)) then (CHR ''6'') else
                (
                if(n = ( 7 :: nat)) then (CHR ''7'') else
                  (
                  if(n = ( 8 :: nat)) then (CHR ''8'') else
                    (
                    if(n = ( 9 :: nat)) then (CHR ''9'') else
                      (
                      if(n = ( 10 :: nat)) then (CHR ''A'') else
                        (
                        if(n = ( 11 :: nat)) then (CHR ''B'') else
                          (
                          if(n = ( 12 :: nat)) then (CHR ''C'') else
                            (
                            if(n = ( 13 :: nat)) then (CHR ''D'') else
                              (
                              if(n = ( 14 :: nat)) then (CHR ''E'') else
                                (
                                if(n = ( 15 :: nat)) then (CHR ''F'') else
                                  (failwith
                                     (''hex_char: not a hexadecimal digit''))))))))))))))))) )\<close> 
  for  n  :: " nat "


\<comment> \<open>\<open>val hex_str_aux : natural -> list char -> list char\<close>\<close>

fun  hex_str_aux  :: \<open> nat \<Rightarrow>(char)list \<Rightarrow>(char)list \<close>  where 
     \<open> hex_str_aux n acc1 = (
  if n =( 0 :: nat) then acc1 else
  hex_str_aux (n div( 16 :: nat)) (hex_char (n mod( 16 :: nat)) # acc1))\<close> 
  for  n  :: " nat " 
  and  acc1  :: "(char)list "


\<comment> \<open>\<open>val hex_str : integer -> string\<close>\<close>

definition hex_str  :: \<open> int \<Rightarrow> string \<close>  where 
     \<open> hex_str i = (
  if i <( 0 :: int) then failwith (''hex_str: negative'') else
  if i =( 0 :: int) then (''0x0'') else
  (''0x'') @ (hex_str_aux (nat (abs (abs i))) []))\<close> 
  for  i  :: " int "


\<comment> \<open>\<open>val subrange_list_inc : forall 'a. list 'a -> integer -> integer -> list 'a\<close>\<close>
definition subrange_list_inc  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list \<close>  where 
     \<open> subrange_list_inc xs i j = (
  (let (toJ,suffix0) = (split_at (nat_of_int (j +( 1 :: int))) xs) in
  (let (prefix0,fromItoJ) = (split_at (nat_of_int i) toJ) in
  fromItoJ)))\<close> 
  for  xs  :: " 'a list " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val subrange_list_dec : forall 'a. list 'a -> integer -> integer -> list 'a\<close>\<close>
definition subrange_list_dec  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list \<close>  where 
     \<open> subrange_list_dec xs i j = (
  (let top1 = ((int (List.length xs)) -( 1 :: int)) in
  subrange_list_inc xs (top1 - i) (top1 - j)))\<close> 
  for  xs  :: " 'a list " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val subrange_list : forall 'a. bool -> list 'a -> integer -> integer -> list 'a\<close>\<close>
definition subrange_list  :: \<open> bool \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list \<close>  where 
     \<open> subrange_list is_inc xs i j = ( if is_inc then subrange_list_inc xs i j else subrange_list_dec xs i j )\<close> 
  for  is_inc  :: " bool " 
  and  xs  :: " 'a list " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val update_subrange_list_inc : forall 'a. list 'a -> integer -> integer -> list 'a -> list 'a\<close>\<close>
definition update_subrange_list_inc  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list \<Rightarrow> 'a list \<close>  where 
     \<open> update_subrange_list_inc xs i j xs' = (
  (let (toJ,suffix) = (split_at (nat_of_int (j +( 1 :: int))) xs) in
  (let (prefix,fromItoJ0) = (split_at (nat_of_int i) toJ) in
  (prefix @ xs') @ suffix)))\<close> 
  for  xs  :: " 'a list " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  xs'  :: " 'a list "


\<comment> \<open>\<open>val update_subrange_list_dec : forall 'a. list 'a -> integer -> integer -> list 'a -> list 'a\<close>\<close>
definition update_subrange_list_dec  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list \<Rightarrow> 'a list \<close>  where 
     \<open> update_subrange_list_dec xs i j xs' = (
  (let top1 = ((int (List.length xs)) -( 1 :: int)) in
  update_subrange_list_inc xs (top1 - i) (top1 - j) xs'))\<close> 
  for  xs  :: " 'a list " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  xs'  :: " 'a list "


\<comment> \<open>\<open>val update_subrange_list : forall 'a. bool -> list 'a -> integer -> integer -> list 'a -> list 'a\<close>\<close>
definition update_subrange_list  :: \<open> bool \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list \<Rightarrow> 'a list \<close>  where 
     \<open> update_subrange_list is_inc xs i j xs' = (
  if is_inc then update_subrange_list_inc xs i j xs' else update_subrange_list_dec xs i j xs' )\<close> 
  for  is_inc  :: " bool " 
  and  xs  :: " 'a list " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  xs'  :: " 'a list "


\<comment> \<open>\<open>val access_list_inc : forall 'a. list 'a -> integer -> 'a\<close>\<close>
definition access_list_inc  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> 'a \<close>  where 
     \<open> access_list_inc xs n = ( List.nth xs (nat_of_int n))\<close> 
  for  xs  :: " 'a list " 
  and  n  :: " int "


\<comment> \<open>\<open>val access_list_dec : forall 'a. list 'a -> integer -> 'a\<close>\<close>
definition access_list_dec  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> 'a \<close>  where 
     \<open> access_list_dec xs n = (
  (let top1 = ((int (List.length xs)) -( 1 :: int)) in
  access_list_inc xs (top1 - n)))\<close> 
  for  xs  :: " 'a list " 
  and  n  :: " int "


\<comment> \<open>\<open>val access_list : forall 'a. bool -> list 'a -> integer -> 'a\<close>\<close>
definition access_list  :: \<open> bool \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> 'a \<close>  where 
     \<open> access_list is_inc xs n = (
  if is_inc then access_list_inc xs n else access_list_dec xs n )\<close> 
  for  is_inc  :: " bool " 
  and  xs  :: " 'a list " 
  and  n  :: " int "


\<comment> \<open>\<open>val update_list_inc : forall 'a. list 'a -> integer -> 'a -> list 'a\<close>\<close>
definition update_list_inc  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a list \<close>  where 
     \<open> update_list_inc xs n x = ( List.list_update xs (nat_of_int n) x )\<close> 
  for  xs  :: " 'a list " 
  and  n  :: " int " 
  and  x  :: " 'a "


\<comment> \<open>\<open>val update_list_dec : forall 'a. list 'a -> integer -> 'a -> list 'a\<close>\<close>
definition update_list_dec  :: \<open> 'a list \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a list \<close>  where 
     \<open> update_list_dec xs n x = (
  (let top1 = ((int (List.length xs)) -( 1 :: int)) in
  update_list_inc xs (top1 - n) x))\<close> 
  for  xs  :: " 'a list " 
  and  n  :: " int " 
  and  x  :: " 'a "


\<comment> \<open>\<open>val update_list : forall 'a. bool -> list 'a -> integer -> 'a -> list 'a\<close>\<close>
definition update_list  :: \<open> bool \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a list \<close>  where 
     \<open> update_list is_inc xs n x = (
  if is_inc then update_list_inc xs n x else update_list_dec xs n x )\<close> 
  for  is_inc  :: " bool " 
  and  xs  :: " 'a list " 
  and  n  :: " int " 
  and  x  :: " 'a "


definition extract_only_bit  :: \<open>(bitU)list \<Rightarrow> bitU \<close>  where 
     \<open> extract_only_bit = ( (\<lambda>x .  
  (case  x of   [] => BU | [e] => e | _ => BU )))\<close>


\<comment> \<open>\<open>** Machine words \<close>\<close>

\<comment> \<open>\<open>val length_mword : forall 'a. mword 'a -> integer\<close>\<close>

\<comment> \<open>\<open>val slice_mword_dec : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b\<close>\<close>
definition slice_mword_dec  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> slice_mword_dec w i j = ( Word.slice (nat_of_int i) w )\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val slice_mword_inc : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b\<close>\<close>
definition slice_mword_inc  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> slice_mword_inc w i j = (
  (let top1 = ((int (size w)) -( 1 :: int)) in
  slice_mword_dec w (top1 - i) (top1 - j)))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val slice_mword : forall 'a 'b. bool -> mword 'a -> integer -> integer -> mword 'b\<close>\<close>
definition slice_mword  :: \<open> bool \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<close>  where 
     \<open> slice_mword is_inc w i j = ( if is_inc then slice_mword_inc w i j else slice_mword_dec w i j )\<close> 
  for  is_inc  :: " bool " 
  and  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val update_slice_mword_dec : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b -> mword 'a\<close>\<close>
definition update_slice_mword_dec  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> update_slice_mword_dec w i j w' = ( Lem.word_update w (nat_of_int i) (nat_of_int j) w' )\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  w'  :: "('b::len)Word.word "


\<comment> \<open>\<open>val update_slice_mword_inc : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b -> mword 'a\<close>\<close>
definition update_slice_mword_inc  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> update_slice_mword_inc w i j w' = (
  (let top1 = ((int (size w)) -( 1 :: int)) in
  update_slice_mword_dec w (top1 - i) (top1 - j) w'))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  w'  :: "('b::len)Word.word "


\<comment> \<open>\<open>val update_slice_mword : forall 'a 'b. bool -> mword 'a -> integer -> integer -> mword 'b -> mword 'a\<close>\<close>
definition update_slice_mword  :: \<open> bool \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> update_slice_mword is_inc w i j w' = (
  if is_inc then update_slice_mword_inc w i j w' else update_slice_mword_dec w i j w' )\<close> 
  for  is_inc  :: " bool " 
  and  w  :: "('a::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  w'  :: "('b::len)Word.word "


\<comment> \<open>\<open>val access_mword_dec : forall 'a. mword 'a -> integer -> bitU\<close>\<close>
definition access_mword_dec  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<close>  where 
     \<open> access_mword_dec w n = ( bitU_of_bool (Bits.test_bit w (nat_of_int n)))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  n  :: " int "


\<comment> \<open>\<open>val access_mword_inc : forall 'a. mword 'a -> integer -> bitU\<close>\<close>
definition access_mword_inc  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<close>  where 
     \<open> access_mword_inc w n = (
  (let top1 = ((int (size w)) -( 1 :: int)) in
  access_mword_dec w (top1 - n)))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  n  :: " int "


\<comment> \<open>\<open>val access_mword : forall 'a. bool -> mword 'a -> integer -> bitU\<close>\<close>
definition access_mword  :: \<open> bool \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<close>  where 
     \<open> access_mword is_inc w n = (
  if is_inc then access_mword_inc w n else access_mword_dec w n )\<close> 
  for  is_inc  :: " bool " 
  and  w  :: "('a::len)Word.word " 
  and  n  :: " int "


\<comment> \<open>\<open>val update_mword_bool_dec : forall 'a. mword 'a -> integer -> bool -> mword 'a\<close>\<close>
definition update_mword_bool_dec  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> update_mword_bool_dec w n b = ( Bits.set_bit w (nat_of_int n) b )\<close> 
  for  w  :: "('a::len)Word.word " 
  and  n  :: " int " 
  and  b  :: " bool "

definition update_mword_dec  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> update_mword_dec w n b = ( map_option (update_mword_bool_dec w n) (bool_of_bitU b))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  n  :: " int " 
  and  b  :: " bitU "


\<comment> \<open>\<open>val update_mword_bool_inc : forall 'a. mword 'a -> integer -> bool -> mword 'a\<close>\<close>
definition update_mword_bool_inc  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> update_mword_bool_inc w n b = (
  (let top1 = ((int (size w)) -( 1 :: int)) in
  update_mword_bool_dec w (top1 - n) b))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  n  :: " int " 
  and  b  :: " bool "

definition update_mword_inc  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option \<close>  where 
     \<open> update_mword_inc w n b = ( map_option (update_mword_bool_inc w n) (bool_of_bitU b))\<close> 
  for  w  :: "('a::len)Word.word " 
  and  n  :: " int " 
  and  b  :: " bitU "


\<comment> \<open>\<open>val int_of_mword : forall 'a. bool -> mword 'a -> integer\<close>\<close>
definition int_of_mword  :: \<open> bool \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<close>  where 
     \<open> int_of_mword sign w = (
  if sign then Word.sint w else Word.uint w )\<close> 
  for  sign  :: " bool " 
  and  w  :: "('a::len)Word.word "


\<comment> \<open>\<open> Translating between a type level number (itself 'n) and an integer \<close>\<close>

definition size_itself_int  :: \<open>('a::len)itself \<Rightarrow> int \<close>  where 
     \<open> size_itself_int x = ( int (size_itself x))\<close> 
  for  x  :: "('a::len)itself "


\<comment> \<open>\<open> NB: the corresponding sail type is forall 'n. atom('n) -> itself('n),
   the actual integer is ignored. \<close>\<close>

\<comment> \<open>\<open>val make_the_value : forall 'n. integer -> itself 'n\<close>\<close>
definition make_the_value  :: \<open> int \<Rightarrow>('n::len)itself \<close>  where 
     \<open> make_the_value _ = ( TYPE(_) )\<close>


\<comment> \<open>\<open>** Bitvectors \<close>\<close>

record 'a Bitvector_class=

  bits_of_method ::" 'a \<Rightarrow> bitU list " 

  \<comment> \<open>\<open> We allow of_bits to be partial, as not all bitvector representations
     support undefined bits \<close>\<close>
  of_bits_method ::" bitU list \<Rightarrow>  'a option " 

  of_bools_method ::" bool list \<Rightarrow> 'a " 

  length_method ::" 'a \<Rightarrow> int " 

  \<comment> \<open>\<open> of_int: the first parameter specifies the desired length of the bitvector \<close>\<close>
  of_int_method ::" int \<Rightarrow> int \<Rightarrow> 'a " 

  \<comment> \<open>\<open> Conversion to integers is undefined if any bit is undefined \<close>\<close>
  unsigned_method ::" 'a \<Rightarrow>  int option " 

  signed_method ::" 'a \<Rightarrow>  int option " 

  \<comment> \<open>\<open> Lifting of integer operations to bitvectors:  The boolean flag indicates
     whether to treat the bitvectors as signed (true) or not (false). \<close>\<close>
  arith_op_bv_method ::" (int \<Rightarrow> int \<Rightarrow> int) \<Rightarrow> bool \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a "



\<comment> \<open>\<open>val of_bits_failwith : forall 'a. Bitvector 'a => list bitU -> 'a\<close>\<close>
definition of_bits_failwith  :: \<open> 'a Bitvector_class \<Rightarrow>(bitU)list \<Rightarrow> 'a \<close>  where 
     \<open> of_bits_failwith dict_Sail2_values_Bitvector_a bits = ( maybe_failwith (
  (of_bits_method   dict_Sail2_values_Bitvector_a) bits))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  bits  :: "(bitU)list "


definition int_of_bv  :: \<open> 'a Bitvector_class \<Rightarrow> bool \<Rightarrow> 'a \<Rightarrow>(int)option \<close>  where 
     \<open> int_of_bv dict_Sail2_values_Bitvector_a sign = ( if sign then 
  (signed_method   dict_Sail2_values_Bitvector_a) else (unsigned_method   dict_Sail2_values_Bitvector_a) )\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  sign  :: " bool "


definition instance_Sail2_values_Bitvector_list_dict  :: \<open> 'a BitU_class \<Rightarrow>('a list)Bitvector_class \<close>  where 
     \<open> instance_Sail2_values_Bitvector_list_dict dict_Sail2_values_BitU_a = ((|

  bits_of_method = ((\<lambda> v. List.map 
  (to_bitU_method   dict_Sail2_values_BitU_a) v)),

  of_bits_method = ((\<lambda> v. Some (List.map 
  (of_bitU_method   dict_Sail2_values_BitU_a) v))),

  of_bools_method = ((\<lambda> v. List.map 
  (of_bitU_method   dict_Sail2_values_BitU_a) (List.map bitU_of_bool v))),

  length_method = ((\<lambda> xs. int (List.length xs))),

  of_int_method = ((\<lambda> len n. List.map 
  (of_bitU_method   dict_Sail2_values_BitU_a) (bits_of_int len n))),

  unsigned_method = ((\<lambda> v. unsigned_of_bits (List.map 
  (to_bitU_method   dict_Sail2_values_BitU_a) v))),

  signed_method = ((\<lambda> v. signed_of_bits (List.map 
  (to_bitU_method   dict_Sail2_values_BitU_a) v))),

  arith_op_bv_method = ((\<lambda> op1 sign l r. List.map 
  (of_bitU_method   dict_Sail2_values_BitU_a) (arith_op_bits op1 sign (List.map 
  (to_bitU_method   dict_Sail2_values_BitU_a) l) (List.map (to_bitU_method   dict_Sail2_values_BitU_a) r))))|) )\<close> 
  for  dict_Sail2_values_BitU_a  :: " 'a BitU_class "


definition instance_Sail2_values_Bitvector_Machine_word_mword_dict  :: \<open>(('a::len)Word.word)Bitvector_class \<close>  where 
     \<open> instance_Sail2_values_Bitvector_Machine_word_mword_dict = ((|

  bits_of_method = ((\<lambda> v. List.map bitU_of_bool (Word.to_bl v))),

  of_bits_method = ((\<lambda> v. map_option Word.of_bl (just_list (List.map bool_of_bitU v)))),

  of_bools_method = ((\<lambda> v. Word.of_bl v)),

  length_method = ((\<lambda> v. int (size v))),

  of_int_method = ( (\<lambda>x .  
  (case  x of _ => (\<lambda> n .  Word.word_of_int n) ))),

  unsigned_method = ((\<lambda> v. Some (Word.uint v))),

  signed_method = ((\<lambda> v. Some (Word.sint v))),

  arith_op_bv_method = ((\<lambda> op1 sign l r. Word.word_of_int (op1 (int_of_mword sign l) (int_of_mword sign r))))|) )\<close>


definition access_bv_inc  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> bitU \<close>  where 
     \<open> access_bv_inc dict_Sail2_values_Bitvector_a v n = ( access_list True  (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) n )\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  v  :: " 'a " 
  and  n  :: " int "

definition access_bv_dec  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> bitU \<close>  where 
     \<open> access_bv_dec dict_Sail2_values_Bitvector_a v n = ( access_list False (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) n )\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  v  :: " 'a " 
  and  n  :: " int "


definition update_bv_inc  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(bitU)list \<close>  where 
     \<open> update_bv_inc dict_Sail2_values_Bitvector_a v n b = ( update_list True  (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) n b )\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  v  :: " 'a " 
  and  n  :: " int " 
  and  b  :: " bitU "

definition update_bv_dec  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(bitU)list \<close>  where 
     \<open> update_bv_dec dict_Sail2_values_Bitvector_a v n b = ( update_list False (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) n b )\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  v  :: " 'a " 
  and  n  :: " int " 
  and  b  :: " bitU "


definition subrange_bv_inc  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(bitU)list \<close>  where 
     \<open> subrange_bv_inc dict_Sail2_values_Bitvector_a v i j = ( subrange_list True  (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) i j )\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  v  :: " 'a " 
  and  i  :: " int " 
  and  j  :: " int "

definition subrange_bv_dec  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(bitU)list \<close>  where 
     \<open> subrange_bv_dec dict_Sail2_values_Bitvector_a v i j = ( subrange_list False (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) i j )\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  v  :: " 'a " 
  and  i  :: " int " 
  and  j  :: " int "


definition update_subrange_bv_inc  :: \<open> 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'b \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow>(bitU)list \<close>  where 
     \<open> update_subrange_bv_inc dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b v i j v' = ( update_subrange_list True  (
  (bits_of_method   dict_Sail2_values_Bitvector_b) v) i j ((bits_of_method   dict_Sail2_values_Bitvector_a) v'))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  v  :: " 'b " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  v'  :: " 'a "

definition update_subrange_bv_dec  :: \<open> 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'b \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow>(bitU)list \<close>  where 
     \<open> update_subrange_bv_dec dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b v i j v' = ( update_subrange_list False (
  (bits_of_method   dict_Sail2_values_Bitvector_b) v) i j ((bits_of_method   dict_Sail2_values_Bitvector_a) v'))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  v  :: " 'b " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  v'  :: " 'a "


\<comment> \<open>\<open>val extz_bv : forall 'a. Bitvector 'a => integer -> 'a -> list bitU\<close>\<close>
definition extz_bv  :: \<open> 'a Bitvector_class \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow>(bitU)list \<close>  where 
     \<open> extz_bv dict_Sail2_values_Bitvector_a n v = ( extz_bits n (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  n  :: " int " 
  and  v  :: " 'a "


\<comment> \<open>\<open>val exts_bv : forall 'a. Bitvector 'a => integer -> 'a -> list bitU\<close>\<close>
definition exts_bv  :: \<open> 'a Bitvector_class \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow>(bitU)list \<close>  where 
     \<open> exts_bv dict_Sail2_values_Bitvector_a n v = ( exts_bits n (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  n  :: " int " 
  and  v  :: " 'a "


\<comment> \<open>\<open>val nat_of_bv : forall 'a. Bitvector 'a => 'a -> maybe nat\<close>\<close>
definition nat_of_bv  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow>(nat)option \<close>  where 
     \<open> nat_of_bv dict_Sail2_values_Bitvector_a v = ( map_option nat_of_int (
  (unsigned_method   dict_Sail2_values_Bitvector_a) v))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  v  :: " 'a "


\<comment> \<open>\<open>val string_of_bv : forall 'a. Bitvector 'a => 'a -> string\<close>\<close>
definition string_of_bv  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> string \<close>  where 
     \<open> string_of_bv dict_Sail2_values_Bitvector_a v = ( show_bitlist (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  v  :: " 'a "


\<comment> \<open>\<open>val print_bits : forall 'a. Bitvector 'a => string -> 'a -> unit\<close>\<close>
definition print_bits  :: \<open> 'a Bitvector_class \<Rightarrow> string \<Rightarrow> 'a \<Rightarrow> unit \<close>  where 
     \<open> print_bits dict_Sail2_values_Bitvector_a str v = ( print_endline (str @ string_of_bv 
  dict_Sail2_values_Bitvector_a v))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  str  :: " string " 
  and  v  :: " 'a "


\<comment> \<open>\<open>val dec_str : integer -> string\<close>\<close>
definition dec_str  :: \<open> int \<Rightarrow> string \<close>  where 
     \<open> dec_str bv = ( Lem_string_extra.stringFromInteger bv )\<close> 
  for  bv  :: " int "


\<comment> \<open>\<open>val concat_str : string -> string -> string\<close>\<close>
definition concat_str  :: \<open> string \<Rightarrow> string \<Rightarrow> string \<close>  where 
     \<open> concat_str str1 str2 = ( str1 @ str2 )\<close> 
  for  str1  :: " string " 
  and  str2  :: " string "


\<comment> \<open>\<open>val int_of_bit : bitU -> integer\<close>\<close>
fun int_of_bit  :: \<open> bitU \<Rightarrow> int \<close>  where 
     \<open> int_of_bit B0 = (( 0 :: int))\<close>
|\<open> int_of_bit B1 = (( 1 :: int))\<close>
|\<open> int_of_bit _ = ( failwith (''int_of_bit saw unknown''))\<close>


\<comment> \<open>\<open>val count_leading_zero_bits : list bitU -> integer\<close>\<close>
function (sequential,domintros)  count_leading_zero_bits  :: \<open>(bitU)list \<Rightarrow> int \<close>  where 
     \<open> count_leading_zero_bits (B0 # v') = ( count_leading_zero_bits v' +( 1 :: int))\<close> 
  for  v'  :: "(bitU)list "
|\<open> count_leading_zero_bits _ = (( 0 :: int))\<close> 
by pat_completeness auto


\<comment> \<open>\<open>val count_leading_zeros_bv : forall 'a. Bitvector 'a => 'a -> integer\<close>\<close>
definition count_leading_zeros_bv  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<close>  where 
     \<open> count_leading_zeros_bv dict_Sail2_values_Bitvector_a v = ( count_leading_zero_bits (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  v  :: " 'a "


\<comment> \<open>\<open>val decimal_string_of_bv : forall 'a. Bitvector 'a => 'a -> string\<close>\<close>
definition decimal_string_of_bv  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> string \<close>  where 
     \<open> decimal_string_of_bv dict_Sail2_values_Bitvector_a bv = (
  (let place_values =
    (Lem_list.mapi
      ((\<lambda> i b .  (int_of_bit b) * (( 2 :: int) ^ i)))
      (List.rev ((bits_of_method   dict_Sail2_values_Bitvector_a) bv)))
  in
  (let sum1 = (List.foldl (+)(( 0 :: int)) place_values) in
  Lem_string_extra.stringFromInteger sum1)))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  bv  :: " 'a "


\<comment> \<open>\<open>** Bytes and addresses \<close>\<close>

type_synonym memory_byte =" bitU list "

\<comment> \<open>\<open>val byte_chunks : forall 'a. list 'a -> maybe (list (list 'a))\<close>\<close>
fun  byte_chunks  :: \<open> 'a list \<Rightarrow>(('a list)list)option \<close>  where 
     \<open> byte_chunks ([]) = ( Some [])\<close>
|\<open> byte_chunks (a # b # c # d # e # f # g # h # rest) = (
     Option.bind (byte_chunks rest) ((\<lambda> rest .  Some ([a,b,c,d,e,f,g,h] # rest))))\<close> 
  for  rest  :: " 'a list " 
  and  h  :: " 'a " 
  and  d  :: " 'a " 
  and  e  :: " 'a " 
  and  c  :: " 'a " 
  and  a  :: " 'a " 
  and  f  :: " 'a " 
  and  g  :: " 'a " 
  and  b  :: " 'a "
|\<open> byte_chunks _ = ( None )\<close>


\<comment> \<open>\<open>val bytes_of_bits : forall 'a. Bitvector 'a => 'a -> maybe (list memory_byte)\<close>\<close>
definition bytes_of_bits  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow>(((bitU)list)list)option \<close>  where 
     \<open> bytes_of_bits dict_Sail2_values_Bitvector_a bs = ( byte_chunks (
  (bits_of_method   dict_Sail2_values_Bitvector_a) bs))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  bs  :: " 'a "


\<comment> \<open>\<open>val bits_of_bytes : list memory_byte -> list bitU\<close>\<close>
definition bits_of_bytes  :: \<open>((bitU)list)list \<Rightarrow>(bitU)list \<close>  where 
     \<open> bits_of_bytes bs = ( List.concat (List.map ((\<lambda> v. List.map ((\<lambda> b. b)) v)) bs))\<close> 
  for  bs  :: "((bitU)list)list "


definition mem_bytes_of_bits  :: \<open> 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow>(((bitU)list)list)option \<close>  where 
     \<open> mem_bytes_of_bits dict_Sail2_values_Bitvector_a bs = ( map_option List.rev (bytes_of_bits 
  dict_Sail2_values_Bitvector_a bs))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  bs  :: " 'a "

definition bits_of_mem_bytes  :: \<open>((bitU)list)list \<Rightarrow>(bitU)list \<close>  where 
     \<open> bits_of_mem_bytes bs = ( bits_of_bytes (List.rev bs))\<close> 
  for  bs  :: "((bitU)list)list "


\<comment> \<open>\<open>val bitv_of_byte_lifteds : list Sail_impl_base.byte_lifted -> list bitU
let bitv_of_byte_lifteds v =
  foldl (fun x (Byte_lifted y) -> x ++ (List.map bitU_of_bit_lifted y)) [] v

val bitv_of_bytes : list Sail_impl_base.byte -> list bitU
let bitv_of_bytes v =
  foldl (fun x (Byte y) -> x ++ (List.map bitU_of_bit y)) [] v

val byte_lifteds_of_bitv : list bitU -> list byte_lifted
let byte_lifteds_of_bitv bits =
  let bits = List.map bit_lifted_of_bitU bits in
  byte_lifteds_of_bit_lifteds bits

val bytes_of_bitv : list bitU -> list byte
let bytes_of_bitv bits =
  let bits = List.map bit_of_bitU bits in
  bytes_of_bits bits

val bit_lifteds_of_bitUs : list bitU -> list bit_lifted
let bit_lifteds_of_bitUs bits = List.map bit_lifted_of_bitU bits

val bit_lifteds_of_bitv : list bitU -> list bit_lifted
let bit_lifteds_of_bitv v = bit_lifteds_of_bitUs v


val address_lifted_of_bitv : list bitU -> address_lifted
let address_lifted_of_bitv v =
  let byte_lifteds = byte_lifteds_of_bitv v in
  let maybe_address_integer =
    match (maybe_all (List.map byte_of_byte_lifted byte_lifteds)) with
    | Just bs -> Just (integer_of_byte_list bs)
    | _ -> Nothing
    end in
  Address_lifted byte_lifteds maybe_address_integer

val bitv_of_address_lifted : address_lifted -> list bitU
let bitv_of_address_lifted (Address_lifted bs _) = bitv_of_byte_lifteds bs

val address_of_bitv : list bitU -> address
let address_of_bitv v =
  let bytes = bytes_of_bitv v in
  address_of_byte_list bytes\<close>\<close>

function (sequential,domintros)  reverse_endianness_list  :: \<open> 'a list \<Rightarrow> 'a list \<close>  where 
     \<open> reverse_endianness_list bits = (
  if List.length bits \<le>( 8 :: nat) then bits else
    reverse_endianness_list (drop_list(( 8 :: int)) bits) @ take_list(( 8 :: int)) bits )\<close> 
  for  bits  :: " 'a list " 
by pat_completeness auto



\<comment> \<open>\<open>** Registers \<close>\<close>

\<comment> \<open>\<open>type register_field = string
type register_field_index = string * (integer * integer) \<open> name, start and end \<close>

type register =
  | Register of string * \<open> name \<close>
                integer * \<open> length \<close>
                integer * \<open> start index \<close>
                bool * \<open> is increasing \<close>
                  list register_field_index
  | UndefinedRegister of integer \<open> length \<close>
  | RegisterPair of register * register\<close>\<close>

record( 'regstate, 'regval, 'a) register_ref =
  
 name ::" string " 

     \<comment> \<open>\<open>is_inc : bool;\<close>\<close>
     read_from ::" 'regstate \<Rightarrow> 'a " 

     write_to ::" 'a \<Rightarrow> 'regstate \<Rightarrow> 'regstate " 

     of_regval ::" 'regval \<Rightarrow>  'a option " 

     regval_of ::" 'a \<Rightarrow> 'regval " 


\<comment> \<open>\<open> Register accessors: pair of functions for reading and writing register values \<close>\<close>
type_synonym( 'regstate, 'regval) register_accessors ="
  ((string \<Rightarrow> 'regstate \<Rightarrow>  'regval option) *
   (string \<Rightarrow> 'regval \<Rightarrow> 'regstate \<Rightarrow>  'regstate option))"

record( 'regtype, 'a) field_ref =
  
 field_name ::" string " 

     field_start ::" int " 

     field_is_inc ::" bool " 

     get_field ::" 'regtype \<Rightarrow> 'a " 

     set_field ::" 'regtype \<Rightarrow> 'a \<Rightarrow> 'regtype " 


\<comment> \<open>\<open>let name_of_reg = function
  | Register name _ _ _ _ -> name
  | UndefinedRegister _ -> failwith "name_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "name_of_reg RegisterPair"
end

let size_of_reg = function
  | Register _ size _ _ _ -> size
  | UndefinedRegister size -> size
  | RegisterPair _ _ -> failwith "size_of_reg RegisterPair"
end

let start_of_reg = function
  | Register _ _ start _ _ -> start
  | UndefinedRegister _ -> failwith "start_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "start_of_reg RegisterPair"
end

let is_inc_of_reg = function
  | Register _ _ _ is_inc _ -> is_inc
  | UndefinedRegister _ -> failwith "is_inc_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "in_inc_of_reg RegisterPair"
end

let dir_of_reg = function
  | Register _ _ _ is_inc _ -> dir_of_bool is_inc
  | UndefinedRegister _ -> failwith "dir_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "dir_of_reg RegisterPair"
end

let size_of_reg_nat reg = natFromInteger (size_of_reg reg)
let start_of_reg_nat reg = natFromInteger (start_of_reg reg)

val register_field_indices_aux : register -> register_field -> maybe (integer * integer)
let rec register_field_indices_aux register rfield =
  match register with
  | Register _ _ _ _ rfields -> List.lookup rfield rfields
  | RegisterPair r1 r2 ->
      let m_indices = register_field_indices_aux r1 rfield in
      if isJust m_indices then m_indices else register_field_indices_aux r2 rfield
  | UndefinedRegister _ -> Nothing
  end

val register_field_indices : register -> register_field -> integer * integer
let register_field_indices register rfield =
  match register_field_indices_aux register rfield with
  | Just indices -> indices
  | Nothing -> failwith "Invalid register/register-field combination"
  end

let register_field_indices_nat reg regfield=
  let (i,j) = register_field_indices reg regfield in
  (natFromInteger i,natFromInteger j)\<close>\<close>

\<comment> \<open>\<open>let rec external_reg_value reg_name v =
  let (internal_start, external_start, direction) =
    match reg_name with
     | Reg _ start size dir ->
        (start, (if dir = D_increasing then start else (start - (size +1))), dir)
     | Reg_slice _ reg_start dir (slice_start, _) ->
        ((if dir = D_increasing then slice_start else (reg_start - slice_start)),
         slice_start, dir)
     | Reg_field _ reg_start dir _ (slice_start, _) ->
        ((if dir = D_increasing then slice_start else (reg_start - slice_start)),
         slice_start, dir)
     | Reg_f_slice _ reg_start dir _ _ (slice_start, _) ->
        ((if dir = D_increasing then slice_start else (reg_start - slice_start)),
         slice_start, dir)
     end in
  let bits = bit_lifteds_of_bitv v in
  <| rv_bits           = bits;
     rv_dir            = direction;
     rv_start          = external_start;
     rv_start_internal = internal_start |>

val internal_reg_value : register_value -> list bitU
let internal_reg_value v =
  List.map bitU_of_bit_lifted v.rv_bits
         \<open>(integerFromNat v.rv_start_internal)
         (v.rv_dir = D_increasing)\<close>


let external_slice (d:direction) (start:nat) ((i,j):(nat*nat)) =
  match d with
  \<open>This is the case the thread/concurrecny model expects, so no change needed\<close>
  | D_increasing -> (i,j)
  | D_decreasing -> let slice_i = start - i in
                    let slice_j = (i - j) + slice_i in
                    (slice_i,slice_j)
  end \<close>\<close>

\<comment> \<open>\<open> TODO
let external_reg_whole r =
  Reg (r.name) (natFromInteger r.start) (natFromInteger r.size) (dir_of_bool r.is_inc)

let external_reg_slice r (i,j) =
  let start = natFromInteger r.start in
  let dir = dir_of_bool r.is_inc in
  Reg_slice (r.name) start dir (external_slice dir start (i,j))

let external_reg_field_whole reg rfield =
  let (m,n) = register_field_indices_nat reg rfield in
  let start = start_of_reg_nat reg in
  let dir = dir_of_reg reg in
  Reg_field (name_of_reg reg) start dir rfield (external_slice dir start (m,n))

let external_reg_field_slice reg rfield (i,j) =
  let (m,n) = register_field_indices_nat reg rfield in
  let start = start_of_reg_nat reg in
  let dir = dir_of_reg reg in
  Reg_f_slice (name_of_reg reg) start dir rfield
              (external_slice dir start (m,n))
              (external_slice dir start (i,j))\<close>\<close>

\<comment> \<open>\<open>val external_mem_value : list bitU -> memory_value
let external_mem_value v =
  byte_lifteds_of_bitv v $> List.reverse

val internal_mem_value : memory_value -> list bitU
let internal_mem_value bytes =
  List.reverse bytes $> bitv_of_byte_lifteds\<close>\<close>


\<comment> \<open>\<open>val foreach : forall 'a 'vars.
  (list 'a) -> 'vars -> ('a -> 'vars -> 'vars) -> 'vars\<close>\<close>
fun  foreach  :: \<open> 'a list \<Rightarrow> 'vars \<Rightarrow>('a \<Rightarrow> 'vars \<Rightarrow> 'vars)\<Rightarrow> 'vars \<close>  where 
     \<open> foreach ([]) vars body = ( vars )\<close> 
  for  vars  :: " 'vars " 
  and  body  :: " 'a \<Rightarrow> 'vars \<Rightarrow> 'vars "
|\<open> foreach (x # xs) vars body = ( foreach xs (body x vars) body )\<close> 
  for  xs  :: " 'a list " 
  and  x  :: " 'a " 
  and  vars  :: " 'vars " 
  and  body  :: " 'a \<Rightarrow> 'vars \<Rightarrow> 'vars "


\<comment> \<open>\<open>val index_list : integer -> integer -> integer -> list integer\<close>\<close>
function (sequential,domintros)  index_list  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(int)list \<close>  where 
     \<open> index_list from1 to1 step = (
  if ((step >( 0 :: int)) \<and> (from1 \<le> to1)) \<or> ((step <( 0 :: int)) \<and> (to1 \<le> from1)) then
    from1 # index_list (from1 + step) to1 step
  else [])\<close> 
  for  from1  :: " int " 
  and  to1  :: " int " 
  and  step  :: " int " 
by pat_completeness auto


\<comment> \<open>\<open>val while : forall 'vars. 'vars -> ('vars -> bool) -> ('vars -> 'vars) -> 'vars\<close>\<close>
function (sequential,domintros)  while  :: \<open> 'vars \<Rightarrow>('vars \<Rightarrow> bool)\<Rightarrow>('vars \<Rightarrow> 'vars)\<Rightarrow> 'vars \<close>  where 
     \<open> while vars cond body = (
  if cond vars then while (body vars) cond body else vars )\<close> 
  for  vars  :: " 'vars " 
  and  cond  :: " 'vars \<Rightarrow> bool " 
  and  body  :: " 'vars \<Rightarrow> 'vars " 
by pat_completeness auto


\<comment> \<open>\<open>val until : forall 'vars. 'vars -> ('vars -> bool) -> ('vars -> 'vars) -> 'vars\<close>\<close>
function (sequential,domintros)  until  :: \<open> 'vars \<Rightarrow>('vars \<Rightarrow> bool)\<Rightarrow>('vars \<Rightarrow> 'vars)\<Rightarrow> 'vars \<close>  where 
     \<open> until vars cond body = (
  (let vars = (body vars) in
  if cond vars then vars else until (body vars) cond body))\<close> 
  for  vars  :: " 'vars " 
  and  cond  :: " 'vars \<Rightarrow> bool " 
  and  body  :: " 'vars \<Rightarrow> 'vars " 
by pat_completeness auto



\<comment> \<open>\<open> convert numbers unsafely to naturals \<close>\<close>

record 'a ToNatural_class=
 toNatural_method ::" 'a \<Rightarrow> nat " 

\<comment> \<open>\<open> eta-expanded for Isabelle output, otherwise it breaks \<close>\<close>
definition instance_Sail2_values_ToNatural_Num_integer_dict  :: \<open>(int)ToNatural_class \<close>  where 
     \<open> instance_Sail2_values_ToNatural_Num_integer_dict = ((|

  toNatural_method = ((\<lambda> n .  nat (abs n)))|) )\<close>

definition instance_Sail2_values_ToNatural_Num_int_dict  :: \<open>(int)ToNatural_class \<close>  where 
     \<open> instance_Sail2_values_ToNatural_Num_int_dict = ((|

  toNatural_method = ((\<lambda> n .   (nat (abs n))))|) )\<close>

definition instance_Sail2_values_ToNatural_nat_dict  :: \<open>(nat)ToNatural_class \<close>  where 
     \<open> instance_Sail2_values_ToNatural_nat_dict = ((|

  toNatural_method = ((\<lambda> n .   n))|) )\<close>

definition instance_Sail2_values_ToNatural_Num_natural_dict  :: \<open>(nat)ToNatural_class \<close>  where 
     \<open> instance_Sail2_values_ToNatural_Num_natural_dict = ((|

  toNatural_method = ((\<lambda> n .  n))|) )\<close>


fun toNaturalFiveTup  :: \<open> 'a ToNatural_class \<Rightarrow> 'b ToNatural_class \<Rightarrow> 'c ToNatural_class \<Rightarrow> 'd ToNatural_class \<Rightarrow> 'e ToNatural_class \<Rightarrow> 'd*'c*'b*'a*'e \<Rightarrow> nat*nat*nat*nat*nat \<close>  where 
     \<open> toNaturalFiveTup dict_Sail2_values_ToNatural_a dict_Sail2_values_ToNatural_b dict_Sail2_values_ToNatural_c dict_Sail2_values_ToNatural_d dict_Sail2_values_ToNatural_e (n1,n2,n3,n4,n5) = (
  ((toNatural_method   dict_Sail2_values_ToNatural_d) n1,(toNatural_method   dict_Sail2_values_ToNatural_c) n2,(toNatural_method   dict_Sail2_values_ToNatural_b) n3,(toNatural_method   dict_Sail2_values_ToNatural_a) n4,(toNatural_method   dict_Sail2_values_ToNatural_e) n5))\<close> 
  for  dict_Sail2_values_ToNatural_a  :: " 'a ToNatural_class " 
  and  dict_Sail2_values_ToNatural_b  :: " 'b ToNatural_class " 
  and  dict_Sail2_values_ToNatural_c  :: " 'c ToNatural_class " 
  and  dict_Sail2_values_ToNatural_d  :: " 'd ToNatural_class " 
  and  dict_Sail2_values_ToNatural_e  :: " 'e ToNatural_class " 
  and  n5  :: " 'e " 
  and  n4  :: " 'a " 
  and  n3  :: " 'b " 
  and  n1  :: " 'd " 
  and  n2  :: " 'c "


\<comment> \<open>\<open> Let the following types be generated by Sail per spec, using either bitlists
   or machine words as bitvector representation \<close>\<close>
\<comment> \<open>\<open>type regfp =
  | RFull of (string)
  | RSlice of (string * integer * integer)
  | RSliceBit of (string * integer)
  | RField of (string * string)

type niafp =
  | NIAFP_successor
  | NIAFP_concrete_address of vector bitU
  | NIAFP_indirect_address

\<open> only for MIPS \<close>
type diafp =
  | DIAFP_none
  | DIAFP_concrete of vector bitU
  | DIAFP_reg of regfp

let regfp_to_reg (reg_info : string -> maybe string -> (nat * nat * direction * (nat * nat))) = function
  | RFull name ->
     let (start,length,direction,_) = reg_info name Nothing in
     Reg name start length direction
  | RSlice (name,i,j) ->
     let i = natFromInteger i in
     let j = natFromInteger j in
     let (start,length,direction,_) = reg_info name Nothing in
     let slice = external_slice direction start (i,j) in
     Reg_slice name start direction slice
  | RSliceBit (name,i) ->
     let i = natFromInteger i in
     let (start,length,direction,_) = reg_info name Nothing in
     let slice = external_slice direction start (i,i) in
     Reg_slice name start direction slice
  | RField (name,field_name) ->
     let (start,length,direction,span) = reg_info name (Just field_name) in
     let slice = external_slice direction start span in
     Reg_field name start direction field_name slice
end

let niafp_to_nia reginfo = function
  | NIAFP_successor -> NIA_successor
  | NIAFP_concrete_address v -> NIA_concrete_address (address_of_bitv v)
  | NIAFP_indirect_address -> NIA_indirect_address
end

let diafp_to_dia reginfo = function
  | DIAFP_none -> DIA_none
  | DIAFP_concrete v -> DIA_concrete_address (address_of_bitv v)
  | DIAFP_reg r -> DIA_register (regfp_to_reg reginfo r)
end
\<close>\<close>
end
