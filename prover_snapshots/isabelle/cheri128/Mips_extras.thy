chapter \<open>Generated by Lem from \<open>../mips/mips_extras.lem\<close>.\<close>

theory "Mips_extras" 

imports
  Main
  "LEM.Lem_pervasives"
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"
  "Sail.Sail2_operators"

begin 

\<comment> \<open>\<open>open import Pervasives\<close>\<close>
\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_instr_kinds\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators_mwords\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt\<close>\<close>

definition addr_size  :: \<open> int \<close>  where 
     \<open> addr_size = ( (( 64 :: int)::int))\<close>


\<comment> \<open>\<open>val MEMr                : forall 'regval 'a 'b 'e. Size 'a, Size 'b => mword 'a -> integer -> monad 'regval (mword 'b) 'e\<close>\<close>
\<comment> \<open>\<open>val MEMr_reserve        : forall 'regval 'a 'b 'e. Size 'a, Size 'b => mword 'a -> integer -> monad 'regval (mword 'b) 'e\<close>\<close>
\<comment> \<open>\<open>val MEMr_tagged         : forall 'regval 'a 'b 'e. Size 'a, Size 'b => mword 'a -> integer -> bool -> monad 'regval (bool * mword 'b) 'e\<close>\<close>
\<comment> \<open>\<open>val MEMr_tagged_reserve : forall 'regval 'a 'b 'e. Size 'a, Size 'b => mword 'a -> integer -> bool -> monad 'regval (bool * mword 'b) 'e\<close>\<close>

definition MEMr  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('regval,(('b::len)Word.word),'e)monad \<close>              where 
     \<open> MEMr addr size1             = ( read_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain addr_size addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "

definition MEMr_reserve  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('regval,(('b::len)Word.word),'e)monad \<close>      where 
     \<open> MEMr_reserve addr size1     = ( read_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_reserve addr_size addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "


definition MEMr_tagged  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('regval,(bool*('b::len)Word.word),'e)monad \<close>  where 
     \<open> MEMr_tagged addr size1 allowTag = (
  (if allowTag then
    read_memt instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain addr size1
   else
    (read_mem instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain addr_size addr size1 \<bind> ((\<lambda> v .  return (v, B0))))) \<bind>  
  ((\<lambda>x .  (case  x of
                      (v, t) =>
                  maybe_fail (''bool_of_bitU'') (bool_of_bitU t) \<bind>
                    ((\<lambda> t .  return (t, v)))
                  ))) )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int " 
  and  allowTag  :: " bool "


definition MEMr_tagged_reserve  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('regval,(bool*('b::len)Word.word),'e)monad \<close>  where 
     \<open> MEMr_tagged_reserve addr size1 allowTag = (
  (if allowTag then
    read_memt instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain addr size1
   else
    (read_mem instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain addr_size addr size1 \<bind> ((\<lambda> v .  return (v, B0))))) \<bind>  
  ((\<lambda>x .  (case  x of
                      (v, t) =>
                  maybe_fail (''bool_of_bitU'') (bool_of_bitU t) \<bind>
                    ((\<lambda> t .  return (t, v)))
                  ))) )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int " 
  and  allowTag  :: " bool "



\<comment> \<open>\<open>val MEMea                 : forall 'regval 'a 'e. Size 'a => mword 'a -> integer -> monad 'regval unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMea_conditional     : forall 'regval 'a 'e. Size 'a => mword 'a -> integer -> monad 'regval unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMea_tag             : forall 'regval 'a 'e. Size 'a => mword 'a -> integer -> monad 'regval unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMea_tag_conditional : forall 'regval 'a 'e. Size 'a => mword 'a -> integer -> monad 'regval unit 'e\<close>\<close>

definition MEMea  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('regval,(unit),'e)monad \<close>                  where 
     \<open> MEMea addr size1                 = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain addr_size addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "

definition MEMea_conditional  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('regval,(unit),'e)monad \<close>      where 
     \<open> MEMea_conditional addr size1     = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_conditional addr_size addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "


\<comment> \<open>\<open>val MEMval                    : forall 'regval 'a 'b 'e. Size 'a, Size 'b => mword 'a -> integer -> mword 'b -> monad 'regval unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMval_conditional        : forall 'regval 'a 'b 'e. Size 'a, Size 'b => mword 'a -> integer -> mword 'b -> monad 'regval bool 'e\<close>\<close>
\<comment> \<open>\<open>val MEMval_tagged             : forall 'regval 'a 'b 'e. Size 'a, Size 'b => mword 'a -> integer -> bool -> mword 'b -> monad 'regval unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMval_tagged_conditional : forall 'regval 'a 'b 'e. Size 'a, Size 'b => mword 'a -> integer -> bool -> mword 'b -> monad 'regval bool 'e\<close>\<close>

definition MEMval  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('regval,(unit),'e)monad \<close>                       where 
     \<open> MEMval addr size1 v                      = ( write_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain addr_size addr size1 v \<bind>  
  ((\<lambda>x .  (case  x of _ => return ()  ))) )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int " 
  and  v  :: "('b::len)Word.word "

definition MEMval_conditional  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('regval,(bool),'e)monad \<close>           where 
     \<open> MEMval_conditional addr size1 v          = ( write_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_conditional addr_size addr size1 v )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int " 
  and  v  :: "('b::len)Word.word "

definition MEMval_tagged  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('b::len)Word.word \<Rightarrow>('regval,(unit),'e)monad \<close>              where 
     \<open> MEMval_tagged addr size1 t v             = ( write_memt 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain addr size1 v (bitU_of_bool t) \<bind>  
  ((\<lambda>x .  (case  x of _ => return ()  ))) )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int " 
  and  t  :: " bool " 
  and  v  :: "('b::len)Word.word "

definition MEMval_tagged_conditional  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('b::len)Word.word \<Rightarrow>('regval,(bool),'e)monad \<close>  where 
     \<open> MEMval_tagged_conditional addr size1 t v = ( write_memt 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_conditional addr size1 v (bitU_of_bool t))\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int " 
  and  t  :: " bool " 
  and  v  :: "('b::len)Word.word "


definition MEMw  :: \<open>('c::len)Word.word \<Rightarrow> int \<Rightarrow> 'e \<Rightarrow>('b::len)Word.word \<Rightarrow>('d,(unit),'a)monad \<close>                     where 
     \<open> MEMw addr size1 t v                    = ( MEMea addr size1             \<then> MEMval addr size1 v )\<close> 
  for  addr  :: "('c::len)Word.word " 
  and  size1  :: " int " 
  and  t  :: " 'e " 
  and  v  :: "('b::len)Word.word "

definition MEMw_conditional  :: \<open>('c::len)Word.word \<Rightarrow> int \<Rightarrow> 'e \<Rightarrow>('b::len)Word.word \<Rightarrow>('d,(bool),'a)monad \<close>         where 
     \<open> MEMw_conditional addr size1 t v        = ( MEMea_conditional addr size1 \<then> MEMval_conditional addr size1 v )\<close> 
  for  addr  :: "('c::len)Word.word " 
  and  size1  :: " int " 
  and  t  :: " 'e " 
  and  v  :: "('b::len)Word.word "

definition MEMw_tagged  :: \<open>('c::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('b::len)Word.word \<Rightarrow>('d,(unit),'a)monad \<close>              where 
     \<open> MEMw_tagged addr size1 t v             = ( MEMea addr size1             \<then> MEMval_tagged addr size1 t v )\<close> 
  for  addr  :: "('c::len)Word.word " 
  and  size1  :: " int " 
  and  t  :: " bool " 
  and  v  :: "('b::len)Word.word "

definition MEMw_tagged_conditional  :: \<open>('c::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('b::len)Word.word \<Rightarrow>('d,(bool),'a)monad \<close>  where 
     \<open> MEMw_tagged_conditional addr size1 t v = ( MEMea_conditional addr size1 \<then> MEMval_tagged_conditional addr size1 t v )\<close> 
  for  addr  :: "('c::len)Word.word " 
  and  size1  :: " int " 
  and  t  :: " bool " 
  and  v  :: "('b::len)Word.word "


\<comment> \<open>\<open>val MEM_sync  : forall 'regval 'e. unit -> monad 'regval unit 'e\<close>\<close>

definition MEM_sync  :: \<open> unit \<Rightarrow>('regval,(unit),'e)monad \<close>  where 
     \<open> MEM_sync _ = ( barrier (Barrier_MIPS_SYNC () ))\<close>


\<comment> \<open>\<open> Some wrappers copied from aarch64_extras \<close>\<close>
\<comment> \<open>\<open> TODO: Harmonise into a common library \<close>\<close>

definition write_ram  :: \<open> 'e \<Rightarrow> int \<Rightarrow> 'f \<Rightarrow>('c::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('d,(unit),'a)monad \<close>  where 
     \<open> write_ram _ size1 _ addr data = (
  MEMea addr size1 \<then>
  MEMval addr size1 data )\<close> 
  for  size1  :: " int " 
  and  addr  :: "('c::len)Word.word " 
  and  data  :: "('b::len)Word.word "


definition read_ram  :: \<open> 'e \<Rightarrow> int \<Rightarrow> 'f \<Rightarrow>('c::len)Word.word \<Rightarrow>('d,(('b::len)Word.word),'a)monad \<close>  where 
     \<open> read_ram _ size1 _ addr = ( MEMr addr size1 )\<close> 
  for  size1  :: " int " 
  and  addr  :: "('c::len)Word.word "


definition string_of_int  :: \<open> 'a Show_class \<Rightarrow> 'a \<Rightarrow> string \<close>  where 
     \<open> string_of_int dict_Show_Show_a = ((show_method   dict_Show_Show_a))\<close> 
  for  dict_Show_Show_a  :: " 'a Show_class "


definition shift_bits_left  :: \<open> 'b Bitvector_class \<Rightarrow> 'd Bitvector_class \<Rightarrow> 'e Bitvector_class \<Rightarrow> 'd \<Rightarrow> 'e \<Rightarrow>('c,'b,'a)monad \<close>  where 
     \<open> shift_bits_left dict_Sail2_values_Bitvector_b dict_Sail2_values_Bitvector_d dict_Sail2_values_Bitvector_e v n = (
  (let r = (Option.bind (
  (unsigned_method   dict_Sail2_values_Bitvector_e) n) ((\<lambda> n . (of_bits_method   dict_Sail2_values_Bitvector_b) (shiftl_bv dict_Sail2_values_Bitvector_d v n)))) in
  maybe_fail (''shift_bits_left'') r))\<close> 
  for  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  dict_Sail2_values_Bitvector_d  :: " 'd Bitvector_class " 
  and  dict_Sail2_values_Bitvector_e  :: " 'e Bitvector_class " 
  and  v  :: " 'd " 
  and  n  :: " 'e "

definition shift_bits_right  :: \<open> 'b Bitvector_class \<Rightarrow> 'd Bitvector_class \<Rightarrow> 'e Bitvector_class \<Rightarrow> 'd \<Rightarrow> 'e \<Rightarrow>('c,'b,'a)monad \<close>  where 
     \<open> shift_bits_right dict_Sail2_values_Bitvector_b dict_Sail2_values_Bitvector_d dict_Sail2_values_Bitvector_e v n = (
  (let r = (Option.bind (
  (unsigned_method   dict_Sail2_values_Bitvector_e) n) ((\<lambda> n . (of_bits_method   dict_Sail2_values_Bitvector_b) (shiftr_bv dict_Sail2_values_Bitvector_d v n)))) in
  maybe_fail (''shift_bits_right'') r))\<close> 
  for  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  dict_Sail2_values_Bitvector_d  :: " 'd Bitvector_class " 
  and  dict_Sail2_values_Bitvector_e  :: " 'e Bitvector_class " 
  and  v  :: " 'd " 
  and  n  :: " 'e "

definition shift_bits_right_arith  :: \<open> 'b Bitvector_class \<Rightarrow> 'd Bitvector_class \<Rightarrow> 'e Bitvector_class \<Rightarrow> 'd \<Rightarrow> 'e \<Rightarrow>('c,'b,'a)monad \<close>  where 
     \<open> shift_bits_right_arith dict_Sail2_values_Bitvector_b dict_Sail2_values_Bitvector_d dict_Sail2_values_Bitvector_e v n = (
  (let r = (Option.bind (
  (unsigned_method   dict_Sail2_values_Bitvector_e) n) ((\<lambda> n . (of_bits_method   dict_Sail2_values_Bitvector_b) (arith_shiftr_bv dict_Sail2_values_Bitvector_d v n)))) in
  maybe_fail (''shift_bits_right_arith'') r))\<close> 
  for  dict_Sail2_values_Bitvector_b  :: " 'b Bitvector_class " 
  and  dict_Sail2_values_Bitvector_d  :: " 'd Bitvector_class " 
  and  dict_Sail2_values_Bitvector_e  :: " 'e Bitvector_class " 
  and  v  :: " 'd " 
  and  n  :: " 'e "


\<comment> \<open>\<open> Use constants for undefined values for now \<close>\<close>
definition undefined_string  :: \<open> unit \<Rightarrow>('b,(string),'a)monad \<close>  where 
     \<open> undefined_string _ = ( return (''''))\<close>

definition undefined_unit  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> undefined_unit _ = ( return ()  )\<close>

definition undefined_int  :: \<open> unit \<Rightarrow>('b,(int),'a)monad \<close>  where 
     \<open> undefined_int _ = ( return (( 0 :: int)::ii))\<close>

\<comment> \<open>\<open>val undefined_vector : forall 'rv 'a 'e. integer -> 'a -> monad 'rv (list 'a) 'e\<close>\<close>
definition undefined_vector  :: \<open> int \<Rightarrow> 'a \<Rightarrow>('rv,('a list),'e)monad \<close>  where 
     \<open> undefined_vector len u = ( return (repeat [u] len))\<close> 
  for  len  :: " int " 
  and  u  :: " 'a "

\<comment> \<open>\<open>val undefined_bitvector : forall 'rv 'a 'e. Size 'a => integer -> monad 'rv (mword 'a) 'e\<close>\<close>
definition undefined_bitvector  :: \<open> int \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> undefined_bitvector len = ( return (Word.of_bl (repeat [False] len)))\<close> 
  for  len  :: " int "

\<comment> \<open>\<open>val undefined_bits : forall 'rv 'a 'e. Size 'a => integer -> monad 'rv (mword 'a) 'e\<close>\<close>
definition undefined_bits  :: \<open> int \<Rightarrow>('rv,(('a::len)Word.word),'e)monad \<close>  where 
     \<open> undefined_bits = ( undefined_bitvector )\<close>

definition undefined_bit  :: \<open> unit \<Rightarrow>('b,(bitU),'a)monad \<close>  where 
     \<open> undefined_bit _ = ( return B0 )\<close>

definition undefined_real  :: \<open> unit \<Rightarrow>('b,(real),'a)monad \<close>  where 
     \<open> undefined_real _ = ( return (realFromFrac(( 0 :: int))(( 1 :: int))))\<close>

definition undefined_range  :: \<open> 'a \<Rightarrow> 'd \<Rightarrow>('c,'a,'b)monad \<close>  where 
     \<open> undefined_range i j = ( return i )\<close> 
  for  i  :: " 'a " 
  and  j  :: " 'd "

definition undefined_atom  :: \<open> 'a \<Rightarrow>('c,'a,'b)monad \<close>  where 
     \<open> undefined_atom i = ( return i )\<close> 
  for  i  :: " 'a "

definition undefined_nat  :: \<open> unit \<Rightarrow>('b,(int),'a)monad \<close>  where 
     \<open> undefined_nat _ = ( return (( 0 :: int)::ii))\<close>


definition skip  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> skip _ = ( return ()  )\<close>


\<comment> \<open>\<open>val elf_entry : unit -> integer\<close>\<close>
definition elf_entry  :: \<open> unit \<Rightarrow> int \<close>  where 
     \<open> elf_entry _ = (( 0 :: int))\<close>


definition print_bits0  :: \<open> 'a Bitvector_class \<Rightarrow> string \<Rightarrow> 'a \<Rightarrow> unit \<close>  where 
     \<open> print_bits0 dict_Sail2_values_Bitvector_a msg bs = ( print_endline (msg @ (string_of_bv 
  dict_Sail2_values_Bitvector_a bs)))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  msg  :: " string " 
  and  bs  :: " 'a "

definition prerr_bits  :: \<open> 'a Bitvector_class \<Rightarrow> string \<Rightarrow> 'a \<Rightarrow> unit \<close>  where 
     \<open> prerr_bits dict_Sail2_values_Bitvector_a msg bs = ( prerr_endline (msg @ (string_of_bv 
  dict_Sail2_values_Bitvector_a bs)))\<close> 
  for  dict_Sail2_values_Bitvector_a  :: " 'a Bitvector_class " 
  and  msg  :: " string " 
  and  bs  :: " 'a "


\<comment> \<open>\<open>val prerr_string : string -> unit\<close>\<close>
definition prerr_string  :: \<open> string \<Rightarrow> unit \<close>  where 
     \<open> prerr_string _ = ( ()  )\<close>


\<comment> \<open>\<open>val get_time_ns : unit -> integer\<close>\<close>
definition get_time_ns  :: \<open> unit \<Rightarrow> int \<close>  where 
     \<open> get_time_ns _ = (( 0 :: int))\<close>


\<comment> \<open>\<open>val cycle_count : unit -> unit\<close>\<close>
definition cycle_count  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> cycle_count _ = ( ()  )\<close>

end
