chapter \<open>Generated by Lem from \<open>cheri128.lem\<close>.\<close>

theory "Cheri128" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_string"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"
  "Cheri128_types"
  "Mips_extras"

begin 

\<comment> \<open>\<open>Generated by Sail from cheri128.\<close>\<close>
\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_instr_kinds\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_string\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators_mwords\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt\<close>\<close>
\<comment> \<open>\<open>open import Cheri128_types\<close>\<close>
\<comment> \<open>\<open>open import Mips_extras\<close>\<close>

\<comment> \<open>\<open>val eq_unit : unit -> unit -> bool\<close>\<close>

definition eq_unit  :: \<open> unit \<Rightarrow> unit \<Rightarrow> bool \<close>  where 
     \<open> eq_unit _ _ = ( True )\<close>




\<comment> \<open>\<open>val neq_bool : bool -> bool -> bool\<close>\<close>

definition neq_bool  :: \<open> bool \<Rightarrow> bool \<Rightarrow> bool \<close>  where 
     \<open> neq_bool x y = ( \<not> (((x = y))))\<close> 
  for  x  :: " bool " 
  and  y  :: " bool "


\<comment> \<open>\<open>val __id : integer -> integer\<close>\<close>

definition id0  :: \<open> int \<Rightarrow> int \<close>  where 
     \<open> id0 x = ( x )\<close> 
  for  x  :: " int "


\<comment> \<open>\<open>val _shl_int_general : ii -> ii -> ii\<close>\<close>

definition shl_int_general  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> shl_int_general (m :: ii) (n :: ii) = (
   if ((n \<ge> (( 0 :: int)::ii))) then shl_int m n
   else shr_int m ((- n)))\<close> 
  for  m  :: " int " 
  and  n  :: " int "


\<comment> \<open>\<open>val _shr_int_general : ii -> ii -> ii\<close>\<close>

definition shr_int_general  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> shr_int_general (m :: ii) (n :: ii) = (
   if ((n \<ge> (( 0 :: int)::ii))) then shr_int m n
   else shl_int m ((- n)))\<close> 
  for  m  :: " int " 
  and  n  :: " int "


\<comment> \<open>\<open>val fdiv_int : ii -> ii -> ii\<close>\<close>

definition fdiv_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> fdiv_int (n :: ii) (m :: ii) = (
   if (((((n < (( 0 :: int)::ii))) \<and> ((m > (( 0 :: int)::ii)))))) then
     ((tdiv_int ((n + (( 1 :: int)::ii))) m)) - (( 1 :: int)::ii)
   else if (((((n > (( 0 :: int)::ii))) \<and> ((m < (( 0 :: int)::ii)))))) then
     ((tdiv_int ((n - (( 1 :: int)::ii))) m)) - (( 1 :: int)::ii)
   else tdiv_int n m )\<close> 
  for  n  :: " int " 
  and  m  :: " int "


\<comment> \<open>\<open>val fmod_int : ii -> ii -> ii\<close>\<close>

definition fmod_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> fmod_int (n :: ii) (m :: ii) = ( n - ((m * ((fdiv_int n m)))))\<close> 
  for  n  :: " int " 
  and  m  :: " int "




\<comment> \<open>\<open>val sail_mask : forall 'len 'v. Size 'len, Size 'v => integer -> mword 'v -> mword 'len\<close>\<close>

definition sail_mask  :: \<open> int \<Rightarrow>('v::len)Word.word \<Rightarrow>('len::len)Word.word \<close>  where 
     \<open> sail_mask len v = (
   if ((len \<le> ((int (size v))))) then (vector_truncate v len  :: ( 'len::len)Word.word)
   else (zero_extend v len  :: ( 'len::len)Word.word))\<close> 
  for  len  :: " int " 
  and  v  :: "('v::len)Word.word "


\<comment> \<open>\<open>val sail_ones : forall 'n. Size 'n => integer -> mword 'n\<close>\<close>

definition sail_ones  :: \<open> int \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> sail_ones n = ( (not_vec ((zeros n  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word))\<close> 
  for  n  :: " int "


\<comment> \<open>\<open>val slice_mask : forall 'n. Size 'n => integer -> ii -> ii -> mword 'n\<close>\<close>

definition slice_mask  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> slice_mask n i l = (
   if ((l \<ge> n)) then (shiftl ((sail_ones n  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)
   else
     (let (one :: ( 'n::len)Word.word) = ((sail_mask n ( 0b1 ::  1 Word.word)  :: ( 'n::len)Word.word)) in
     (shiftl ((sub_vec ((shiftl one l  :: ( 'n::len)Word.word)) one  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)))\<close> 
  for  n  :: " int " 
  and  i  :: " int " 
  and  l  :: " int "






\<comment> \<open>\<open>val is_zero_subrange : forall 'n. Size 'n => mword 'n -> ii -> ii -> bool\<close>\<close>

definition is_zero_subrange  :: \<open>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> is_zero_subrange xs i j = (
   (((and_vec xs
         ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
        :: ( 'n::len)Word.word)) = ((extz_vec ((int (size xs))) ( 0b0 ::  1 Word.word)  :: ( 'n::len)Word.word))))\<close> 
  for  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val is_zeros_slice : forall 'n. Size 'n => mword 'n -> ii -> ii -> bool\<close>\<close>

definition is_zeros_slice  :: \<open>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> is_zeros_slice xs i l = (
   (((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) = ((extz_vec ((int (size xs))) ( 0b0 ::  1 Word.word)  :: ( 'n::len)Word.word))))\<close> 
  for  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  l  :: " int "


\<comment> \<open>\<open>val is_ones_subrange : forall 'n. Size 'n => mword 'n -> ii -> ii -> bool\<close>\<close>

definition is_ones_subrange  :: \<open>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> is_ones_subrange xs i j = (
   (let (m :: ( 'n::len)Word.word) =
     ((slice_mask ((int (size xs))) j ((((j - i)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word)) in
   (((and_vec xs m  :: ( 'n::len)Word.word)) = m)))\<close> 
  for  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val is_ones_slice : forall 'n. Size 'n => mword 'n -> ii -> ii -> bool\<close>\<close>

definition is_ones_slice  :: \<open>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> is_ones_slice xs i j = (
   (let (m :: ( 'n::len)Word.word) = ((slice_mask ((int (size xs))) i j  :: ( 'n::len)Word.word)) in
   (((and_vec xs m  :: ( 'n::len)Word.word)) = m)))\<close> 
  for  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val slice_slice_concat : forall 'm 'n 'r. Size 'm, Size 'n, Size 'r => integer -> mword 'n -> ii -> ii -> mword 'm -> ii -> ii -> mword 'r\<close>\<close>

definition slice_slice_concat  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('r::len)Word.word \<close>  where 
     \<open> slice_slice_concat r xs i l ys i' l' = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (let ys =
     ((shiftr ((and_vec ys ((slice_mask ((int (size ys))) i' l'  :: ( 'm::len)Word.word))  :: ( 'm::len)Word.word)) i'
       :: ( 'm::len)Word.word)) in
   (or_vec ((shiftl ((extz_vec r xs  :: ( 'r::len)Word.word)) l'  :: ( 'r::len)Word.word)) ((extz_vec r ys  :: ( 'r::len)Word.word))
     :: ( 'r::len)Word.word))))\<close> 
  for  r  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  l  :: " int " 
  and  ys  :: "('m::len)Word.word " 
  and  i'  :: " int " 
  and  l'  :: " int "


\<comment> \<open>\<open>val slice_zeros_concat : forall 'n 'p_plus_q. Size 'n, Size 'p_plus_q => mword 'n -> ii -> integer -> integer -> mword 'p_plus_q\<close>\<close>

definition slice_zeros_concat  :: \<open>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('p_plus_q::len)Word.word \<close>  where 
     \<open> slice_zeros_concat xs i l l' = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (shiftl ((extz_vec ((l + l')) xs  :: ( 'p_plus_q::len)Word.word)) l'  :: ( 'p_plus_q::len)Word.word)))\<close> 
  for  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  l  :: " int " 
  and  l'  :: " int "


\<comment> \<open>\<open>val subrange_zeros_concat : forall 'hi_minus_lo_plus_p1_plus_q 'n. Size 'hi_minus_lo_plus_p1_plus_q, Size 'n => mword 'n -> integer -> integer -> integer -> mword 'hi_minus_lo_plus_p1_plus_q\<close>\<close>

definition subrange_zeros_concat  :: \<open>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('hi_minus_lo_plus_p1_plus_q::len)Word.word \<close>  where 
     \<open> subrange_zeros_concat xs hi lo l' = (
   (slice_zeros_concat xs lo ((((hi - lo)) + (( 1 :: int)::ii))) l'
     :: ( 'hi_minus_lo_plus_p1_plus_q::len)Word.word))\<close> 
  for  xs  :: "('n::len)Word.word " 
  and  hi  :: " int " 
  and  lo  :: " int " 
  and  l'  :: " int "


\<comment> \<open>\<open>val subrange_subrange_eq : forall 'n. Size 'n => mword 'n -> ii -> ii -> mword 'n -> ii -> ii -> bool\<close>\<close>

definition subrange_subrange_eq  :: \<open>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> subrange_subrange_eq xs i j ys i' j' = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size ys))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j
       :: ( 'n::len)Word.word)) in
   (let ys =
     ((shiftr
        ((and_vec ys
            ((slice_mask ((int (size ys))) j' ((((i' - j')) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j'
       :: ( 'n::len)Word.word)) in
   (xs = ys))))\<close> 
  for  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  ys  :: "('n::len)Word.word " 
  and  i'  :: " int " 
  and  j'  :: " int "


\<comment> \<open>\<open>val subrange_subrange_concat : forall 'm 'n 's. Size 'm, Size 'n, Size 's => integer -> mword 'n -> integer -> integer -> mword 'm -> integer -> integer -> mword 's\<close>\<close>

definition subrange_subrange_concat  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('s::len)Word.word \<close>  where 
     \<open> subrange_subrange_concat s xs i j ys i' j' = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j
       :: ( 'n::len)Word.word)) in
   (let ys =
     ((shiftr
        ((and_vec ys
            ((slice_mask ((int (size ys))) j' ((((i' - j')) + (( 1 :: int)::ii)))  :: ( 'm::len)Word.word))
           :: ( 'm::len)Word.word)) j'
       :: ( 'm::len)Word.word)) in
   (or_vec
      ((shiftl ((extz_vec s xs  :: ( 's::len)Word.word)) ((((i' - j')) + (( 1 :: int)::ii)))
         :: ( 's::len)Word.word)) ((extz_vec s ys  :: ( 's::len)Word.word))
     :: ( 's::len)Word.word))))\<close> 
  for  s  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  ys  :: "('m::len)Word.word " 
  and  i'  :: " int " 
  and  j'  :: " int "


\<comment> \<open>\<open>val place_subrange : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm\<close>\<close>

definition place_subrange  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> place_subrange m xs i j shift = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j
       :: ( 'n::len)Word.word)) in
   (shiftl ((extz_vec m xs  :: ( 'm::len)Word.word)) shift  :: ( 'm::len)Word.word)))\<close> 
  for  m  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  shift  :: " int "


\<comment> \<open>\<open>val place_slice : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm\<close>\<close>

definition place_slice  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> place_slice m xs i l shift = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (shiftl ((extz_vec m xs  :: ( 'm::len)Word.word)) shift  :: ( 'm::len)Word.word)))\<close> 
  for  m  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  l  :: " int " 
  and  shift  :: " int "


\<comment> \<open>\<open>val set_slice_zeros : forall 'n. Size 'n => integer -> mword 'n -> ii -> ii -> mword 'n\<close>\<close>

definition set_slice_zeros  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> set_slice_zeros n xs i l = (
   (let (ys :: ( 'n::len)Word.word) = ((slice_mask n i l  :: ( 'n::len)Word.word)) in
   (and_vec xs ((not_vec ys  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)))\<close> 
  for  n  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  l  :: " int "


\<comment> \<open>\<open>val set_subrange_zeros : forall 'n. Size 'n => integer -> mword 'n -> ii -> ii -> mword 'n\<close>\<close>

definition set_subrange_zeros  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> set_subrange_zeros n xs hi lo = (
   (set_slice_zeros n xs lo ((((hi - lo)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))\<close> 
  for  n  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  hi  :: " int " 
  and  lo  :: " int "


\<comment> \<open>\<open>val zext_slice : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm\<close>\<close>

definition zext_slice  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> zext_slice m xs i l = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (extz_vec m xs  :: ( 'm::len)Word.word)))\<close> 
  for  m  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  l  :: " int "


\<comment> \<open>\<open>val zext_subrange : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm\<close>\<close>

definition zext_subrange  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> zext_subrange m xs i j = (
   (zext_slice m xs j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'm::len)Word.word))\<close> 
  for  m  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val sext_slice : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm\<close>\<close>

definition sext_slice  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> sext_slice m xs i l = (
   (let xs =
     ((arith_shiftr
        ((shiftl ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word))
            ((((((int (size xs))) - i)) - l))
           :: ( 'n::len)Word.word)) ((((int (size xs))) - l))
       :: ( 'n::len)Word.word)) in
   (exts_vec m xs  :: ( 'm::len)Word.word)))\<close> 
  for  m  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  l  :: " int "


\<comment> \<open>\<open>val sext_subrange : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm\<close>\<close>

definition sext_subrange  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> sext_subrange m xs i j = (
   (sext_slice m xs j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'm::len)Word.word))\<close> 
  for  m  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val place_slice_signed : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm\<close>\<close>

definition place_slice_signed  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> place_slice_signed m xs i l shift = (
   (shiftl ((sext_slice m xs i l  :: ( 'm::len)Word.word)) shift  :: ( 'm::len)Word.word))\<close> 
  for  m  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  l  :: " int " 
  and  shift  :: " int "


\<comment> \<open>\<open>val place_subrange_signed : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm\<close>\<close>

definition place_subrange_signed  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> place_subrange_signed m xs i j shift = (
   (place_slice_signed m xs j ((((i - j)) + (( 1 :: int)::ii))) shift  :: ( 'm::len)Word.word))\<close> 
  for  m  :: " int " 
  and  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int " 
  and  shift  :: " int "


\<comment> \<open>\<open>val unsigned_slice : forall 'n. Size 'n => mword 'n -> ii -> integer -> integer\<close>\<close>

definition unsigned_slice  :: \<open>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> unsigned_slice xs i l = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   ((Word.uint xs)) mod ((pow2 l))))\<close> 
  for  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  l  :: " int "


\<comment> \<open>\<open>val unsigned_subrange : forall 'n. Size 'n => mword 'n -> integer -> integer -> integer\<close>\<close>

definition unsigned_subrange  :: \<open>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> unsigned_subrange xs i j = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) i
       :: ( 'n::len)Word.word)) in
   ((Word.uint xs)) mod ((pow2 ((((i - j)) + (( 1 :: int)::ii)))))))\<close> 
  for  xs  :: "('n::len)Word.word " 
  and  i  :: " int " 
  and  j  :: " int "


\<comment> \<open>\<open>val zext_ones : forall 'n. Size 'n => integer -> ii -> mword 'n\<close>\<close>

definition zext_ones  :: \<open> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> zext_ones n m = (
   (let (v :: ( 'n::len)Word.word) = ((exts_vec ((id0 n)) ( 0b1 ::  1 Word.word)  :: ( 'n::len)Word.word)) in
   (shiftr v ((n - m))  :: ( 'n::len)Word.word)))\<close> 
  for  n  :: " int " 
  and  m  :: " int "


\<comment> \<open>\<open>val vector_update_subrange_from_subrange : forall 'n1 'n2. Size 'n1, Size 'n2 => integer -> mword 'n1 -> integer -> integer -> mword 'n2 -> integer -> integer -> mword 'n1\<close>\<close>

definition vector_update_subrange_from_subrange  :: \<open> int \<Rightarrow>('n1::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n2::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n1::len)Word.word \<close>  where 
     \<open> vector_update_subrange_from_subrange n v1 s1 e1 v2 s2 e2 = (
   (let xs =
     ((shiftr
        ((and_vec v2
            ((slice_mask ((int (size v2))) e2 ((((s2 - e2)) + (( 1 :: int)::ii)))  :: ( 'n2::len)Word.word))
           :: ( 'n2::len)Word.word)) e2
       :: ( 'n2::len)Word.word)) in
   (let xs = ((shiftl ((extz_vec n xs  :: ( 'n1::len)Word.word)) e1  :: ( 'n1::len)Word.word)) in
   (let ys =
     ((and_vec v1
        ((not_vec
            ((slice_mask ((int (size xs))) e1 ((((s1 - e1)) + (( 1 :: int)::ii)))  :: ( 'n1::len)Word.word))
           :: ( 'n1::len)Word.word))
       :: ( 'n1::len)Word.word)) in
   (or_vec xs ys  :: ( 'n1::len)Word.word)))))\<close> 
  for  n  :: " int " 
  and  v1  :: "('n1::len)Word.word " 
  and  s1  :: " int " 
  and  e1  :: " int " 
  and  v2  :: "('n2::len)Word.word " 
  and  s2  :: " int " 
  and  e2  :: " int "


\<comment> \<open>\<open>val vector_update_subrange_from_integer_subrange : forall 'n1. Size 'n1 => integer -> mword 'n1 -> integer -> integer -> ii -> integer -> integer -> mword 'n1\<close>\<close>

definition vector_update_subrange_from_integer_subrange  :: \<open> int \<Rightarrow>('n1::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n1::len)Word.word \<close>  where 
     \<open> vector_update_subrange_from_integer_subrange n1 v1 s1 e1 i s2 e2 = (
   (let (v2 :: ( 'n1::len)Word.word) = ((get_slice_int n1 i e2  :: ( 'n1::len)Word.word)) in
   (vector_update_subrange_from_subrange n1 v1 s1 e1 v2 ((s2 - e2)) (( 0 :: int)::ii)  :: ( 'n1::len)Word.word)))\<close> 
  for  n1  :: " int " 
  and  v1  :: "('n1::len)Word.word " 
  and  s1  :: " int " 
  and  e1  :: " int " 
  and  i  :: " int " 
  and  s2  :: " int " 
  and  e2  :: " int "


definition trace  :: \<open> bool \<close>  where 
     \<open> trace = ( False )\<close>


\<comment> \<open>\<open>val undefined_option : forall 'a. 'a -> M (maybe 'a)\<close>\<close>

definition undefined_option  :: \<open> 'a \<Rightarrow>((register_value),('a option),(exception))monad \<close>  where 
     \<open> undefined_option typ_a = (
   undefined_unit ()  \<bind> ((\<lambda> (u_0 :: unit) . 
   (let (u_1 :: 'a) = typ_a in
   internal_pick [Some u_1,None]))))\<close> 
  for  typ_a  :: " 'a "


\<comment> \<open>\<open>val is_none : forall 'a. maybe 'a -> bool\<close>\<close>

fun is_none  :: \<open> 'a option \<Rightarrow> bool \<close>  where 
     \<open> is_none (Some (_)) = ( False )\<close>
|\<open> is_none None = ( True )\<close>


\<comment> \<open>\<open>val is_some : forall 'a. maybe 'a -> bool\<close>\<close>

fun is_some  :: \<open> 'a option \<Rightarrow> bool \<close>  where 
     \<open> is_some (Some (_)) = ( True )\<close>
|\<open> is_some None = ( False )\<close>


\<comment> \<open>\<open>val concat_str_bits : forall 'n. Size 'n => string -> mword 'n -> string\<close>\<close>

definition concat_str_bits  :: \<open> string \<Rightarrow>('n::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> concat_str_bits str x = ( (@) str ((string_of_bits x)))\<close> 
  for  str  :: " string " 
  and  x  :: "('n::len)Word.word "


\<comment> \<open>\<open>val concat_str_dec : string -> ii -> string\<close>\<close>

definition concat_str_dec  :: \<open> string \<Rightarrow> int \<Rightarrow> string \<close>  where 
     \<open> concat_str_dec str x = ( (@) str ((dec_str x)))\<close> 
  for  str  :: " string " 
  and  x  :: " int "




\<comment> \<open>\<open>val cast_unit_vec : bitU -> mword ty1\<close>\<close>

fun cast_unit_vec0  :: \<open> bitU \<Rightarrow>(1)Word.word \<close>  where 
     \<open> cast_unit_vec0 B0 = ( ( 0b0 ::  1 Word.word))\<close>
|\<open> cast_unit_vec0 _ = ( ( 0b1 ::  1 Word.word))\<close>


\<comment> \<open>\<open>val __MIPS_write : forall 'p8_times_n. Size 'p8_times_n => mword ty64 -> integer -> mword 'p8_times_n -> M unit\<close>\<close>

definition MIPS_write  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('p8_times_n::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> MIPS_write addr width data = (
   write_ram (( 64 :: int)::ii) width ( 0x0000000000000000 ::  64 Word.word) addr data \<bind>  
  ((\<lambda>x .  (case  x of _ => return ()  ))) )\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  data  :: "('p8_times_n::len)Word.word "


\<comment> \<open>\<open>val __MIPS_read : forall 'p8_times_n. Size 'p8_times_n => mword ty64 -> integer -> M (mword 'p8_times_n)\<close>\<close>

definition MIPS_read  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('p8_times_n::len)Word.word),(exception))monad \<close>  where 
     \<open> MIPS_read addr width = (
   (read_ram (( 64 :: int)::ii) width ( 0x0000000000000000 ::  64 Word.word) addr  :: (( 'p8_times_n::len)Word.word) M))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int "




\<comment> \<open>\<open>val undefined_exception : unit -> M exception\<close>\<close>

definition undefined_exception  :: \<open> unit \<Rightarrow>((register_value),(exception),(exception))monad \<close>  where 
     \<open> undefined_exception _ = (
   undefined_string ()  \<bind> ((\<lambda> (u_0 :: string) . 
   undefined_unit ()  \<bind> ((\<lambda> (u_1 :: unit) . 
   internal_pick
     [ISAException u_1,Error_not_implemented u_0,Error_misaligned_access u_1,Error_EBREAK u_1,Error_internal_error u_1])))))\<close>


\<comment> \<open>\<open>val mips_sign_extend : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> mword 'm\<close>\<close>

\<comment> \<open>\<open>val mips_zero_extend : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> mword 'm\<close>\<close>

definition mips_sign_extend  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> mips_sign_extend m v = ( (sign_extend v m  :: ( 'm::len)Word.word))\<close> 
  for  m  :: " int " 
  and  v  :: "('n::len)Word.word "


definition mips_zero_extend  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> mips_zero_extend m v = ( (zero_extend v m  :: ( 'm::len)Word.word))\<close> 
  for  m  :: " int " 
  and  v  :: "('n::len)Word.word "


\<comment> \<open>\<open>val zeros_implicit : forall 'n. Size 'n => integer -> unit -> mword 'n\<close>\<close>

definition zeros_implicit  :: \<open> int \<Rightarrow> unit \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> zeros_implicit n _ = ( (zeros n  :: ( 'n::len)Word.word))\<close> 
  for  n  :: " int "


\<comment> \<open>\<open>val ones_implicit : forall 'n. Size 'n => integer -> unit -> mword 'n\<close>\<close>

definition ones_implicit  :: \<open> int \<Rightarrow> unit \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> ones_implicit n _ = ( (sail_ones n  :: ( 'n::len)Word.word))\<close> 
  for  n  :: " int "


\<comment> \<open>\<open>val zopz0zI_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zKzJ_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zI_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zKzJ_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

definition zopz0zI_s  :: \<open>('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> zopz0zI_s x y = ( ((Word.sint x)) < ((Word.sint y)))\<close> 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zKzJ_s  :: \<open>('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> zopz0zKzJ_s x y = ( ((Word.sint x)) \<ge> ((Word.sint y)))\<close> 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zI_u  :: \<open>('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> zopz0zI_u x y = ( ((Word.uint x)) < ((Word.uint y)))\<close> 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zKzJ_u  :: \<open>('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> zopz0zKzJ_u x y = ( ((Word.uint x)) \<ge> ((Word.uint y)))\<close> 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


\<comment> \<open>\<open>val bool_to_bits : bool -> mword ty1\<close>\<close>

definition bool_to_bits  :: \<open> bool \<Rightarrow>(1)Word.word \<close>  where 
     \<open> bool_to_bits x = ( if x then ( 0b1 ::  1 Word.word) else ( 0b0 ::  1 Word.word))\<close> 
  for  x  :: " bool "


\<comment> \<open>\<open>val bool_to_bit : bool -> bitU\<close>\<close>

definition bool_to_bit  :: \<open> bool \<Rightarrow> bitU \<close>  where 
     \<open> bool_to_bit x = ( if x then B1 else B0 )\<close> 
  for  x  :: " bool "


\<comment> \<open>\<open>val bit_to_bool : bitU -> bool\<close>\<close>

fun bit_to_bool  :: \<open> bitU \<Rightarrow> bool \<close>  where 
     \<open> bit_to_bool B1 = ( True )\<close>
|\<open> bit_to_bool _ = ( False )\<close>


\<comment> \<open>\<open>val bits_to_bool : mword ty1 -> bool\<close>\<close>

definition bits_to_bool  :: \<open>(1)Word.word \<Rightarrow> bool \<close>  where 
     \<open> bits_to_bool x = ( bit_to_bool ((access_vec_dec x (( 0 :: int)::ii))))\<close> 
  for  x  :: "(1)Word.word "


\<comment> \<open>\<open>
THIS`(l, v)` converts an integer, `v`,  to a bit vector of length `l`. If `v` is negative a twos-complement representation is used. If `v` is too large (or too negative) to fit in the requested length then it is truncated to the least significant bits.
\<close>\<close>
\<comment> \<open>\<open>val to_bits : forall 'l. Size 'l => integer -> ii -> mword 'l\<close>\<close>

definition to_bits  :: \<open> int \<Rightarrow> int \<Rightarrow>('l::len)Word.word \<close>  where 
     \<open> to_bits l n = ( (get_slice_int l n (( 0 :: int)::ii)  :: ( 'l::len)Word.word))\<close> 
  for  l  :: " int " 
  and  n  :: " int "


\<comment> \<open>\<open>val mask : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'm -> mword 'n\<close>\<close>

definition mask0  :: \<open> int \<Rightarrow>('m::len)Word.word \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> mask0 n bs = ( (subrange_vec_dec bs ((n - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'n::len)Word.word))\<close> 
  for  n  :: " int " 
  and  bs  :: "('m::len)Word.word "


\<comment> \<open>\<open>val undefined_CauseReg : unit -> M CauseReg\<close>\<close>

definition undefined_CauseReg  :: \<open> unit \<Rightarrow>((register_value),(CauseReg),(exception))monad \<close>  where 
     \<open> undefined_CauseReg _ = (
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   return ((| CauseReg_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_CauseReg : mword ty32 -> CauseReg\<close>\<close>

definition Mk_CauseReg  :: \<open>(32)Word.word \<Rightarrow> CauseReg \<close>  where 
     \<open> Mk_CauseReg v = ( (| CauseReg_bits = v |) )\<close> 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_CauseReg_bits : CauseReg -> mword ty32\<close>\<close>

definition get_CauseReg_bits  :: \<open> CauseReg \<Rightarrow>(32)Word.word \<close>  where 
     \<open> get_CauseReg_bits v = ( (subrange_vec_dec(CauseReg_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))\<close> 
  for  v  :: " CauseReg "


\<comment> \<open>\<open>val _set_CauseReg_bits : register_ref regstate register_value CauseReg -> mword ty32 -> M unit\<close>\<close>

definition set_CauseReg_bits  :: \<open>((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CauseReg_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   r) (( 31 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CauseReg))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_CauseReg_bits : CauseReg -> mword ty32 -> CauseReg\<close>\<close>

definition update_CauseReg_bits  :: \<open> CauseReg \<Rightarrow>(32)Word.word \<Rightarrow> CauseReg \<close>  where 
     \<open> update_CauseReg_bits v x = (
   ( v (|
     CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " CauseReg " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_CapCauseReg_bits : CapCauseReg -> mword ty16 -> CapCauseReg\<close>\<close>

\<comment> \<open>\<open>val _update_ContextReg_bits : ContextReg -> mword ty64 -> ContextReg\<close>\<close>

\<comment> \<open>\<open>val _update_StatusReg_bits : StatusReg -> mword ty32 -> StatusReg\<close>\<close>

\<comment> \<open>\<open>val _update_TLBEntryHiReg_bits : TLBEntryHiReg -> mword ty64 -> TLBEntryHiReg\<close>\<close>

\<comment> \<open>\<open>val _update_TLBEntryLoReg_bits : TLBEntryLoReg -> mword ty64 -> TLBEntryLoReg\<close>\<close>

\<comment> \<open>\<open>val _update_TLBEntry_bits : TLBEntry -> mword ty119 -> TLBEntry\<close>\<close>

\<comment> \<open>\<open>val _update_XContextReg_bits : XContextReg -> mword ty64 -> XContextReg\<close>\<close>

\<comment> \<open>\<open>val _get_CapCauseReg_bits : CapCauseReg -> mword ty16\<close>\<close>

\<comment> \<open>\<open>val _get_ContextReg_bits : ContextReg -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_StatusReg_bits : StatusReg -> mword ty32\<close>\<close>

\<comment> \<open>\<open>val _get_TLBEntryHiReg_bits : TLBEntryHiReg -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_TLBEntryLoReg_bits : TLBEntryLoReg -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_TLBEntry_bits : TLBEntry -> mword ty119\<close>\<close>

\<comment> \<open>\<open>val _get_XContextReg_bits : XContextReg -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _set_CapCauseReg_bits : register_ref regstate register_value CapCauseReg -> mword ty16 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_ContextReg_bits : register_ref regstate register_value ContextReg -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_StatusReg_bits : register_ref regstate register_value StatusReg -> mword ty32 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_TLBEntryHiReg_bits : register_ref regstate register_value TLBEntryHiReg -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_TLBEntryLoReg_bits : register_ref regstate register_value TLBEntryLoReg -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_TLBEntry_bits : register_ref regstate register_value TLBEntry -> mword ty119 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_XContextReg_bits : register_ref regstate register_value XContextReg -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_CauseReg_BD : CauseReg -> mword ty1\<close>\<close>

definition get_CauseReg_BD  :: \<open> CauseReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_CauseReg_BD v = ( (subrange_vec_dec(CauseReg_bits   v) (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " CauseReg "


\<comment> \<open>\<open>val _set_CauseReg_BD : register_ref regstate register_value CauseReg -> mword ty1 -> M unit\<close>\<close>

definition set_CauseReg_BD  :: \<open>((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CauseReg_BD r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   r) (( 31 :: int)::ii) (( 31 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CauseReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_CauseReg_BD : CauseReg -> mword ty1 -> CauseReg\<close>\<close>

definition update_CauseReg_BD  :: \<open> CauseReg \<Rightarrow>(1)Word.word \<Rightarrow> CauseReg \<close>  where 
     \<open> update_CauseReg_BD v x = (
   ( v (|
     CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   v) (( 31 :: int)::ii) (( 31 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " CauseReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_CauseReg_CE : CauseReg -> mword ty2\<close>\<close>

definition get_CauseReg_CE  :: \<open> CauseReg \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_CauseReg_CE v = ( (subrange_vec_dec(CauseReg_bits   v) (( 29 :: int)::ii) (( 28 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " CauseReg "


\<comment> \<open>\<open>val _set_CauseReg_CE : register_ref regstate register_value CauseReg -> mword ty2 -> M unit\<close>\<close>

definition set_CauseReg_CE  :: \<open>((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CauseReg_CE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   r) (( 29 :: int)::ii) (( 28 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CauseReg))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_CauseReg_CE : CauseReg -> mword ty2 -> CauseReg\<close>\<close>

definition update_CauseReg_CE  :: \<open> CauseReg \<Rightarrow>(2)Word.word \<Rightarrow> CauseReg \<close>  where 
     \<open> update_CauseReg_CE v x = (
   ( v (|
     CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   v) (( 29 :: int)::ii) (( 28 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " CauseReg " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_CauseReg_ExcCode : CauseReg -> mword ty5\<close>\<close>

definition get_CauseReg_ExcCode  :: \<open> CauseReg \<Rightarrow>(5)Word.word \<close>  where 
     \<open> get_CauseReg_ExcCode v = ( (subrange_vec_dec(CauseReg_bits   v) (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word))\<close> 
  for  v  :: " CauseReg "


\<comment> \<open>\<open>val _set_CauseReg_ExcCode : register_ref regstate register_value CauseReg -> mword ty5 -> M unit\<close>\<close>

definition set_CauseReg_ExcCode  :: \<open>((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CauseReg_ExcCode r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   r) (( 6 :: int)::ii) (( 2 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CauseReg))register_ref " 
  and  v  :: "(5)Word.word "


\<comment> \<open>\<open>val _update_CauseReg_ExcCode : CauseReg -> mword ty5 -> CauseReg\<close>\<close>

definition update_CauseReg_ExcCode  :: \<open> CauseReg \<Rightarrow>(5)Word.word \<Rightarrow> CauseReg \<close>  where 
     \<open> update_CauseReg_ExcCode v x = (
   ( v (|
     CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   v) (( 6 :: int)::ii) (( 2 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " CauseReg " 
  and  x  :: "(5)Word.word "


\<comment> \<open>\<open>val _update_CapCauseReg_ExcCode : CapCauseReg -> mword ty8 -> CapCauseReg\<close>\<close>

\<comment> \<open>\<open>val _get_CapCauseReg_ExcCode : CapCauseReg -> mword ty8\<close>\<close>

\<comment> \<open>\<open>val _set_CapCauseReg_ExcCode : register_ref regstate register_value CapCauseReg -> mword ty8 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_CauseReg_IP : CauseReg -> mword ty8\<close>\<close>

definition get_CauseReg_IP  :: \<open> CauseReg \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_CauseReg_IP v = ( (subrange_vec_dec(CauseReg_bits   v) (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " CauseReg "


\<comment> \<open>\<open>val _set_CauseReg_IP : register_ref regstate register_value CauseReg -> mword ty8 -> M unit\<close>\<close>

definition set_CauseReg_IP  :: \<open>((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CauseReg_IP r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   r) (( 15 :: int)::ii) (( 8 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CauseReg))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_CauseReg_IP : CauseReg -> mword ty8 -> CauseReg\<close>\<close>

definition update_CauseReg_IP  :: \<open> CauseReg \<Rightarrow>(8)Word.word \<Rightarrow> CauseReg \<close>  where 
     \<open> update_CauseReg_IP v x = (
   ( v (|
     CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   v) (( 15 :: int)::ii) (( 8 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " CauseReg " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_CauseReg_IV : CauseReg -> mword ty1\<close>\<close>

definition get_CauseReg_IV  :: \<open> CauseReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_CauseReg_IV v = ( (subrange_vec_dec(CauseReg_bits   v) (( 23 :: int)::ii) (( 23 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " CauseReg "


\<comment> \<open>\<open>val _set_CauseReg_IV : register_ref regstate register_value CauseReg -> mword ty1 -> M unit\<close>\<close>

definition set_CauseReg_IV  :: \<open>((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CauseReg_IV r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   r) (( 23 :: int)::ii) (( 23 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CauseReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_CauseReg_IV : CauseReg -> mword ty1 -> CauseReg\<close>\<close>

definition update_CauseReg_IV  :: \<open> CauseReg \<Rightarrow>(1)Word.word \<Rightarrow> CauseReg \<close>  where 
     \<open> update_CauseReg_IV v x = (
   ( v (|
     CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   v) (( 23 :: int)::ii) (( 23 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " CauseReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_CauseReg_WP : CauseReg -> mword ty1\<close>\<close>

definition get_CauseReg_WP  :: \<open> CauseReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_CauseReg_WP v = ( (subrange_vec_dec(CauseReg_bits   v) (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " CauseReg "


\<comment> \<open>\<open>val _set_CauseReg_WP : register_ref regstate register_value CauseReg -> mword ty1 -> M unit\<close>\<close>

definition set_CauseReg_WP  :: \<open>((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CauseReg_WP r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   r) (( 22 :: int)::ii) (( 22 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CauseReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_CauseReg_WP : CauseReg -> mword ty1 -> CauseReg\<close>\<close>

definition update_CauseReg_WP  :: \<open> CauseReg \<Rightarrow>(1)Word.word \<Rightarrow> CauseReg \<close>  where 
     \<open> update_CauseReg_WP v x = (
   ( v (|
     CauseReg_bits := ((update_subrange_vec_dec(CauseReg_bits   v) (( 22 :: int)::ii) (( 22 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " CauseReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val undefined_TLBEntryLoReg : unit -> M TLBEntryLoReg\<close>\<close>

definition undefined_TLBEntryLoReg  :: \<open> unit \<Rightarrow>((register_value),(TLBEntryLoReg),(exception))monad \<close>  where 
     \<open> undefined_TLBEntryLoReg _ = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   return ((| TLBEntryLoReg_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_TLBEntryLoReg : mword ty64 -> TLBEntryLoReg\<close>\<close>

definition Mk_TLBEntryLoReg  :: \<open>(64)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> Mk_TLBEntryLoReg v = ( (| TLBEntryLoReg_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_TLBEntryLoReg_bits  :: \<open> TLBEntryLoReg \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_TLBEntryLoReg_bits v = ( (subrange_vec_dec(TLBEntryLoReg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " TLBEntryLoReg "


definition set_TLBEntryLoReg_bits  :: \<open>((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryLoReg_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryLoReg_bits :=
         ((update_subrange_vec_dec(TLBEntryLoReg_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref " 
  and  v  :: "(64)Word.word "


definition update_TLBEntryLoReg_bits  :: \<open> TLBEntryLoReg \<Rightarrow>(64)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> update_TLBEntryLoReg_bits v x = (
   ( v (|
     TLBEntryLoReg_bits :=
       ((update_subrange_vec_dec(TLBEntryLoReg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryLoReg " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryLoReg_C : TLBEntryLoReg -> mword ty3\<close>\<close>

definition get_TLBEntryLoReg_C  :: \<open> TLBEntryLoReg \<Rightarrow>(3)Word.word \<close>  where 
     \<open> get_TLBEntryLoReg_C v = ( (subrange_vec_dec(TLBEntryLoReg_bits   v) (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word))\<close> 
  for  v  :: " TLBEntryLoReg "


\<comment> \<open>\<open>val _set_TLBEntryLoReg_C : register_ref regstate register_value TLBEntryLoReg -> mword ty3 -> M unit\<close>\<close>

definition set_TLBEntryLoReg_C  :: \<open>((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryLoReg_C r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryLoReg_bits :=
         ((update_subrange_vec_dec(TLBEntryLoReg_bits   r) (( 5 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref " 
  and  v  :: "(3)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryLoReg_C : TLBEntryLoReg -> mword ty3 -> TLBEntryLoReg\<close>\<close>

definition update_TLBEntryLoReg_C  :: \<open> TLBEntryLoReg \<Rightarrow>(3)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> update_TLBEntryLoReg_C v x = (
   ( v (|
     TLBEntryLoReg_bits :=
       ((update_subrange_vec_dec(TLBEntryLoReg_bits   v) (( 5 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryLoReg " 
  and  x  :: "(3)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryLoReg_CapL : TLBEntryLoReg -> mword ty1\<close>\<close>

definition get_TLBEntryLoReg_CapL  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntryLoReg_CapL v = ( (subrange_vec_dec(TLBEntryLoReg_bits   v) (( 62 :: int)::ii) (( 62 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntryLoReg "


\<comment> \<open>\<open>val _set_TLBEntryLoReg_CapL : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntryLoReg_CapL  :: \<open>((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryLoReg_CapL r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryLoReg_bits :=
         ((update_subrange_vec_dec(TLBEntryLoReg_bits   r) (( 62 :: int)::ii) (( 62 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryLoReg_CapL : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg\<close>\<close>

definition update_TLBEntryLoReg_CapL  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> update_TLBEntryLoReg_CapL v x = (
   ( v (|
     TLBEntryLoReg_bits :=
       ((update_subrange_vec_dec(TLBEntryLoReg_bits   v) (( 62 :: int)::ii) (( 62 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryLoReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryLoReg_CapLG : TLBEntryLoReg -> mword ty1\<close>\<close>

definition get_TLBEntryLoReg_CapLG  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntryLoReg_CapLG v = (
   (subrange_vec_dec(TLBEntryLoReg_bits   v) (( 61 :: int)::ii) (( 61 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntryLoReg "


\<comment> \<open>\<open>val _set_TLBEntryLoReg_CapLG : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntryLoReg_CapLG  :: \<open>((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryLoReg_CapLG r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryLoReg_bits :=
         ((update_subrange_vec_dec(TLBEntryLoReg_bits   r) (( 61 :: int)::ii) (( 61 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryLoReg_CapLG : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg\<close>\<close>

definition update_TLBEntryLoReg_CapLG  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> update_TLBEntryLoReg_CapLG v x = (
   ( v (|
     TLBEntryLoReg_bits :=
       ((update_subrange_vec_dec(TLBEntryLoReg_bits   v) (( 61 :: int)::ii) (( 61 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryLoReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryLoReg_CapS : TLBEntryLoReg -> mword ty1\<close>\<close>

definition get_TLBEntryLoReg_CapS  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntryLoReg_CapS v = ( (subrange_vec_dec(TLBEntryLoReg_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntryLoReg "


\<comment> \<open>\<open>val _set_TLBEntryLoReg_CapS : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntryLoReg_CapS  :: \<open>((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryLoReg_CapS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryLoReg_bits :=
         ((update_subrange_vec_dec(TLBEntryLoReg_bits   r) (( 63 :: int)::ii) (( 63 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryLoReg_CapS : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg\<close>\<close>

definition update_TLBEntryLoReg_CapS  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> update_TLBEntryLoReg_CapS v x = (
   ( v (|
     TLBEntryLoReg_bits :=
       ((update_subrange_vec_dec(TLBEntryLoReg_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryLoReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryLoReg_D : TLBEntryLoReg -> mword ty1\<close>\<close>

definition get_TLBEntryLoReg_D  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntryLoReg_D v = ( (subrange_vec_dec(TLBEntryLoReg_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntryLoReg "


\<comment> \<open>\<open>val _set_TLBEntryLoReg_D : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntryLoReg_D  :: \<open>((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryLoReg_D r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryLoReg_bits :=
         ((update_subrange_vec_dec(TLBEntryLoReg_bits   r) (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryLoReg_D : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg\<close>\<close>

definition update_TLBEntryLoReg_D  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> update_TLBEntryLoReg_D v x = (
   ( v (|
     TLBEntryLoReg_bits :=
       ((update_subrange_vec_dec(TLBEntryLoReg_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryLoReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryLoReg_G : TLBEntryLoReg -> mword ty1\<close>\<close>

definition get_TLBEntryLoReg_G  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntryLoReg_G v = ( (subrange_vec_dec(TLBEntryLoReg_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntryLoReg "


\<comment> \<open>\<open>val _set_TLBEntryLoReg_G : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntryLoReg_G  :: \<open>((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryLoReg_G r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryLoReg_bits :=
         ((update_subrange_vec_dec(TLBEntryLoReg_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryLoReg_G : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg\<close>\<close>

definition update_TLBEntryLoReg_G  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> update_TLBEntryLoReg_G v x = (
   ( v (|
     TLBEntryLoReg_bits :=
       ((update_subrange_vec_dec(TLBEntryLoReg_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryLoReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryLoReg_PFN : TLBEntryLoReg -> mword ty24\<close>\<close>

definition get_TLBEntryLoReg_PFN  :: \<open> TLBEntryLoReg \<Rightarrow>(24)Word.word \<close>  where 
     \<open> get_TLBEntryLoReg_PFN v = ( (subrange_vec_dec(TLBEntryLoReg_bits   v) (( 29 :: int)::ii) (( 6 :: int)::ii)  ::  24 Word.word))\<close> 
  for  v  :: " TLBEntryLoReg "


\<comment> \<open>\<open>val _set_TLBEntryLoReg_PFN : register_ref regstate register_value TLBEntryLoReg -> mword ty24 -> M unit\<close>\<close>

definition set_TLBEntryLoReg_PFN  :: \<open>((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryLoReg_PFN r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryLoReg_bits :=
         ((update_subrange_vec_dec(TLBEntryLoReg_bits   r) (( 29 :: int)::ii) (( 6 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref " 
  and  v  :: "(24)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryLoReg_PFN : TLBEntryLoReg -> mword ty24 -> TLBEntryLoReg\<close>\<close>

definition update_TLBEntryLoReg_PFN  :: \<open> TLBEntryLoReg \<Rightarrow>(24)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> update_TLBEntryLoReg_PFN v x = (
   ( v (|
     TLBEntryLoReg_bits :=
       ((update_subrange_vec_dec(TLBEntryLoReg_bits   v) (( 29 :: int)::ii) (( 6 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryLoReg " 
  and  x  :: "(24)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryLoReg_V : TLBEntryLoReg -> mword ty1\<close>\<close>

definition get_TLBEntryLoReg_V  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntryLoReg_V v = ( (subrange_vec_dec(TLBEntryLoReg_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntryLoReg "


\<comment> \<open>\<open>val _set_TLBEntryLoReg_V : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntryLoReg_V  :: \<open>((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryLoReg_V r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryLoReg_bits :=
         ((update_subrange_vec_dec(TLBEntryLoReg_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryLoReg_V : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg\<close>\<close>

definition update_TLBEntryLoReg_V  :: \<open> TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg \<close>  where 
     \<open> update_TLBEntryLoReg_V v x = (
   ( v (|
     TLBEntryLoReg_bits :=
       ((update_subrange_vec_dec(TLBEntryLoReg_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryLoReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val undefined_TLBEntryHiReg : unit -> M TLBEntryHiReg\<close>\<close>

definition undefined_TLBEntryHiReg  :: \<open> unit \<Rightarrow>((register_value),(TLBEntryHiReg),(exception))monad \<close>  where 
     \<open> undefined_TLBEntryHiReg _ = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   return ((| TLBEntryHiReg_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_TLBEntryHiReg : mword ty64 -> TLBEntryHiReg\<close>\<close>

definition Mk_TLBEntryHiReg  :: \<open>(64)Word.word \<Rightarrow> TLBEntryHiReg \<close>  where 
     \<open> Mk_TLBEntryHiReg v = ( (| TLBEntryHiReg_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_TLBEntryHiReg_bits  :: \<open> TLBEntryHiReg \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_TLBEntryHiReg_bits v = ( (subrange_vec_dec(TLBEntryHiReg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " TLBEntryHiReg "


definition set_TLBEntryHiReg_bits  :: \<open>((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryHiReg_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryHiReg_bits :=
         ((update_subrange_vec_dec(TLBEntryHiReg_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref " 
  and  v  :: "(64)Word.word "


definition update_TLBEntryHiReg_bits  :: \<open> TLBEntryHiReg \<Rightarrow>(64)Word.word \<Rightarrow> TLBEntryHiReg \<close>  where 
     \<open> update_TLBEntryHiReg_bits v x = (
   ( v (|
     TLBEntryHiReg_bits :=
       ((update_subrange_vec_dec(TLBEntryHiReg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryHiReg " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryHiReg_ASID : TLBEntryHiReg -> mword ty8\<close>\<close>

definition get_TLBEntryHiReg_ASID  :: \<open> TLBEntryHiReg \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_TLBEntryHiReg_ASID v = ( (subrange_vec_dec(TLBEntryHiReg_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " TLBEntryHiReg "


\<comment> \<open>\<open>val _set_TLBEntryHiReg_ASID : register_ref regstate register_value TLBEntryHiReg -> mword ty8 -> M unit\<close>\<close>

definition set_TLBEntryHiReg_ASID  :: \<open>((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryHiReg_ASID r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryHiReg_bits :=
         ((update_subrange_vec_dec(TLBEntryHiReg_bits   r) (( 7 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryHiReg_ASID : TLBEntryHiReg -> mword ty8 -> TLBEntryHiReg\<close>\<close>

definition update_TLBEntryHiReg_ASID  :: \<open> TLBEntryHiReg \<Rightarrow>(8)Word.word \<Rightarrow> TLBEntryHiReg \<close>  where 
     \<open> update_TLBEntryHiReg_ASID v x = (
   ( v (|
     TLBEntryHiReg_bits :=
       ((update_subrange_vec_dec(TLBEntryHiReg_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryHiReg " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryHiReg_CLGK : TLBEntryHiReg -> mword ty1\<close>\<close>

definition get_TLBEntryHiReg_CLGK  :: \<open> TLBEntryHiReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntryHiReg_CLGK v = ( (subrange_vec_dec(TLBEntryHiReg_bits   v) (( 61 :: int)::ii) (( 61 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntryHiReg "


\<comment> \<open>\<open>val _set_TLBEntryHiReg_CLGK : register_ref regstate register_value TLBEntryHiReg -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntryHiReg_CLGK  :: \<open>((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryHiReg_CLGK r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryHiReg_bits :=
         ((update_subrange_vec_dec(TLBEntryHiReg_bits   r) (( 61 :: int)::ii) (( 61 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryHiReg_CLGK : TLBEntryHiReg -> mword ty1 -> TLBEntryHiReg\<close>\<close>

definition update_TLBEntryHiReg_CLGK  :: \<open> TLBEntryHiReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryHiReg \<close>  where 
     \<open> update_TLBEntryHiReg_CLGK v x = (
   ( v (|
     TLBEntryHiReg_bits :=
       ((update_subrange_vec_dec(TLBEntryHiReg_bits   v) (( 61 :: int)::ii) (( 61 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryHiReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryHiReg_CLGS : TLBEntryHiReg -> mword ty1\<close>\<close>

definition get_TLBEntryHiReg_CLGS  :: \<open> TLBEntryHiReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntryHiReg_CLGS v = ( (subrange_vec_dec(TLBEntryHiReg_bits   v) (( 60 :: int)::ii) (( 60 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntryHiReg "


\<comment> \<open>\<open>val _set_TLBEntryHiReg_CLGS : register_ref regstate register_value TLBEntryHiReg -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntryHiReg_CLGS  :: \<open>((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryHiReg_CLGS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryHiReg_bits :=
         ((update_subrange_vec_dec(TLBEntryHiReg_bits   r) (( 60 :: int)::ii) (( 60 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryHiReg_CLGS : TLBEntryHiReg -> mword ty1 -> TLBEntryHiReg\<close>\<close>

definition update_TLBEntryHiReg_CLGS  :: \<open> TLBEntryHiReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryHiReg \<close>  where 
     \<open> update_TLBEntryHiReg_CLGS v x = (
   ( v (|
     TLBEntryHiReg_bits :=
       ((update_subrange_vec_dec(TLBEntryHiReg_bits   v) (( 60 :: int)::ii) (( 60 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryHiReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryHiReg_CLGU : TLBEntryHiReg -> mword ty1\<close>\<close>

definition get_TLBEntryHiReg_CLGU  :: \<open> TLBEntryHiReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntryHiReg_CLGU v = ( (subrange_vec_dec(TLBEntryHiReg_bits   v) (( 59 :: int)::ii) (( 59 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntryHiReg "


\<comment> \<open>\<open>val _set_TLBEntryHiReg_CLGU : register_ref regstate register_value TLBEntryHiReg -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntryHiReg_CLGU  :: \<open>((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryHiReg_CLGU r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryHiReg_bits :=
         ((update_subrange_vec_dec(TLBEntryHiReg_bits   r) (( 59 :: int)::ii) (( 59 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryHiReg_CLGU : TLBEntryHiReg -> mword ty1 -> TLBEntryHiReg\<close>\<close>

definition update_TLBEntryHiReg_CLGU  :: \<open> TLBEntryHiReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryHiReg \<close>  where 
     \<open> update_TLBEntryHiReg_CLGU v x = (
   ( v (|
     TLBEntryHiReg_bits :=
       ((update_subrange_vec_dec(TLBEntryHiReg_bits   v) (( 59 :: int)::ii) (( 59 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryHiReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryHiReg_R : TLBEntryHiReg -> mword ty2\<close>\<close>

definition get_TLBEntryHiReg_R  :: \<open> TLBEntryHiReg \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_TLBEntryHiReg_R v = ( (subrange_vec_dec(TLBEntryHiReg_bits   v) (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " TLBEntryHiReg "


\<comment> \<open>\<open>val _set_TLBEntryHiReg_R : register_ref regstate register_value TLBEntryHiReg -> mword ty2 -> M unit\<close>\<close>

definition set_TLBEntryHiReg_R  :: \<open>((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryHiReg_R r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryHiReg_bits :=
         ((update_subrange_vec_dec(TLBEntryHiReg_bits   r) (( 63 :: int)::ii) (( 62 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryHiReg_R : TLBEntryHiReg -> mword ty2 -> TLBEntryHiReg\<close>\<close>

definition update_TLBEntryHiReg_R  :: \<open> TLBEntryHiReg \<Rightarrow>(2)Word.word \<Rightarrow> TLBEntryHiReg \<close>  where 
     \<open> update_TLBEntryHiReg_R v x = (
   ( v (|
     TLBEntryHiReg_bits :=
       ((update_subrange_vec_dec(TLBEntryHiReg_bits   v) (( 63 :: int)::ii) (( 62 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryHiReg " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_TLBEntryHiReg_VPN2 : TLBEntryHiReg -> mword ty27\<close>\<close>

definition get_TLBEntryHiReg_VPN2  :: \<open> TLBEntryHiReg \<Rightarrow>(27)Word.word \<close>  where 
     \<open> get_TLBEntryHiReg_VPN2 v = (
   (subrange_vec_dec(TLBEntryHiReg_bits   v) (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word))\<close> 
  for  v  :: " TLBEntryHiReg "


\<comment> \<open>\<open>val _set_TLBEntryHiReg_VPN2 : register_ref regstate register_value TLBEntryHiReg -> mword ty27 -> M unit\<close>\<close>

definition set_TLBEntryHiReg_VPN2  :: \<open>((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntryHiReg_VPN2 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntryHiReg_bits :=
         ((update_subrange_vec_dec(TLBEntryHiReg_bits   r) (( 39 :: int)::ii) (( 13 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref " 
  and  v  :: "(27)Word.word "


\<comment> \<open>\<open>val _update_TLBEntryHiReg_VPN2 : TLBEntryHiReg -> mword ty27 -> TLBEntryHiReg\<close>\<close>

definition update_TLBEntryHiReg_VPN2  :: \<open> TLBEntryHiReg \<Rightarrow>(27)Word.word \<Rightarrow> TLBEntryHiReg \<close>  where 
     \<open> update_TLBEntryHiReg_VPN2 v x = (
   ( v (|
     TLBEntryHiReg_bits :=
       ((update_subrange_vec_dec(TLBEntryHiReg_bits   v) (( 39 :: int)::ii) (( 13 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " TLBEntryHiReg " 
  and  x  :: "(27)Word.word "


\<comment> \<open>\<open>val undefined_ContextReg : unit -> M ContextReg\<close>\<close>

definition undefined_ContextReg  :: \<open> unit \<Rightarrow>((register_value),(ContextReg),(exception))monad \<close>  where 
     \<open> undefined_ContextReg _ = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   return ((| ContextReg_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_ContextReg : mword ty64 -> ContextReg\<close>\<close>

definition Mk_ContextReg  :: \<open>(64)Word.word \<Rightarrow> ContextReg \<close>  where 
     \<open> Mk_ContextReg v = ( (| ContextReg_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_ContextReg_bits  :: \<open> ContextReg \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_ContextReg_bits v = ( (subrange_vec_dec(ContextReg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " ContextReg "


definition set_ContextReg_bits  :: \<open>((regstate),(register_value),(ContextReg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_ContextReg_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       ContextReg_bits :=
         ((update_subrange_vec_dec(ContextReg_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(ContextReg))register_ref " 
  and  v  :: "(64)Word.word "


definition update_ContextReg_bits  :: \<open> ContextReg \<Rightarrow>(64)Word.word \<Rightarrow> ContextReg \<close>  where 
     \<open> update_ContextReg_bits v x = (
   ( v (|
     ContextReg_bits := ((update_subrange_vec_dec(ContextReg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " ContextReg " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_ContextReg_BadVPN2 : ContextReg -> mword ty19\<close>\<close>

definition get_ContextReg_BadVPN2  :: \<open> ContextReg \<Rightarrow>(19)Word.word \<close>  where 
     \<open> get_ContextReg_BadVPN2 v = ( (subrange_vec_dec(ContextReg_bits   v) (( 22 :: int)::ii) (( 4 :: int)::ii)  ::  19 Word.word))\<close> 
  for  v  :: " ContextReg "


\<comment> \<open>\<open>val _set_ContextReg_BadVPN2 : register_ref regstate register_value ContextReg -> mword ty19 -> M unit\<close>\<close>

definition set_ContextReg_BadVPN2  :: \<open>((regstate),(register_value),(ContextReg))register_ref \<Rightarrow>(19)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_ContextReg_BadVPN2 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       ContextReg_bits :=
         ((update_subrange_vec_dec(ContextReg_bits   r) (( 22 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(ContextReg))register_ref " 
  and  v  :: "(19)Word.word "


\<comment> \<open>\<open>val _update_ContextReg_BadVPN2 : ContextReg -> mword ty19 -> ContextReg\<close>\<close>

definition update_ContextReg_BadVPN2  :: \<open> ContextReg \<Rightarrow>(19)Word.word \<Rightarrow> ContextReg \<close>  where 
     \<open> update_ContextReg_BadVPN2 v x = (
   ( v (|
     ContextReg_bits := ((update_subrange_vec_dec(ContextReg_bits   v) (( 22 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " ContextReg " 
  and  x  :: "(19)Word.word "


\<comment> \<open>\<open>val _get_ContextReg_PTEBase : ContextReg -> mword ty41\<close>\<close>

definition get_ContextReg_PTEBase  :: \<open> ContextReg \<Rightarrow>(41)Word.word \<close>  where 
     \<open> get_ContextReg_PTEBase v = ( (subrange_vec_dec(ContextReg_bits   v) (( 63 :: int)::ii) (( 23 :: int)::ii)  ::  41 Word.word))\<close> 
  for  v  :: " ContextReg "


\<comment> \<open>\<open>val _set_ContextReg_PTEBase : register_ref regstate register_value ContextReg -> mword ty41 -> M unit\<close>\<close>

definition set_ContextReg_PTEBase  :: \<open>((regstate),(register_value),(ContextReg))register_ref \<Rightarrow>(41)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_ContextReg_PTEBase r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       ContextReg_bits :=
         ((update_subrange_vec_dec(ContextReg_bits   r) (( 63 :: int)::ii) (( 23 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(ContextReg))register_ref " 
  and  v  :: "(41)Word.word "


\<comment> \<open>\<open>val _update_ContextReg_PTEBase : ContextReg -> mword ty41 -> ContextReg\<close>\<close>

definition update_ContextReg_PTEBase  :: \<open> ContextReg \<Rightarrow>(41)Word.word \<Rightarrow> ContextReg \<close>  where 
     \<open> update_ContextReg_PTEBase v x = (
   ( v (|
     ContextReg_bits := ((update_subrange_vec_dec(ContextReg_bits   v) (( 63 :: int)::ii) (( 23 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " ContextReg " 
  and  x  :: "(41)Word.word "


\<comment> \<open>\<open>val undefined_XContextReg : unit -> M XContextReg\<close>\<close>

definition undefined_XContextReg  :: \<open> unit \<Rightarrow>((register_value),(XContextReg),(exception))monad \<close>  where 
     \<open> undefined_XContextReg _ = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   return ((| XContextReg_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_XContextReg : mword ty64 -> XContextReg\<close>\<close>

definition Mk_XContextReg  :: \<open>(64)Word.word \<Rightarrow> XContextReg \<close>  where 
     \<open> Mk_XContextReg v = ( (| XContextReg_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_XContextReg_bits  :: \<open> XContextReg \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_XContextReg_bits v = ( (subrange_vec_dec(XContextReg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " XContextReg "


definition set_XContextReg_bits  :: \<open>((regstate),(register_value),(XContextReg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_XContextReg_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       XContextReg_bits :=
         ((update_subrange_vec_dec(XContextReg_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(XContextReg))register_ref " 
  and  v  :: "(64)Word.word "


definition update_XContextReg_bits  :: \<open> XContextReg \<Rightarrow>(64)Word.word \<Rightarrow> XContextReg \<close>  where 
     \<open> update_XContextReg_bits v x = (
   ( v (|
     XContextReg_bits :=
       ((update_subrange_vec_dec(XContextReg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " XContextReg " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_XContextReg_XBadVPN2 : XContextReg -> mword ty27\<close>\<close>

definition get_XContextReg_XBadVPN2  :: \<open> XContextReg \<Rightarrow>(27)Word.word \<close>  where 
     \<open> get_XContextReg_XBadVPN2 v = ( (subrange_vec_dec(XContextReg_bits   v) (( 30 :: int)::ii) (( 4 :: int)::ii)  ::  27 Word.word))\<close> 
  for  v  :: " XContextReg "


\<comment> \<open>\<open>val _set_XContextReg_XBadVPN2 : register_ref regstate register_value XContextReg -> mword ty27 -> M unit\<close>\<close>

definition set_XContextReg_XBadVPN2  :: \<open>((regstate),(register_value),(XContextReg))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_XContextReg_XBadVPN2 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       XContextReg_bits :=
         ((update_subrange_vec_dec(XContextReg_bits   r) (( 30 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(XContextReg))register_ref " 
  and  v  :: "(27)Word.word "


\<comment> \<open>\<open>val _update_XContextReg_XBadVPN2 : XContextReg -> mword ty27 -> XContextReg\<close>\<close>

definition update_XContextReg_XBadVPN2  :: \<open> XContextReg \<Rightarrow>(27)Word.word \<Rightarrow> XContextReg \<close>  where 
     \<open> update_XContextReg_XBadVPN2 v x = (
   ( v (|
     XContextReg_bits :=
       ((update_subrange_vec_dec(XContextReg_bits   v) (( 30 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " XContextReg " 
  and  x  :: "(27)Word.word "


\<comment> \<open>\<open>val _get_XContextReg_XPTEBase : XContextReg -> mword ty31\<close>\<close>

definition get_XContextReg_XPTEBase  :: \<open> XContextReg \<Rightarrow>(31)Word.word \<close>  where 
     \<open> get_XContextReg_XPTEBase v = (
   (subrange_vec_dec(XContextReg_bits   v) (( 63 :: int)::ii) (( 33 :: int)::ii)  ::  31 Word.word))\<close> 
  for  v  :: " XContextReg "


\<comment> \<open>\<open>val _set_XContextReg_XPTEBase : register_ref regstate register_value XContextReg -> mword ty31 -> M unit\<close>\<close>

definition set_XContextReg_XPTEBase  :: \<open>((regstate),(register_value),(XContextReg))register_ref \<Rightarrow>(31)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_XContextReg_XPTEBase r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       XContextReg_bits :=
         ((update_subrange_vec_dec(XContextReg_bits   r) (( 63 :: int)::ii) (( 33 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(XContextReg))register_ref " 
  and  v  :: "(31)Word.word "


\<comment> \<open>\<open>val _update_XContextReg_XPTEBase : XContextReg -> mword ty31 -> XContextReg\<close>\<close>

definition update_XContextReg_XPTEBase  :: \<open> XContextReg \<Rightarrow>(31)Word.word \<Rightarrow> XContextReg \<close>  where 
     \<open> update_XContextReg_XPTEBase v x = (
   ( v (|
     XContextReg_bits :=
       ((update_subrange_vec_dec(XContextReg_bits   v) (( 63 :: int)::ii) (( 33 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " XContextReg " 
  and  x  :: "(31)Word.word "


\<comment> \<open>\<open>val _get_XContextReg_XR : XContextReg -> mword ty2\<close>\<close>

definition get_XContextReg_XR  :: \<open> XContextReg \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_XContextReg_XR v = ( (subrange_vec_dec(XContextReg_bits   v) (( 32 :: int)::ii) (( 31 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " XContextReg "


\<comment> \<open>\<open>val _set_XContextReg_XR : register_ref regstate register_value XContextReg -> mword ty2 -> M unit\<close>\<close>

definition set_XContextReg_XR  :: \<open>((regstate),(register_value),(XContextReg))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_XContextReg_XR r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       XContextReg_bits :=
         ((update_subrange_vec_dec(XContextReg_bits   r) (( 32 :: int)::ii) (( 31 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(XContextReg))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_XContextReg_XR : XContextReg -> mword ty2 -> XContextReg\<close>\<close>

definition update_XContextReg_XR  :: \<open> XContextReg \<Rightarrow>(2)Word.word \<Rightarrow> XContextReg \<close>  where 
     \<open> update_XContextReg_XR v x = (
   ( v (|
     XContextReg_bits :=
       ((update_subrange_vec_dec(XContextReg_bits   v) (( 32 :: int)::ii) (( 31 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " XContextReg " 
  and  x  :: "(2)Word.word "


definition TLBNumEntries  :: \<open> int \<close>  where 
     \<open> TLBNumEntries = ( (( 64 :: int)::ii))\<close>


definition TLBIndexMax  :: \<open>(6)Word.word \<close>  where 
     \<open> TLBIndexMax = ( ( 0b111111 ::  6 Word.word))\<close>


\<comment> \<open>\<open>val MAX : integer -> integer\<close>\<close>

definition MAX0  :: \<open> int \<Rightarrow> int \<close>  where 
     \<open> MAX0 n = ( ((pow2 n)) - (( 1 :: int)::ii))\<close> 
  for  n  :: " int "


definition MAX_U64  :: \<open> int \<close>  where 
     \<open> MAX_U64 = ( (( 18446744073709551615 :: int)::ii))\<close>


definition MAX_VA  :: \<open> int \<close>  where 
     \<open> MAX_VA = ( (( 1099511627775 :: int)::ii))\<close>


definition MAX_PA  :: \<open> int \<close>  where 
     \<open> MAX_PA = ( (( 68719476735 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_TLBEntry : unit -> M TLBEntry\<close>\<close>

definition undefined_TLBEntry  :: \<open> unit \<Rightarrow>((register_value),(TLBEntry),(exception))monad \<close>  where 
     \<open> undefined_TLBEntry _ = (
   (undefined_bitvector (( 119 :: int)::ii)  :: ( 119 Word.word) M) \<bind> ((\<lambda> (w__0 ::  119 Word.word) . 
   return ((| TLBEntry_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_TLBEntry : mword ty119 -> TLBEntry\<close>\<close>

definition Mk_TLBEntry  :: \<open>(119)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> Mk_TLBEntry v = ( (| TLBEntry_bits = v |) )\<close> 
  for  v  :: "(119)Word.word "


definition get_TLBEntry_bits  :: \<open> TLBEntry \<Rightarrow>(119)Word.word \<close>  where 
     \<open> get_TLBEntry_bits v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 118 :: int)::ii) (( 0 :: int)::ii)  ::  119 Word.word))\<close> 
  for  v  :: " TLBEntry "


definition set_TLBEntry_bits  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(119)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 118 :: int)::ii) (( 0 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(119)Word.word "


definition update_TLBEntry_bits  :: \<open> TLBEntry \<Rightarrow>(119)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_bits v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 118 :: int)::ii) (( 0 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(119)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_asid : TLBEntry -> mword ty8\<close>\<close>

definition get_TLBEntry_asid  :: \<open> TLBEntry \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_TLBEntry_asid v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 73 :: int)::ii) (( 66 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_asid : register_ref regstate register_value TLBEntry -> mword ty8 -> M unit\<close>\<close>

definition set_TLBEntry_asid  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_asid r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 73 :: int)::ii) (( 66 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_asid : TLBEntry -> mword ty8 -> TLBEntry\<close>\<close>

definition update_TLBEntry_asid  :: \<open> TLBEntry \<Rightarrow>(8)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_asid v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 73 :: int)::ii) (( 66 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_c0 : TLBEntry -> mword ty3\<close>\<close>

definition get_TLBEntry_c0  :: \<open> TLBEntry \<Rightarrow>(3)Word.word \<close>  where 
     \<open> get_TLBEntry_c0 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_c0 : register_ref regstate register_value TLBEntry -> mword ty3 -> M unit\<close>\<close>

definition set_TLBEntry_c0  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_c0 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 4 :: int)::ii) (( 2 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(3)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_c0 : TLBEntry -> mword ty3 -> TLBEntry\<close>\<close>

definition update_TLBEntry_c0  :: \<open> TLBEntry \<Rightarrow>(3)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_c0 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 4 :: int)::ii) (( 2 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(3)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_c1 : TLBEntry -> mword ty3\<close>\<close>

definition get_TLBEntry_c1  :: \<open> TLBEntry \<Rightarrow>(3)Word.word \<close>  where 
     \<open> get_TLBEntry_c1 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 36 :: int)::ii) (( 34 :: int)::ii)  ::  3 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_c1 : register_ref regstate register_value TLBEntry -> mword ty3 -> M unit\<close>\<close>

definition set_TLBEntry_c1  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_c1 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 36 :: int)::ii) (( 34 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(3)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_c1 : TLBEntry -> mword ty3 -> TLBEntry\<close>\<close>

definition update_TLBEntry_c1  :: \<open> TLBEntry \<Rightarrow>(3)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_c1 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 36 :: int)::ii) (( 34 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(3)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_capl0 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_capl0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_capl0 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 29 :: int)::ii) (( 29 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_capl0 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_capl0  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_capl0 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 29 :: int)::ii) (( 29 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_capl0 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_capl0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_capl0 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 29 :: int)::ii) (( 29 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_capl1 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_capl1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_capl1 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 61 :: int)::ii) (( 61 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_capl1 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_capl1  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_capl1 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 61 :: int)::ii) (( 61 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_capl1 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_capl1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_capl1 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 61 :: int)::ii) (( 61 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_caplg0 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_caplg0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_caplg0 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_caplg0 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_caplg0  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_caplg0 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 31 :: int)::ii) (( 31 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_caplg0 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_caplg0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_caplg0 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 31 :: int)::ii) (( 31 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_caplg1 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_caplg1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_caplg1 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_caplg1 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_caplg1  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_caplg1 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 63 :: int)::ii) (( 63 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_caplg1 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_caplg1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_caplg1 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_caps0 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_caps0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_caps0 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 30 :: int)::ii) (( 30 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_caps0 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_caps0  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_caps0 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 30 :: int)::ii) (( 30 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_caps0 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_caps0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_caps0 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 30 :: int)::ii) (( 30 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_caps1 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_caps1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_caps1 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 62 :: int)::ii) (( 62 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_caps1 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_caps1  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_caps1 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 62 :: int)::ii) (( 62 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_caps1 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_caps1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_caps1 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 62 :: int)::ii) (( 62 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_d0 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_d0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_d0 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_d0 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_d0  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_d0 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_d0 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_d0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_d0 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_d1 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_d1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_d1 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 33 :: int)::ii) (( 33 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_d1 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_d1  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_d1 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 33 :: int)::ii) (( 33 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_d1 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_d1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_d1 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 33 :: int)::ii) (( 33 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_g : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_g  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_g v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 65 :: int)::ii) (( 65 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_g : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_g  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_g r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 65 :: int)::ii) (( 65 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_g : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_g  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_g v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 65 :: int)::ii) (( 65 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_pagemask : TLBEntry -> mword ty16\<close>\<close>

definition get_TLBEntry_pagemask  :: \<open> TLBEntry \<Rightarrow>(16)Word.word \<close>  where 
     \<open> get_TLBEntry_pagemask v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 118 :: int)::ii) (( 103 :: int)::ii)  ::  16 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_pagemask : register_ref regstate register_value TLBEntry -> mword ty16 -> M unit\<close>\<close>

definition set_TLBEntry_pagemask  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_pagemask r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits :=
         ((update_subrange_vec_dec(TLBEntry_bits   r) (( 118 :: int)::ii) (( 103 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_pagemask : TLBEntry -> mword ty16 -> TLBEntry\<close>\<close>

definition update_TLBEntry_pagemask  :: \<open> TLBEntry \<Rightarrow>(16)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_pagemask v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 118 :: int)::ii) (( 103 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(16)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_pfn0 : TLBEntry -> mword ty24\<close>\<close>

definition get_TLBEntry_pfn0  :: \<open> TLBEntry \<Rightarrow>(24)Word.word \<close>  where 
     \<open> get_TLBEntry_pfn0 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 28 :: int)::ii) (( 5 :: int)::ii)  ::  24 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_pfn0 : register_ref regstate register_value TLBEntry -> mword ty24 -> M unit\<close>\<close>

definition set_TLBEntry_pfn0  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_pfn0 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 28 :: int)::ii) (( 5 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(24)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_pfn0 : TLBEntry -> mword ty24 -> TLBEntry\<close>\<close>

definition update_TLBEntry_pfn0  :: \<open> TLBEntry \<Rightarrow>(24)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_pfn0 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 28 :: int)::ii) (( 5 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(24)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_pfn1 : TLBEntry -> mword ty24\<close>\<close>

definition get_TLBEntry_pfn1  :: \<open> TLBEntry \<Rightarrow>(24)Word.word \<close>  where 
     \<open> get_TLBEntry_pfn1 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 60 :: int)::ii) (( 37 :: int)::ii)  ::  24 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_pfn1 : register_ref regstate register_value TLBEntry -> mword ty24 -> M unit\<close>\<close>

definition set_TLBEntry_pfn1  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_pfn1 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 60 :: int)::ii) (( 37 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(24)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_pfn1 : TLBEntry -> mword ty24 -> TLBEntry\<close>\<close>

definition update_TLBEntry_pfn1  :: \<open> TLBEntry \<Rightarrow>(24)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_pfn1 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 60 :: int)::ii) (( 37 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(24)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_r : TLBEntry -> mword ty2\<close>\<close>

definition get_TLBEntry_r  :: \<open> TLBEntry \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_TLBEntry_r v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 102 :: int)::ii) (( 101 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_r : register_ref regstate register_value TLBEntry -> mword ty2 -> M unit\<close>\<close>

definition set_TLBEntry_r  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_r r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits :=
         ((update_subrange_vec_dec(TLBEntry_bits   r) (( 102 :: int)::ii) (( 101 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_r : TLBEntry -> mword ty2 -> TLBEntry\<close>\<close>

definition update_TLBEntry_r  :: \<open> TLBEntry \<Rightarrow>(2)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_r v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 102 :: int)::ii) (( 101 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_v0 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_v0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_v0 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_v0 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_v0  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_v0 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_v0 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_v0  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_v0 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_v1 : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_v1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_v1 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 32 :: int)::ii) (( 32 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_v1 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_v1  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_v1 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 32 :: int)::ii) (( 32 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_v1 : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_v1  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_v1 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 32 :: int)::ii) (( 32 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_valid : TLBEntry -> mword ty1\<close>\<close>

definition get_TLBEntry_valid  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_TLBEntry_valid v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 64 :: int)::ii) (( 64 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_valid : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit\<close>\<close>

definition set_TLBEntry_valid  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_valid r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 64 :: int)::ii) (( 64 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_valid : TLBEntry -> mword ty1 -> TLBEntry\<close>\<close>

definition update_TLBEntry_valid  :: \<open> TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_valid v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 64 :: int)::ii) (( 64 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_TLBEntry_vpn2 : TLBEntry -> mword ty27\<close>\<close>

definition get_TLBEntry_vpn2  :: \<open> TLBEntry \<Rightarrow>(27)Word.word \<close>  where 
     \<open> get_TLBEntry_vpn2 v = ( (subrange_vec_dec(TLBEntry_bits   v) (( 100 :: int)::ii) (( 74 :: int)::ii)  ::  27 Word.word))\<close> 
  for  v  :: " TLBEntry "


\<comment> \<open>\<open>val _set_TLBEntry_vpn2 : register_ref regstate register_value TLBEntry -> mword ty27 -> M unit\<close>\<close>

definition set_TLBEntry_vpn2  :: \<open>((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_TLBEntry_vpn2 r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   r) (( 100 :: int)::ii) (( 74 :: int)::ii) v  ::  119 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(TLBEntry))register_ref " 
  and  v  :: "(27)Word.word "


\<comment> \<open>\<open>val _update_TLBEntry_vpn2 : TLBEntry -> mword ty27 -> TLBEntry\<close>\<close>

definition update_TLBEntry_vpn2  :: \<open> TLBEntry \<Rightarrow>(27)Word.word \<Rightarrow> TLBEntry \<close>  where 
     \<open> update_TLBEntry_vpn2 v x = (
   ( v (|
     TLBEntry_bits := ((update_subrange_vec_dec(TLBEntry_bits   v) (( 100 :: int)::ii) (( 74 :: int)::ii) x  ::  119 Word.word)) |)))\<close> 
  for  v  :: " TLBEntry " 
  and  x  :: "(27)Word.word "


definition TLBEntries  :: \<open>(((regstate),(register_value),(TLBEntry))register_ref)list \<close>  where 
     \<open> TLBEntries = (
  [TLBEntry63_ref,TLBEntry62_ref,TLBEntry61_ref,TLBEntry60_ref,TLBEntry59_ref,TLBEntry58_ref,
   TLBEntry57_ref,TLBEntry56_ref,TLBEntry55_ref,TLBEntry54_ref,TLBEntry53_ref,TLBEntry52_ref,
   TLBEntry51_ref,TLBEntry50_ref,TLBEntry49_ref,TLBEntry48_ref,TLBEntry47_ref,TLBEntry46_ref,
   TLBEntry45_ref,TLBEntry44_ref,TLBEntry43_ref,TLBEntry42_ref,TLBEntry41_ref,TLBEntry40_ref,
   TLBEntry39_ref,TLBEntry38_ref,TLBEntry37_ref,TLBEntry36_ref,TLBEntry35_ref,TLBEntry34_ref,
   TLBEntry33_ref,TLBEntry32_ref,TLBEntry31_ref,TLBEntry30_ref,TLBEntry29_ref,TLBEntry28_ref,
   TLBEntry27_ref,TLBEntry26_ref,TLBEntry25_ref,TLBEntry24_ref,TLBEntry23_ref,TLBEntry22_ref,
   TLBEntry21_ref,TLBEntry20_ref,TLBEntry19_ref,TLBEntry18_ref,TLBEntry17_ref,TLBEntry16_ref,
   TLBEntry15_ref,TLBEntry14_ref,TLBEntry13_ref,TLBEntry12_ref,TLBEntry11_ref,TLBEntry10_ref,
   TLBEntry09_ref,TLBEntry08_ref,TLBEntry07_ref,TLBEntry06_ref,TLBEntry05_ref,TLBEntry04_ref,
   TLBEntry03_ref,TLBEntry02_ref,TLBEntry01_ref,TLBEntry00_ref])\<close>


\<comment> \<open>\<open>val get_CP0EPC : unit -> M (mword ty64)\<close>\<close>

\<comment> \<open>\<open>val set_CP0EPC : mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val get_CP0ErrorEPC : unit -> M (mword ty64)\<close>\<close>

\<comment> \<open>\<open>val set_CP0ErrorEPC : mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val undefined_StatusReg : unit -> M StatusReg\<close>\<close>

definition undefined_StatusReg  :: \<open> unit \<Rightarrow>((register_value),(StatusReg),(exception))monad \<close>  where 
     \<open> undefined_StatusReg _ = (
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   return ((| StatusReg_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_StatusReg : mword ty32 -> StatusReg\<close>\<close>

definition Mk_StatusReg  :: \<open>(32)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> Mk_StatusReg v = ( (| StatusReg_bits = v |) )\<close> 
  for  v  :: "(32)Word.word "


definition get_StatusReg_bits  :: \<open> StatusReg \<Rightarrow>(32)Word.word \<close>  where 
     \<open> get_StatusReg_bits v = ( (subrange_vec_dec(StatusReg_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))\<close> 
  for  v  :: " StatusReg "


definition set_StatusReg_bits  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 31 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(32)Word.word "


definition update_StatusReg_bits  :: \<open> StatusReg \<Rightarrow>(32)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_bits v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_BEV : StatusReg -> mword ty1\<close>\<close>

definition get_StatusReg_BEV  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_StatusReg_BEV v = ( (subrange_vec_dec(StatusReg_bits   v) (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_BEV : register_ref regstate register_value StatusReg -> mword ty1 -> M unit\<close>\<close>

definition set_StatusReg_BEV  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_BEV r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 22 :: int)::ii) (( 22 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_BEV : StatusReg -> mword ty1 -> StatusReg\<close>\<close>

definition update_StatusReg_BEV  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_BEV v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 22 :: int)::ii) (( 22 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_CU : StatusReg -> mword ty4\<close>\<close>

definition get_StatusReg_CU  :: \<open> StatusReg \<Rightarrow>(4)Word.word \<close>  where 
     \<open> get_StatusReg_CU v = ( (subrange_vec_dec(StatusReg_bits   v) (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_CU : register_ref regstate register_value StatusReg -> mword ty4 -> M unit\<close>\<close>

definition set_StatusReg_CU  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_CU r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 31 :: int)::ii) (( 28 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(4)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_CU : StatusReg -> mword ty4 -> StatusReg\<close>\<close>

definition update_StatusReg_CU  :: \<open> StatusReg \<Rightarrow>(4)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_CU v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 31 :: int)::ii) (( 28 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(4)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_ERL : StatusReg -> mword ty1\<close>\<close>

definition get_StatusReg_ERL  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_StatusReg_ERL v = ( (subrange_vec_dec(StatusReg_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_ERL : register_ref regstate register_value StatusReg -> mword ty1 -> M unit\<close>\<close>

definition set_StatusReg_ERL  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_ERL r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_ERL : StatusReg -> mword ty1 -> StatusReg\<close>\<close>

definition update_StatusReg_ERL  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_ERL v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_EXL : StatusReg -> mword ty1\<close>\<close>

definition get_StatusReg_EXL  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_StatusReg_EXL v = ( (subrange_vec_dec(StatusReg_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_EXL : register_ref regstate register_value StatusReg -> mword ty1 -> M unit\<close>\<close>

definition set_StatusReg_EXL  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_EXL r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_EXL : StatusReg -> mword ty1 -> StatusReg\<close>\<close>

definition update_StatusReg_EXL  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_EXL v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_IE : StatusReg -> mword ty1\<close>\<close>

definition get_StatusReg_IE  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_StatusReg_IE v = ( (subrange_vec_dec(StatusReg_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_IE : register_ref regstate register_value StatusReg -> mword ty1 -> M unit\<close>\<close>

definition set_StatusReg_IE  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_IE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_IE : StatusReg -> mword ty1 -> StatusReg\<close>\<close>

definition update_StatusReg_IE  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_IE v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_IM : StatusReg -> mword ty8\<close>\<close>

definition get_StatusReg_IM  :: \<open> StatusReg \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_StatusReg_IM v = ( (subrange_vec_dec(StatusReg_bits   v) (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_IM : register_ref regstate register_value StatusReg -> mword ty8 -> M unit\<close>\<close>

definition set_StatusReg_IM  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_IM r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 15 :: int)::ii) (( 8 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_IM : StatusReg -> mword ty8 -> StatusReg\<close>\<close>

definition update_StatusReg_IM  :: \<open> StatusReg \<Rightarrow>(8)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_IM v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 15 :: int)::ii) (( 8 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_KSU : StatusReg -> mword ty2\<close>\<close>

definition get_StatusReg_KSU  :: \<open> StatusReg \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_StatusReg_KSU v = ( (subrange_vec_dec(StatusReg_bits   v) (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_KSU : register_ref regstate register_value StatusReg -> mword ty2 -> M unit\<close>\<close>

definition set_StatusReg_KSU  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_KSU r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 4 :: int)::ii) (( 3 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_KSU : StatusReg -> mword ty2 -> StatusReg\<close>\<close>

definition update_StatusReg_KSU  :: \<open> StatusReg \<Rightarrow>(2)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_KSU v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 4 :: int)::ii) (( 3 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_KX : StatusReg -> mword ty1\<close>\<close>

definition get_StatusReg_KX  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_StatusReg_KX v = ( (subrange_vec_dec(StatusReg_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_KX : register_ref regstate register_value StatusReg -> mword ty1 -> M unit\<close>\<close>

definition set_StatusReg_KX  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_KX r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_KX : StatusReg -> mword ty1 -> StatusReg\<close>\<close>

definition update_StatusReg_KX  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_KX v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_SX : StatusReg -> mword ty1\<close>\<close>

definition get_StatusReg_SX  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_StatusReg_SX v = ( (subrange_vec_dec(StatusReg_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_SX : register_ref regstate register_value StatusReg -> mword ty1 -> M unit\<close>\<close>

definition set_StatusReg_SX  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_SX r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 6 :: int)::ii) (( 6 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_SX : StatusReg -> mword ty1 -> StatusReg\<close>\<close>

definition update_StatusReg_SX  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_SX v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_StatusReg_UX : StatusReg -> mword ty1\<close>\<close>

definition get_StatusReg_UX  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_StatusReg_UX v = ( (subrange_vec_dec(StatusReg_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " StatusReg "


\<comment> \<open>\<open>val _set_StatusReg_UX : register_ref regstate register_value StatusReg -> mword ty1 -> M unit\<close>\<close>

definition set_StatusReg_UX  :: \<open>((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_StatusReg_UX r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(StatusReg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_StatusReg_UX : StatusReg -> mword ty1 -> StatusReg\<close>\<close>

definition update_StatusReg_UX  :: \<open> StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg \<close>  where 
     \<open> update_StatusReg_UX v x = (
   ( v (|
     StatusReg_bits := ((update_subrange_vec_dec(StatusReg_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " StatusReg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>
THIS checks the given offset against the bounds of PCC and raises a capability length exception if it is out of bounds, otherwise a branch occurs in the normal manner for the architecture (on MIPS this implies a branch delay slot, so `NextInBranchDelay` is set to true).
\<close>\<close>
\<comment> \<open>\<open>val execute_branch : mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val execute_branch_mips : mword ty64 -> M unit\<close>\<close>

definition execute_branch_mips  :: \<open>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_branch_mips pc = (
   (write_reg DelayedPC_ref pc \<then>
   write_reg BranchPending_ref ( 0b1 ::  1 Word.word)) \<then>
   write_reg NextInBranchDelay_ref ( 0b1 ::  1 Word.word))\<close> 
  for  pc  :: "(64)Word.word "


\<comment> \<open>\<open>val NotWordVal : mword ty64 -> bool\<close>\<close>

definition NotWordVal  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> NotWordVal word1 = (
   (((replicate_bits ((cast_unit_vec0 ((access_vec_dec word1 (( 31 :: int)::ii)))  ::  1 Word.word)) (( 32 :: int)::ii)
        ::  32 Word.word)) \<noteq> ((subrange_vec_dec word1 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))\<close> 
  for  word1  :: "(64)Word.word "


\<comment> \<open>\<open>
Reads the value of the given general purpose register as a 64-bit vector. Register zero is always zero.
\<close>\<close>
\<comment> \<open>\<open>val rGPR : mword ty5 -> M (mword ty64)\<close>\<close>

definition rGPR  :: \<open>(5)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> rGPR idx = (
   (let i = (Word.uint idx) in
   if (((i = (( 0 :: int)::ii)))) then return ( 0x0000000000000000 ::  64 Word.word)
   else
     read_reg GPR_ref \<bind> ((\<lambda> (w__0 :: ( 64 Word.word) list) . 
     return ((access_list_dec w__0 i  ::  64 Word.word))))))\<close> 
  for  idx  :: "(5)Word.word "


\<comment> \<open>\<open>
THIS(rd, v) writes the 64-bit value, _v_, to the general purpose register _rd_. Writes to register zero are ignored.
\<close>\<close>
\<comment> \<open>\<open>val wGPR : mword ty5 -> mword ty64 -> M unit\<close>\<close>

definition wGPR  :: \<open>(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> wGPR idx v = (
   (let i = (Word.uint idx) in
   if (((i \<noteq> (( 0 :: int)::ii)))) then
     read_reg GPR_ref \<bind> ((\<lambda> (w__0 :: ( 64 Word.word) list) . 
     write_reg GPR_ref ((update_list_dec w__0 i v  :: ( 64 Word.word) list))))
   else return () ))\<close> 
  for  idx  :: "(5)Word.word " 
  and  v  :: "(64)Word.word "
















\<comment> \<open>\<open>val Exception_of_num : integer -> Exception\<close>\<close>

definition Exception_of_num  :: \<open> int \<Rightarrow> Exception \<close>  where 
     \<open> Exception_of_num arg1 = (
   (let l__140 = arg1 in
   if (((l__140 = (( 0 :: int)::ii)))) then Interrupt
   else if (((l__140 = (( 1 :: int)::ii)))) then TLBMod
   else if (((l__140 = (( 2 :: int)::ii)))) then TLBL
   else if (((l__140 = (( 3 :: int)::ii)))) then TLBS
   else if (((l__140 = (( 4 :: int)::ii)))) then AdEL
   else if (((l__140 = (( 5 :: int)::ii)))) then AdES
   else if (((l__140 = (( 6 :: int)::ii)))) then Sys
   else if (((l__140 = (( 7 :: int)::ii)))) then Bp
   else if (((l__140 = (( 8 :: int)::ii)))) then ResI
   else if (((l__140 = (( 9 :: int)::ii)))) then CpU
   else if (((l__140 = (( 10 :: int)::ii)))) then Ov
   else if (((l__140 = (( 11 :: int)::ii)))) then Tr
   else if (((l__140 = (( 12 :: int)::ii)))) then C2E
   else if (((l__140 = (( 13 :: int)::ii)))) then C2Trap
   else if (((l__140 = (( 14 :: int)::ii)))) then XTLBRefillL
   else if (((l__140 = (( 15 :: int)::ii)))) then XTLBRefillS
   else if (((l__140 = (( 16 :: int)::ii)))) then XTLBInvL
   else if (((l__140 = (( 17 :: int)::ii)))) then XTLBInvS
   else MCheck))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_Exception : Exception -> integer\<close>\<close>

fun num_of_Exception  :: \<open> Exception \<Rightarrow> int \<close>  where 
     \<open> num_of_Exception Interrupt = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_Exception TLBMod = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_Exception TLBL = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_Exception TLBS = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_Exception AdEL = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_Exception AdES = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_Exception Sys = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_Exception Bp = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_Exception ResI = ( (( 8 :: int)::ii))\<close>
|\<open> num_of_Exception CpU = ( (( 9 :: int)::ii))\<close>
|\<open> num_of_Exception Ov = ( (( 10 :: int)::ii))\<close>
|\<open> num_of_Exception Tr = ( (( 11 :: int)::ii))\<close>
|\<open> num_of_Exception C2E = ( (( 12 :: int)::ii))\<close>
|\<open> num_of_Exception C2Trap = ( (( 13 :: int)::ii))\<close>
|\<open> num_of_Exception XTLBRefillL = ( (( 14 :: int)::ii))\<close>
|\<open> num_of_Exception XTLBRefillS = ( (( 15 :: int)::ii))\<close>
|\<open> num_of_Exception XTLBInvL = ( (( 16 :: int)::ii))\<close>
|\<open> num_of_Exception XTLBInvS = ( (( 17 :: int)::ii))\<close>
|\<open> num_of_Exception MCheck = ( (( 18 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_Exception : unit -> M Exception\<close>\<close>

definition undefined_Exception  :: \<open> unit \<Rightarrow>((register_value),(Exception),(exception))monad \<close>  where 
     \<open> undefined_Exception _ = (
   internal_pick
     [Interrupt,TLBMod,TLBL,TLBS,AdEL,AdES,Sys,Bp,ResI,CpU,Ov,Tr,C2E,C2Trap,XTLBRefillL,XTLBRefillS,XTLBInvL,XTLBInvS,MCheck])\<close>


\<comment> \<open>\<open>val ExceptionCode : Exception -> mword ty5\<close>\<close>

definition ExceptionCode  :: \<open> Exception \<Rightarrow>(5)Word.word \<close>  where 
     \<open> ExceptionCode ex = (
   (let (x :: 8 bits) =
     ((case  ex of
       Interrupt => ( 0x00 ::  8 Word.word)
     | TLBMod => ( 0x01 ::  8 Word.word)
     | TLBL => ( 0x02 ::  8 Word.word)
     | TLBS => ( 0x03 ::  8 Word.word)
     | AdEL => ( 0x04 ::  8 Word.word)
     | AdES => ( 0x05 ::  8 Word.word)
     | Sys => ( 0x08 ::  8 Word.word)
     | Bp => ( 0x09 ::  8 Word.word)
     | ResI => ( 0x0A ::  8 Word.word)
     | CpU => ( 0x0B ::  8 Word.word)
     | Ov => ( 0x0C ::  8 Word.word)
     | Tr => ( 0x0D ::  8 Word.word)
     | C2E => ( 0x12 ::  8 Word.word)
     | C2Trap => ( 0x12 ::  8 Word.word)
     | XTLBRefillL => ( 0x02 ::  8 Word.word)
     | XTLBRefillS => ( 0x03 ::  8 Word.word)
     | XTLBInvL => ( 0x02 ::  8 Word.word)
     | XTLBInvS => ( 0x03 ::  8 Word.word)
     | MCheck => ( 0x18 ::  8 Word.word)
     )) in
   (subrange_vec_dec x (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)))\<close> 
  for  ex  :: " Exception "


\<comment> \<open>\<open>val string_of_exception : Exception -> string\<close>\<close>

fun string_of_exception  :: \<open> Exception \<Rightarrow> string \<close>  where 
     \<open> string_of_exception Interrupt = ( (''Interrupt''))\<close>
|\<open> string_of_exception TLBMod = ( (''TLBMod''))\<close>
|\<open> string_of_exception TLBL = ( (''TLBL''))\<close>
|\<open> string_of_exception TLBS = ( (''TLBS''))\<close>
|\<open> string_of_exception AdEL = ( (''AdEL''))\<close>
|\<open> string_of_exception AdES = ( (''AdES''))\<close>
|\<open> string_of_exception Sys = ( (''Sys''))\<close>
|\<open> string_of_exception Bp = ( (''Bp  ''))\<close>
|\<open> string_of_exception ResI = ( (''ResI''))\<close>
|\<open> string_of_exception CpU = ( (''CpU''))\<close>
|\<open> string_of_exception Ov = ( (''Ov''))\<close>
|\<open> string_of_exception Tr = ( (''Tr''))\<close>
|\<open> string_of_exception C2E = ( (''C2E''))\<close>
|\<open> string_of_exception C2Trap = ( (''C2Trap''))\<close>
|\<open> string_of_exception XTLBRefillL = ( (''XTLBRefillL''))\<close>
|\<open> string_of_exception XTLBRefillS = ( (''XTLBRefillS''))\<close>
|\<open> string_of_exception XTLBInvL = ( (''XTLBInvL''))\<close>
|\<open> string_of_exception XTLBInvS = ( (''XTLBInvS''))\<close>
|\<open> string_of_exception MCheck = ( (''MCheck''))\<close>


\<comment> \<open>\<open>val traceException : Exception -> unit\<close>\<close>

definition traceException  :: \<open> Exception \<Rightarrow> unit \<close>  where 
     \<open> traceException ex = ( ()  )\<close> 
  for  ex  :: " Exception "


\<comment> \<open>\<open>
Choose an exception vector offset based on current state of processor
and exception type. Some are not supported e.g. Reset.
\<close>\<close>
\<comment> \<open>\<open>val exceptionVectorOffset : Exception -> M (mword ty12)\<close>\<close>

definition exceptionVectorOffset  :: \<open> Exception \<Rightarrow>((register_value),((12)Word.word),(exception))monad \<close>  where 
     \<open> exceptionVectorOffset ex = (
   read_reg CP0Status_ref \<bind> ((\<lambda> (w__0 :: StatusReg) . 
   return (if ((bits_to_bool ((get_StatusReg_EXL w__0  ::  1 Word.word)))) then ( 0x180 ::  12 Word.word)
           else if ((((((ex = XTLBRefillL))) \<or> (((ex = XTLBRefillS)))))) then ( 0x080 ::  12 Word.word)
           else if (((ex = C2Trap))) then ( 0x280 ::  12 Word.word)
           else ( 0x180 ::  12 Word.word)))))\<close> 
  for  ex  :: " Exception "


\<comment> \<open>\<open>
Choose appropariate exception vector base for current processor state.
\<close>\<close>
\<comment> \<open>\<open>val exceptionVectorBase : unit -> M (mword ty64)\<close>\<close>

definition exceptionVectorBase  :: \<open> unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> exceptionVectorBase _ = (
   read_reg CP0Status_ref \<bind> ((\<lambda> (w__0 :: StatusReg) . 
   return (if ((bits_to_bool ((get_StatusReg_BEV w__0  ::  1 Word.word)))) then
             ( 0xFFFFFFFFBFC00200 ::  64 Word.word)
           else ( 0xFFFFFFFF80000000 ::  64 Word.word)))))\<close>


\<comment> \<open>\<open>
Update CP0BadInstr and CP0BadInstrP for exception.
\<close>\<close>
\<comment> \<open>\<open>val updateBadInstr : unit -> M unit\<close>\<close>

definition updateBadInstr  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> updateBadInstr _ = (
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bit_to_bool ((access_vec_dec w__0 (( 0 :: int)::ii))))) then
      (read_reg LastInstrBits_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      write_reg CP0BadInstrP_ref w__1))
    else return () ) \<then>
   (read_reg CurrentInstrBits_ref  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   write_reg CP0BadInstr_ref w__2)))))\<close>


\<comment> \<open>\<open>
Causes the processor to raise the given exception in the usual manner defined by the processor architecture (as modified for CHERI).
\<close>\<close>
\<comment> \<open>\<open>val SignalException : forall 'o. Exception -> M 'o\<close>\<close>

\<comment> \<open>\<open>
causes the processor to raise the given exception as per [SignalException], but with an associated bad address (on MIPS this is written to the BadVAddr register to aid with exception handling).
\<close>\<close>
\<comment> \<open>\<open>val SignalExceptionBadAddr : forall 'o. Exception -> mword ty64 -> M 'o\<close>\<close>

\<comment> \<open>\<open>val undefined_Capability : unit -> M Capability\<close>\<close>

definition undefined_Capability  :: \<open> unit \<Rightarrow>((register_value),(Capability),(exception))monad \<close>  where 
     \<open> undefined_Capability _ = (
   undefined_bool ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (w__1 ::  4 Word.word) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__2 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__4 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__6 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__7 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__8 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__9 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__10 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__11 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__12 :: bool) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__13 :: bool) . 
   (undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M) \<bind> ((\<lambda> (w__14 ::  3 Word.word) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__15 :: bool) . 
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M) \<bind> ((\<lambda> (w__16 ::  6 Word.word) . 
   undefined_bool ()  \<bind> ((\<lambda> (w__17 :: bool) . 
   (undefined_bitvector (( 14 :: int)::ii)  :: ( 14 Word.word) M) \<bind> ((\<lambda> (w__18 ::  14 Word.word) . 
   (undefined_bitvector (( 14 :: int)::ii)  :: ( 14 Word.word) M) \<bind> ((\<lambda> (w__19 ::  14 Word.word) . 
   (undefined_bitvector (( 18 :: int)::ii)  :: ( 18 Word.word) M) \<bind> ((\<lambda> (w__20 ::  18 Word.word) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
   return ((| Capability_tag = w__0, 
              Capability_uperms = w__1, 
              Capability_permit_set_CID = w__2, 
              Capability_access_system_regs = w__3, 
              Capability_permit_unseal = w__4, 
              Capability_permit_ccall = w__5, 
              Capability_permit_seal = w__6, 
              Capability_permit_store_local_cap = w__7, 
              Capability_permit_store_cap = w__8, 
              Capability_permit_load_cap = w__9, 
              Capability_permit_store = w__10, 
              Capability_permit_load = w__11, 
              Capability_permit_execute = w__12, 
              Capability_global = w__13, 
              Capability_reserved = w__14, 
              Capability_internal_e = w__15, 
              Capability_E = w__16, 
              Capability_sealed = w__17, 
              Capability_B = w__18, 
              Capability_T = w__19, 
              Capability_otype = w__20, 
              Capability_address = w__21 |)))))))))))))))))))))))))))))))))))))))))))))))\<close>


\<comment> \<open>\<open>val getCapBounds : Capability -> (integer * integer)\<close>\<close>

definition getCapBounds  :: \<open> Capability \<Rightarrow> int*int \<close>  where 
     \<open> getCapBounds c = (
   (let E = (Word.uint(Capability_E   c)) in
   (let (a :: 64 bits) = ((Capability_address   c)) in
   (let a3 =
     ((vector_truncate ((shiftr a ((E + (( 11 :: int)::ii)))  ::  64 Word.word)) (( 3 :: int)::ii)  ::  3 Word.word)) in
   (let B3 = ((vector_truncateLSB(Capability_B   c) (( 3 :: int)::ii)  ::  3 Word.word)) in
   (let T3 = ((vector_truncateLSB(Capability_T   c) (( 3 :: int)::ii)  ::  3 Word.word)) in
   (let R3 = ((sub_vec B3 ( 0b001 ::  3 Word.word)  ::  3 Word.word)) in
   (let aHi = (if ((zopz0zI_u a3 R3)) then (( 1 :: int)::ii) else (( 0 :: int)::ii)) in
   (let bHi = (if ((zopz0zI_u B3 R3)) then (( 1 :: int)::ii) else (( 0 :: int)::ii)) in
   (let tHi = (if ((zopz0zI_u T3 R3)) then (( 1 :: int)::ii) else (( 0 :: int)::ii)) in
   (let correction_base = (bHi - aHi) in
   (let correction_top = (tHi - aHi) in
   (let a_top = ((shiftr a ((E + (( 14 :: int)::ii)))  ::  64 Word.word)) in
   (let (base :: 65 bits) =
     ((place_slice (( 65 :: int)::ii)
        ((concat_vec ((add_vec_int a_top correction_base  ::  64 Word.word))(Capability_B   c)
           ::  78 Word.word)) (( 0 :: int)::ii) (( 78 :: int)::ii) E
       ::  65 Word.word)) in
   (let (top1 :: 65 bits) =
     ((place_slice (( 65 :: int)::ii)
        ((concat_vec ((add_vec_int a_top correction_top  ::  64 Word.word))(Capability_T   c)  ::  78 Word.word))
        (( 0 :: int)::ii) (( 78 :: int)::ii) E
       ::  65 Word.word)) in
   (let (top1 ::  65 Word.word) =
     (if (((((access_vec_dec base (( 64 :: int)::ii))) = B1))) then
       (update_vec_dec top1 (( 64 :: int)::ii)
          (if ((((((aHi = (( 1 :: int)::ii)))) \<and> (((tHi = (( 1 :: int)::ii))))))) then B1
           else B0)
         ::  65 Word.word)
     else top1) in
   (Word.uint ((subrange_vec_dec base (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)), Word.uint top1)))))))))))))))))\<close> 
  for  c  :: " Capability "


\<comment> \<open>\<open>val getCapBase : Capability -> integer\<close>\<close>

definition getCapBase  :: \<open> Capability \<Rightarrow> int \<close>  where 
     \<open> getCapBase c = (
   (let (base, _) = (getCapBounds c) in
   base))\<close> 
  for  c  :: " Capability "


\<comment> \<open>\<open>val capBoundsEqual : Capability -> Capability -> bool\<close>\<close>

definition capBoundsEqual  :: \<open> Capability \<Rightarrow> Capability \<Rightarrow> bool \<close>  where 
     \<open> capBoundsEqual c1 c2 = (
   (let (base1, top1) = (getCapBounds c1) in
   (let (base2, top2) = (getCapBounds c2) in
   ((((base1 = base2))) \<and> (((top1 = top2)))))))\<close> 
  for  c1  :: " Capability " 
  and  c2  :: " Capability "


\<comment> \<open>\<open>val setCapOffset : Capability -> mword ty64 -> (bool * Capability)\<close>\<close>

definition setCapOffset  :: \<open> Capability \<Rightarrow>(64)Word.word \<Rightarrow> bool*Capability \<close>  where 
     \<open> setCapOffset c offset = (
   (let (base64 :: 64 bits) = ((to_bits (( 64 :: int)::ii) ((getCapBase c))  ::  64 Word.word)) in
   (let (newAddress :: 64 bits) = ((add_vec base64 offset  ::  64 Word.word)) in
   (let newCap = (( c (| Capability_address := newAddress |))) in
   (let representable = (capBoundsEqual c newCap) in
   (representable, newCap))))))\<close> 
  for  c  :: " Capability " 
  and  offset  :: "(64)Word.word "


\<comment> \<open>\<open>
THIS sets PCC to the given capability before executing the next instruction. It is used for CCall, which has no branch delay.
\<close>\<close>
\<comment> \<open>\<open>val set_next_pcc : Capability -> M unit\<close>\<close>

definition set_next_pcc  :: \<open> Capability \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_next_pcc newPCC = ( write_reg NextPCC_ref newPCC \<then> write_reg DelayedPCC_ref newPCC )\<close> 
  for  newPCC  :: " Capability "


\<comment> \<open>\<open>
THIS`(cap)` returns `cap` with the tag unset. It is used when the
result of a capability operation (e.g. setting the address) has
caused it to become unrepresentable. The result of subsequent
operations such as [getCapBase] will depend on the exact capability
format in use but in general the address, length, object type and
permissions will remain the same, with the expected operation having
been applied to the address.
\<close>\<close>
\<comment> \<open>\<open>val unrepCap : Capability -> Capability\<close>\<close>

definition unrepCap  :: \<open> Capability \<Rightarrow> Capability \<close>  where 
     \<open> unrepCap cap = ( ( cap (| Capability_tag := False |)))\<close> 
  for  cap  :: " Capability "


definition SignalException  :: \<open> Exception \<Rightarrow>((register_value),'o,(exception))monad \<close>  where 
     \<open> SignalException ex = (
   (let (_ :: unit) = (traceException ex) in
   read_reg CP0Status_ref \<bind> ((\<lambda> (w__0 :: StatusReg) . 
   (((if ((\<not> ((bits_to_bool ((get_StatusReg_EXL w__0  ::  1 Word.word)))))) then
      (read_reg InBranchDelay_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__1 ::  1 Word.word) . 
      (if ((bit_to_bool ((access_vec_dec w__1 (( 0 :: int)::ii))))) then
         (set_CauseReg_BD CP0Cause_ref ( 0b1 ::  1 Word.word) \<then>
         (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
         return ((sub_vec_int w__2 (( 4 :: int)::ii)  ::  64 Word.word))))
       else set_CauseReg_BD CP0Cause_ref ( 0b0 ::  1 Word.word) \<then> (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (epc :: 64
        bits) . 
      read_reg PCC_ref \<bind> ((\<lambda> (w__4 :: Capability) . 
      (let (representable, newEPCC) = (setCapOffset w__4 epc) in
      (let (_ :: unit) = (if ((\<not> representable)) then print_endline (''UNREPRESENTABLE EPCC!'') else () ) in
      (let (_ :: unit) = (if(Capability_sealed   newEPCC) then print_endline (''SEALED PCC!'') else () ) in
      write_reg
        EPCC_ref
        (if (((representable \<and> ((\<not>(Capability_sealed   newEPCC)))))) then newEPCC
         else unrepCap newEPCC))))))))))
    else return () ) \<then>
   updateBadInstr () ) \<then>
   (exceptionVectorOffset ex  :: ( 12 Word.word) M)) \<bind> ((\<lambda> vectorOffset . 
   (exceptionVectorBase ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> vectorBase . 
   read_reg KCC_ref \<bind> ((\<lambda> (w__5 :: Capability) . 
   (let kccBase = (getCapBase w__5) in
   (write_reg
     NextPC_ref
     ((sub_vec
         ((add_vec vectorBase ((mips_zero_extend (( 64 :: int)::ii) vectorOffset  ::  64 Word.word))  ::  64 Word.word))
         ((to_bits (( 64 :: int)::ii) kccBase  ::  64 Word.word))
        ::  64 Word.word)) \<then>
   read_reg KCC_ref) \<bind> ((\<lambda> (w__6 :: Capability) . 
   ((set_next_pcc w__6 \<then>
   set_CauseReg_ExcCode CP0Cause_ref ((ExceptionCode ex  ::  5 Word.word))) \<then>
   set_StatusReg_EXL CP0Status_ref ( 0b1 ::  1 Word.word)) \<then> throw (ISAException () ))))))))))))))\<close> 
  for  ex  :: " Exception "


definition SignalExceptionBadAddr  :: \<open> Exception \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),'o,(exception))monad \<close>  where 
     \<open> SignalExceptionBadAddr ex badAddr = ( write_reg CP0BadVAddr_ref badAddr \<then> SignalException ex )\<close> 
  for  ex  :: " Exception " 
  and  badAddr  :: "(64)Word.word "


\<comment> \<open>\<open>val SignalExceptionTLB : forall 'o. Exception -> mword ty64 -> M 'o\<close>\<close>

definition SignalExceptionTLB  :: \<open> Exception \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),'o,(exception))monad \<close>  where 
     \<open> SignalExceptionTLB ex badAddr = (
   (((((write_reg CP0BadVAddr_ref badAddr \<then>
   set_ContextReg_BadVPN2 TLBContext_ref ((subrange_vec_dec badAddr (( 31 :: int)::ii) (( 13 :: int)::ii)  ::  19 Word.word))) \<then>
   set_XContextReg_XBadVPN2 TLBXContext_ref
     ((subrange_vec_dec badAddr (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word))) \<then>
   set_XContextReg_XR TLBXContext_ref ((subrange_vec_dec badAddr (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word))) \<then>
   set_TLBEntryHiReg_R TLBEntryHi_ref ((subrange_vec_dec badAddr (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word))) \<then>
   set_TLBEntryHiReg_VPN2 TLBEntryHi_ref ((subrange_vec_dec badAddr (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word))) \<then>
   SignalException ex )\<close> 
  for  ex  :: " Exception " 
  and  badAddr  :: "(64)Word.word "


\<comment> \<open>\<open>val MemAccessType_of_num : integer -> MemAccessType\<close>\<close>

definition MemAccessType_of_num  :: \<open> int \<Rightarrow> MemAccessType \<close>  where 
     \<open> MemAccessType_of_num arg1 = (
   (let l__138 = arg1 in
   if (((l__138 = (( 0 :: int)::ii)))) then Instruction
   else if (((l__138 = (( 1 :: int)::ii)))) then LoadData
   else StoreData))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_MemAccessType : MemAccessType -> integer\<close>\<close>

fun num_of_MemAccessType  :: \<open> MemAccessType \<Rightarrow> int \<close>  where 
     \<open> num_of_MemAccessType Instruction = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_MemAccessType LoadData = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_MemAccessType StoreData = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_MemAccessType : unit -> M MemAccessType\<close>\<close>

definition undefined_MemAccessType  :: \<open> unit \<Rightarrow>((register_value),(MemAccessType),(exception))monad \<close>  where 
     \<open> undefined_MemAccessType _ = ( internal_pick [Instruction,LoadData,StoreData])\<close>


\<comment> \<open>\<open>val MemAccessCapRestriction_of_num : integer -> MemAccessCapRestriction\<close>\<close>

definition MemAccessCapRestriction_of_num  :: \<open> int \<Rightarrow> MemAccessCapRestriction \<close>  where 
     \<open> MemAccessCapRestriction_of_num arg1 = (
   (let l__136 = arg1 in
   if (((l__136 = (( 0 :: int)::ii)))) then Unrestricted
   else if (((l__136 = (( 1 :: int)::ii)))) then Trap
   else Clear))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_MemAccessCapRestriction : MemAccessCapRestriction -> integer\<close>\<close>

fun num_of_MemAccessCapRestriction  :: \<open> MemAccessCapRestriction \<Rightarrow> int \<close>  where 
     \<open> num_of_MemAccessCapRestriction Unrestricted = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_MemAccessCapRestriction Trap = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_MemAccessCapRestriction Clear = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_MemAccessCapRestriction : unit -> M MemAccessCapRestriction\<close>\<close>

definition undefined_MemAccessCapRestriction  :: \<open> unit \<Rightarrow>((register_value),(MemAccessCapRestriction),(exception))monad \<close>  where 
     \<open> undefined_MemAccessCapRestriction _ = ( internal_pick [Unrestricted,Trap,Clear])\<close>


\<comment> \<open>\<open>val AccessLevel_of_num : integer -> AccessLevel\<close>\<close>

definition AccessLevel_of_num  :: \<open> int \<Rightarrow> AccessLevel \<close>  where 
     \<open> AccessLevel_of_num arg1 = (
   (let l__134 = arg1 in
   if (((l__134 = (( 0 :: int)::ii)))) then User
   else if (((l__134 = (( 1 :: int)::ii)))) then Supervisor
   else Kernel))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_AccessLevel : AccessLevel -> integer\<close>\<close>

fun num_of_AccessLevel  :: \<open> AccessLevel \<Rightarrow> int \<close>  where 
     \<open> num_of_AccessLevel User = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_AccessLevel Supervisor = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_AccessLevel Kernel = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_AccessLevel : unit -> M AccessLevel\<close>\<close>

definition undefined_AccessLevel  :: \<open> unit \<Rightarrow>((register_value),(AccessLevel),(exception))monad \<close>  where 
     \<open> undefined_AccessLevel _ = ( internal_pick [User,Supervisor,Kernel])\<close>


\<comment> \<open>\<open>val int_of_AccessLevel : AccessLevel -> integer\<close>\<close>

fun int_of_AccessLevel  :: \<open> AccessLevel \<Rightarrow> int \<close>  where 
     \<open> int_of_AccessLevel User = ( (( 0 :: int)::ii))\<close>
|\<open> int_of_AccessLevel Supervisor = ( (( 1 :: int)::ii))\<close>
|\<open> int_of_AccessLevel Kernel = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>
Returns whether the first AccessLevel is sufficient to grant access at the second, required, access level.
\<close>\<close>
\<comment> \<open>\<open>val grantsAccess : AccessLevel -> AccessLevel -> bool\<close>\<close>

definition grantsAccess  :: \<open> AccessLevel \<Rightarrow> AccessLevel \<Rightarrow> bool \<close>  where 
     \<open> grantsAccess currentLevel requiredLevel = (
   ((int_of_AccessLevel currentLevel)) \<ge> ((int_of_AccessLevel requiredLevel)))\<close> 
  for  currentLevel  :: " AccessLevel " 
  and  requiredLevel  :: " AccessLevel "


\<comment> \<open>\<open>
Returns the current effective access level (User, Supervisor or Kernel) determined by accessing the relevant parts of the MIPS status register.
\<close>\<close>
\<comment> \<open>\<open>val getAccessLevel : unit -> M AccessLevel\<close>\<close>

definition getAccessLevel  :: \<open> unit \<Rightarrow>((register_value),(AccessLevel),(exception))monad \<close>  where 
     \<open> getAccessLevel _ = (
   or_boolM
     (read_reg CP0Status_ref \<bind> ((\<lambda> (w__0 :: StatusReg) . 
      return ((bits_to_bool ((get_StatusReg_EXL w__0  ::  1 Word.word)))))))
     (read_reg CP0Status_ref \<bind> ((\<lambda> (w__1 :: StatusReg) . 
      return ((bits_to_bool ((get_StatusReg_ERL w__1  ::  1 Word.word))))))) \<bind> ((\<lambda> (w__2 :: bool) . 
   if w__2 then return Kernel
   else
     read_reg CP0Status_ref \<bind> ((\<lambda> (w__3 :: StatusReg) . 
     (let p__158 = ((get_StatusReg_KSU w__3  ::  2 Word.word)) in
     (let b__0 = p__158 in
     return (if (((b__0 = ( 0b00 ::  2 Word.word)))) then Kernel
             else if (((b__0 = ( 0b01 ::  2 Word.word)))) then Supervisor
             else if (((b__0 = ( 0b10 ::  2 Word.word)))) then User
             else User))))))))\<close>


\<comment> \<open>\<open>val checkCP0AccessHook : unit -> M unit\<close>\<close>

\<comment> \<open>\<open>val checkCP0Access : unit -> M unit\<close>\<close>

\<comment> \<open>\<open>val pcc_access_system_regs : unit -> M bool\<close>\<close>

definition pcc_access_system_regs  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> pcc_access_system_regs _ = (
   read_reg PCC_ref \<bind> ((\<lambda> (w__0 :: Capability) .  return(Capability_access_system_regs   w__0))))\<close>


\<comment> \<open>\<open>val undefined_CapCauseReg : unit -> M CapCauseReg\<close>\<close>

definition undefined_CapCauseReg  :: \<open> unit \<Rightarrow>((register_value),(CapCauseReg),(exception))monad \<close>  where 
     \<open> undefined_CapCauseReg _ = (
   (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__0 ::  16 Word.word) . 
   return ((| CapCauseReg_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val CapExCode : CapEx -> mword ty8\<close>\<close>

fun CapExCode  :: \<open> CapEx \<Rightarrow>(8)Word.word \<close>  where 
     \<open> CapExCode CapEx_None = ( ( 0x00 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_LengthViolation = ( ( 0x01 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_TagViolation = ( ( 0x02 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_SealViolation = ( ( 0x03 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_TypeViolation = ( ( 0x04 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_CallTrap = ( ( 0x05 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_ReturnTrap = ( ( 0x06 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_TSSUnderFlow = ( ( 0x07 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_UserDefViolation = ( ( 0x08 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_TLBNoStoreCap = ( ( 0x09 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_InexactBounds = ( ( 0x0A ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_TLBLoadCap = ( ( 0x0C ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_GlobalViolation = ( ( 0x10 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitExecuteViolation = ( ( 0x11 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitLoadViolation = ( ( 0x12 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitStoreViolation = ( ( 0x13 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitLoadCapViolation = ( ( 0x14 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitStoreCapViolation = ( ( 0x15 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitStoreLocalCapViolation = ( ( 0x16 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitSealViolation = ( ( 0x17 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_AccessSystemRegsViolation = ( ( 0x18 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitCCallViolation = ( ( 0x19 ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_AccessCCallIDCViolation = ( ( 0x1A ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitUnsealViolation = ( ( 0x1B ::  8 Word.word))\<close>
|\<open> CapExCode CapEx_PermitSetCIDViolation = ( ( 0x1C ::  8 Word.word))\<close>


definition set_CapCauseReg_ExcCode  :: \<open>((regstate),(register_value),(CapCauseReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CapCauseReg_ExcCode r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CapCauseReg_bits :=
         ((update_subrange_vec_dec(CapCauseReg_bits   r) (( 15 :: int)::ii) (( 8 :: int)::ii) v  ::  16 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CapCauseReg))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _set_CapCauseReg_RegNum : register_ref regstate register_value CapCauseReg -> mword ty8 -> M unit\<close>\<close>

definition set_CapCauseReg_RegNum  :: \<open>((regstate),(register_value),(CapCauseReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CapCauseReg_RegNum r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CapCauseReg_bits :=
         ((update_subrange_vec_dec(CapCauseReg_bits   r) (( 7 :: int)::ii) (( 0 :: int)::ii) v  ::  16 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CapCauseReg))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val raise_c2_exception8 : forall 'o. CapEx -> mword ty8 -> M 'o\<close>\<close>

definition raise_c2_exception8  :: \<open> CapEx \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),'o,(exception))monad \<close>  where 
     \<open> raise_c2_exception8 capEx regnum = (
   (set_CapCauseReg_ExcCode CapCause_ref ((CapExCode capEx  ::  8 Word.word)) \<then>
   set_CapCauseReg_RegNum CapCause_ref regnum) \<then>
   ((let mipsEx =
     (if ((((((capEx = CapEx_CallTrap))) \<or> (((capEx = CapEx_ReturnTrap)))))) then C2Trap
     else C2E) in
   SignalException mipsEx)))\<close> 
  for  capEx  :: " CapEx " 
  and  regnum  :: "(8)Word.word "


\<comment> \<open>\<open>
is as [raise_c2_exception] except that CapCause.RegNum  is written with the special value 0xff indicating PCC or no register.
\<close>\<close>
\<comment> \<open>\<open>val raise_c2_exception_noreg : forall 'o. CapEx -> M 'o\<close>\<close>

definition raise_c2_exception_noreg  :: \<open> CapEx \<Rightarrow>((register_value),'o,(exception))monad \<close>  where 
     \<open> raise_c2_exception_noreg capEx = ( raise_c2_exception8 capEx ( 0xFF ::  8 Word.word))\<close> 
  for  capEx  :: " CapEx "


definition checkCP0AccessHook  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> checkCP0AccessHook _ = (
   pcc_access_system_regs ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if ((\<not> w__0)) then raise_c2_exception_noreg CapEx_AccessSystemRegsViolation
   else return () )))\<close>


definition checkCP0Access  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> checkCP0Access _ = (
   getAccessLevel ()  \<bind> ((\<lambda> accessLevel . 
   and_boolM (return (((accessLevel \<noteq> Kernel))))
     (read_reg CP0Status_ref \<bind> ((\<lambda> (w__0 :: StatusReg) . 
      return ((\<not> ((bit_to_bool ((access_vec_dec ((get_StatusReg_CU w__0  ::  4 Word.word)) (( 0 :: int)::ii)))))))))) \<bind> ((\<lambda> (w__1 ::
     bool) . 
   (if w__1 then set_CauseReg_CE CP0Cause_ref ( 0b00 ::  2 Word.word) \<then> SignalException CpU
    else return () ) \<then>
   checkCP0AccessHook () )))))\<close>


\<comment> \<open>\<open>val incrementCP0Count : unit -> M unit\<close>\<close>

definition incrementCP0Count  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> incrementCP0Count _ = (
   (read_reg TLBRandom_ref  :: ( 6 Word.word) M) \<bind> ((\<lambda> (w__0 ::  6 Word.word) . 
   (read_reg TLBWired_ref  :: ( 6 Word.word) M) \<bind> ((\<lambda> (w__1 ::  6 Word.word) . 
   (if (((w__0 = w__1))) then return TLBIndexMax
    else
      (read_reg TLBRandom_ref  :: ( 6 Word.word) M) \<bind> ((\<lambda> (w__2 ::  6 Word.word) . 
      return ((sub_vec_int w__2 (( 1 :: int)::ii)  ::  6 Word.word))))) \<bind> ((\<lambda> (w__3 ::  6 Word.word) . 
   (write_reg TLBRandom_ref w__3 \<then>
   (read_reg CP0Count_ref  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (write_reg CP0Count_ref ((add_vec_int w__4 (( 1 :: int)::ii)  ::  32 Word.word)) \<then>
   (read_reg CP0Count_ref  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (read_reg CP0Compare_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   ((if (((w__5 = w__6))) then
      read_reg CP0Cause_ref \<bind> ((\<lambda> (w__7 :: CauseReg) . 
      set_CauseReg_IP CP0Cause_ref
        ((or_vec ((get_CauseReg_IP w__7  ::  8 Word.word)) ( 0x80 ::  8 Word.word)  ::  8 Word.word))))
    else return () ) \<then>
   read_reg CP0Status_ref) \<bind> ((\<lambda> (w__8 :: StatusReg) . 
   (let ims = ((get_StatusReg_IM w__8  ::  8 Word.word)) in
   read_reg CP0Cause_ref \<bind> ((\<lambda> (w__9 :: CauseReg) . 
   (let ips = ((get_CauseReg_IP w__9  ::  8 Word.word)) in
   read_reg CP0Status_ref \<bind> ((\<lambda> (w__10 :: StatusReg) . 
   (let ie = ((get_StatusReg_IE w__10  ::  1 Word.word)) in
   read_reg CP0Status_ref \<bind> ((\<lambda> (w__11 :: StatusReg) . 
   (let exl = ((get_StatusReg_EXL w__11  ::  1 Word.word)) in
   read_reg CP0Status_ref \<bind> ((\<lambda> (w__12 :: StatusReg) . 
   (let erl = ((get_StatusReg_ERL w__12  ::  1 Word.word)) in
   if (((((\<not> ((bits_to_bool exl)))) \<and> (((((\<not> ((bits_to_bool erl)))) \<and> (((((bits_to_bool ie)) \<and> (((((and_vec ips ims  ::  8 Word.word)) \<noteq> ( 0x00 ::  8 Word.word))))))))))))) then
     SignalException Interrupt
   else return () ))))))))))))))))))))))))))))\<close>


\<comment> \<open>\<open>val strReg : mword ty5 -> string\<close>\<close>

definition strReg  :: \<open>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strReg r = ( concat_str_dec (''$'') ((Word.uint r)))\<close> 
  for  r  :: "(5)Word.word "


\<comment> \<open>\<open>val strRRRArgs : mword ty5 -> mword ty5 -> mword ty5 -> string\<close>\<close>

definition strRRRArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strRRRArgs (r2 :: regno) (r1 :: regno) (rd :: regno) = (
   (@) ((strReg rd))
     (((@) ('', '') (((@) ((strReg r1)) (((@) ('', '') ((strReg r2)))))))))\<close> 
  for  r2  :: "(5)Word.word " 
  and  r1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val strRRIArgs : forall 'n. Size 'n => mword ty5 -> mword ty5 -> mword 'n -> string\<close>\<close>

definition strRRIArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> strRRIArgs rs rd imm = (
   (@) ((strReg rd))
     (((@) ('', '')
         (((@) ((strReg rs)) (((@) ('', '') ((dec_str ((Word.sint imm)))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  imm  :: "('n::len)Word.word "


\<comment> \<open>\<open>val strRRIUArgs : forall 'n. Size 'n => mword ty5 -> mword ty5 -> mword 'n -> string\<close>\<close>

definition strRRIUArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> strRRIUArgs rs rd imm = (
   (@) ((strReg rd))
     (((@) ('', '')
         (((@) ((strReg rs)) (((@) ('', '') ((hex_str ((Word.uint imm)))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  imm  :: "('n::len)Word.word "


\<comment> \<open>\<open>val strRIArgs : forall 'n. Size 'n => mword ty5 -> mword 'n -> string\<close>\<close>

definition strRIArgs  :: \<open>(5)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> strRIArgs rd imm = ( (@) ((strReg rd)) (((@) ('', '') ((hex_str ((Word.uint imm)))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  imm  :: "('n::len)Word.word "


\<comment> \<open>\<open>val strMemArgs : forall 'n. Size 'n => mword ty5 -> mword ty5 -> mword 'n -> string\<close>\<close>

definition strMemArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> strMemArgs base rt offset = (
   (@) ((strReg rt))
     (((@) ('', '')
         (((@) ((dec_str ((Word.sint offset))))
             (((@) (''('') (((@) ((strReg base)) ('')''))))))))))\<close> 
  for  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "('n::len)Word.word "


\<comment> \<open>\<open>val decode_failure_of_num : integer -> decode_failure\<close>\<close>

definition decode_failure_of_num  :: \<open> int \<Rightarrow> decode_failure \<close>  where 
     \<open> decode_failure_of_num arg1 = (
   (let l__131 = arg1 in
   if (((l__131 = (( 0 :: int)::ii)))) then No_matching_pattern
   else if (((l__131 = (( 1 :: int)::ii)))) then Unsupported_instruction
   else if (((l__131 = (( 2 :: int)::ii)))) then Illegal_instruction
   else Internal_error))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_decode_failure : decode_failure -> integer\<close>\<close>

definition num_of_decode_failure  :: \<open> decode_failure \<Rightarrow> int \<close>  where 
     \<open> num_of_decode_failure no_matching_pattern = ( (( 0 :: int)::ii))\<close> 
  for  no_matching_pattern  :: " decode_failure "


\<comment> \<open>\<open>val undefined_decode_failure : unit -> M decode_failure\<close>\<close>

definition undefined_decode_failure  :: \<open> unit \<Rightarrow>((register_value),(decode_failure),(exception))monad \<close>  where 
     \<open> undefined_decode_failure _ = (
   internal_pick [No_matching_pattern,Unsupported_instruction,Illegal_instruction,Internal_error])\<close>


\<comment> \<open>\<open>val Comparison_of_num : integer -> Comparison\<close>\<close>

definition Comparison_of_num  :: \<open> int \<Rightarrow> Comparison \<close>  where 
     \<open> Comparison_of_num arg1 = (
   (let l__124 = arg1 in
   if (((l__124 = (( 0 :: int)::ii)))) then EQ'
   else if (((l__124 = (( 1 :: int)::ii)))) then NE
   else if (((l__124 = (( 2 :: int)::ii)))) then GE
   else if (((l__124 = (( 3 :: int)::ii)))) then GEU
   else if (((l__124 = (( 4 :: int)::ii)))) then GT'
   else if (((l__124 = (( 5 :: int)::ii)))) then LE
   else if (((l__124 = (( 6 :: int)::ii)))) then LT'
   else LTU))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_Comparison : Comparison -> integer\<close>\<close>

fun num_of_Comparison  :: \<open> Comparison \<Rightarrow> int \<close>  where 
     \<open> num_of_Comparison EQ' = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_Comparison NE = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_Comparison GE = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_Comparison GEU = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_Comparison GT' = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_Comparison LE = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_Comparison LT' = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_Comparison LTU = ( (( 7 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_Comparison : unit -> M Comparison\<close>\<close>

definition undefined_Comparison  :: \<open> unit \<Rightarrow>((register_value),(Comparison),(exception))monad \<close>  where 
     \<open> undefined_Comparison _ = ( internal_pick [EQ',NE,GE,GEU,GT',LE,LT',LTU])\<close>


\<comment> \<open>\<open>val strCmp : Comparison -> string\<close>\<close>

fun strCmp  :: \<open> Comparison \<Rightarrow> string \<close>  where 
     \<open> strCmp EQ' = ( (''eq''))\<close>
|\<open> strCmp NE = ( (''ne''))\<close>
|\<open> strCmp GE = ( (''ge''))\<close>
|\<open> strCmp GEU = ( (''geu''))\<close>
|\<open> strCmp GT' = ( (''gt''))\<close>
|\<open> strCmp LE = ( (''le''))\<close>
|\<open> strCmp LT' = ( (''lt''))\<close>
|\<open> strCmp LTU = ( (''ltu''))\<close>


\<comment> \<open>\<open>val compare : Comparison -> mword ty64 -> mword ty64 -> bool\<close>\<close>

fun compare  :: \<open> Comparison \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> compare EQ' valA valB = ( (valA = valB))\<close> 
  for  valA  :: "(64)Word.word " 
  and  valB  :: "(64)Word.word "
|\<open> compare NE valA valB = ( (valA \<noteq> valB))\<close> 
  for  valA  :: "(64)Word.word " 
  and  valB  :: "(64)Word.word "
|\<open> compare GE valA valB = ( zopz0zKzJ_s valA valB )\<close> 
  for  valA  :: "(64)Word.word " 
  and  valB  :: "(64)Word.word "
|\<open> compare GEU valA valB = ( zopz0zKzJ_u valA valB )\<close> 
  for  valA  :: "(64)Word.word " 
  and  valB  :: "(64)Word.word "
|\<open> compare GT' valA valB = ( zopz0zI_s valB valA )\<close> 
  for  valA  :: "(64)Word.word " 
  and  valB  :: "(64)Word.word "
|\<open> compare LE valA valB = ( zopz0zKzJ_s valB valA )\<close> 
  for  valA  :: "(64)Word.word " 
  and  valB  :: "(64)Word.word "
|\<open> compare LT' valA valB = ( zopz0zI_s valA valB )\<close> 
  for  valA  :: "(64)Word.word " 
  and  valB  :: "(64)Word.word "
|\<open> compare LTU valA valB = ( zopz0zI_u valA valB )\<close> 
  for  valA  :: "(64)Word.word " 
  and  valB  :: "(64)Word.word "


\<comment> \<open>\<open>val WordType_of_num : integer -> WordType\<close>\<close>

definition WordType_of_num  :: \<open> int \<Rightarrow> WordType \<close>  where 
     \<open> WordType_of_num arg1 = (
   (let l__121 = arg1 in
   if (((l__121 = (( 0 :: int)::ii)))) then B
   else if (((l__121 = (( 1 :: int)::ii)))) then H
   else if (((l__121 = (( 2 :: int)::ii)))) then W
   else D))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_WordType : WordType -> integer\<close>\<close>

fun num_of_WordType  :: \<open> WordType \<Rightarrow> int \<close>  where 
     \<open> num_of_WordType B = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_WordType H = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_WordType W = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_WordType D = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_WordType : unit -> M WordType\<close>\<close>

definition undefined_WordType  :: \<open> unit \<Rightarrow>((register_value),(WordType),(exception))monad \<close>  where 
     \<open> undefined_WordType _ = ( internal_pick [B,H,W,D])\<close>


\<comment> \<open>\<open>val WordTypeUnaligned_of_num : integer -> WordTypeUnaligned\<close>\<close>

definition WordTypeUnaligned_of_num  :: \<open> int \<Rightarrow> WordTypeUnaligned \<close>  where 
     \<open> WordTypeUnaligned_of_num arg1 = (
   (let l__118 = arg1 in
   if (((l__118 = (( 0 :: int)::ii)))) then WL
   else if (((l__118 = (( 1 :: int)::ii)))) then WR
   else if (((l__118 = (( 2 :: int)::ii)))) then DL
   else DR))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_WordTypeUnaligned : WordTypeUnaligned -> integer\<close>\<close>

fun num_of_WordTypeUnaligned  :: \<open> WordTypeUnaligned \<Rightarrow> int \<close>  where 
     \<open> num_of_WordTypeUnaligned WL = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_WordTypeUnaligned WR = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_WordTypeUnaligned DL = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_WordTypeUnaligned DR = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_WordTypeUnaligned : unit -> M WordTypeUnaligned\<close>\<close>

definition undefined_WordTypeUnaligned  :: \<open> unit \<Rightarrow>((register_value),(WordTypeUnaligned),(exception))monad \<close>  where 
     \<open> undefined_WordTypeUnaligned _ = ( internal_pick [WL,WR,DL,DR])\<close>


\<comment> \<open>\<open>val strWordType : WordType -> string\<close>\<close>

fun strWordType  :: \<open> WordType \<Rightarrow> string \<close>  where 
     \<open> strWordType B = ( (''b''))\<close>
|\<open> strWordType H = ( (''h''))\<close>
|\<open> strWordType W = ( (''w''))\<close>
|\<open> strWordType D = ( (''d''))\<close>


\<comment> \<open>\<open>val unalignedBytesTouched : ii -> WordTypeUnaligned -> (ii * ii)\<close>\<close>

definition unalignedBytesTouched  :: \<open> int \<Rightarrow> WordTypeUnaligned \<Rightarrow> int*int \<close>  where 
     \<open> unalignedBytesTouched (vAddr :: ii) (width :: WordTypeUnaligned) = (
   (let woffset = (vAddr mod (( 4 :: int)::ii)) in
   (let doffset = (vAddr mod (( 8 :: int)::ii)) in
   (case  width of
     WL => (vAddr, (( 4 :: int)::ii) - woffset)
   | WR => (vAddr - woffset, woffset + (( 1 :: int)::ii))
   | DL => (vAddr, (( 8 :: int)::ii) - doffset)
   | DR => (vAddr - doffset, doffset + (( 1 :: int)::ii))
   ))))\<close> 
  for  vAddr  :: " int " 
  and  width  :: " WordTypeUnaligned "


\<comment> \<open>\<open>
 Returns the width of the given WordType (byte, half, word, double) in bytes.
\<close>\<close>
\<comment> \<open>\<open>val wordWidthBytes : WordType -> integer\<close>\<close>

fun wordWidthBytes  :: \<open> WordType \<Rightarrow> int \<close>  where 
     \<open> wordWidthBytes B = ( (( 1 :: int)::ii))\<close>
|\<open> wordWidthBytes H = ( (( 2 :: int)::ii))\<close>
|\<open> wordWidthBytes W = ( (( 4 :: int)::ii))\<close>
|\<open> wordWidthBytes D = ( (( 8 :: int)::ii))\<close>


definition alignment_width  :: \<open> int \<close>  where 
     \<open> alignment_width = ( (( 16 :: int)::ii))\<close>


\<comment> \<open>\<open>
  THIS`(address, wordtype)` returns whether `address` is naturally aligned for the given `wordtype`.
\<close>\<close>
\<comment> \<open>\<open>val isAddressAligned : mword ty64 -> WordType -> bool\<close>\<close>

definition isAddressAligned  :: \<open>(64)Word.word \<Rightarrow> WordType \<Rightarrow> bool \<close>  where 
     \<open> isAddressAligned addr wordType = (
   (let a = (Word.uint addr) in
   (((a div alignment_width)) = ((((((a + ((wordWidthBytes wordType)))) - (( 1 :: int)::ii))) div
         alignment_width)))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  wordType  :: " WordType "


\<comment> \<open>\<open>
  THIS`(val, signed)` extends `val` to 64-bits in either sign extended or zero extended fashion according to `signed`.
\<close>\<close>
\<comment> \<open>\<open>val extendLoad : forall 'sz. Size 'sz => mword 'sz -> bool -> mword ty64\<close>\<close>

definition extendLoad  :: \<open>('sz::len)Word.word \<Rightarrow> bool \<Rightarrow>(64)Word.word \<close>  where 
     \<open> extendLoad memResult sign = (
   if sign then (mips_sign_extend (( 64 :: int)::ii) memResult  ::  64 Word.word)
   else (mips_zero_extend (( 64 :: int)::ii) memResult  ::  64 Word.word))\<close> 
  for  memResult  :: "('sz::len)Word.word " 
  and  sign  :: " bool "


\<comment> \<open>\<open>
THIS`(addr, size)` reads a vector of `size` bytes of memory from physical address `addr` (big-endian byte order on CHERI-MIPS).
\<close>\<close>
\<comment> \<open>\<open>val MEMr_wrapper : forall 'p8_times_n. Size 'p8_times_n => mword ty64 -> integer -> M (mword 'p8_times_n)\<close>\<close>

definition MEMr_wrapper  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('p8_times_n::len)Word.word),(exception))monad \<close>  where 
     \<open> MEMr_wrapper addr size1 = (
   if (((addr = ( 0x000000007F000000 ::  64 Word.word)))) then
     (read_reg UART_RVALID_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> rvalid . 
     (write_reg UART_RVALID_ref ( 0b0 ::  1 Word.word) \<then>
     (read_reg UART_RDATA_ref  :: ( 8 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  8 Word.word) . 
     return ((mask0 (((( 8 :: int)::ii) * ((id0 size1))))
                ((concat_vec ( 0x00000000 ::  32 Word.word)
                    ((concat_vec w__0
                        ((concat_vec rvalid
                            ((concat_vec ( 0b0000000 ::  7 Word.word) ( 0x0000 ::  16 Word.word)  ::  23 Word.word))
                           ::  24 Word.word))
                       ::  32 Word.word))
                   ::  64 Word.word))
               :: ( 'p8_times_n::len)Word.word))))))
   else if (((addr = ( 0x000000007F000004 ::  64 Word.word)))) then
     return ((mask0 (((( 8 :: int)::ii) * ((id0 size1)))) ( 0x000000000004FFFF ::  64 Word.word)
               :: ( 'p8_times_n::len)Word.word))
   else
     (MEMr addr size1  :: (( 'p8_times_n::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'p8_times_n::len)Word.word) . 
     return ((reverse_endianness w__1  :: ( 'p8_times_n::len)Word.word)))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  size1  :: " int "


\<comment> \<open>\<open>
is the same as [MEMr_wrapper] except that the read is marked as part of a load linked / store conditional pair.
\<close>\<close>
\<comment> \<open>\<open>val MEMr_reserve_wrapper : forall 'p8_times_n. Size 'p8_times_n => mword ty64 -> integer -> M (mword 'p8_times_n)\<close>\<close>

definition MEMr_reserve_wrapper  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('p8_times_n::len)Word.word),(exception))monad \<close>  where 
     \<open> MEMr_reserve_wrapper addr size1 = (
   (MEMr_reserve addr size1  :: (( 'p8_times_n::len)Word.word) M) \<bind> ((\<lambda> (w__0 :: ( 'p8_times_n::len)Word.word) . 
   return ((reverse_endianness w__0  :: ( 'p8_times_n::len)Word.word)))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  size1  :: " int "


\<comment> \<open>\<open>val init_cp0_state : unit -> M unit\<close>\<close>

definition init_cp0_state  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_cp0_state _ = ( set_StatusReg_BEV CP0Status_ref ((cast_unit_vec0 B1  ::  1 Word.word)))\<close>


\<comment> \<open>\<open>val init_cp2_state : unit -> M unit\<close>\<close>

\<comment> \<open>\<open>val cp2_next_pc : unit -> M unit\<close>\<close>

\<comment> \<open>\<open>val dump_cp2_state : unit -> M unit\<close>\<close>

\<comment> \<open>\<open>val tlbEntryMatch : mword ty2 -> mword ty27 -> mword ty8 -> TLBEntry -> bool\<close>\<close>

definition tlbEntryMatch  :: \<open>(2)Word.word \<Rightarrow>(27)Word.word \<Rightarrow>(8)Word.word \<Rightarrow> TLBEntry \<Rightarrow> bool \<close>  where 
     \<open> tlbEntryMatch r vpn2 asid entry = (
   (let entryValid = ((get_TLBEntry_valid entry  ::  1 Word.word)) in
   (let entryR = ((get_TLBEntry_r entry  ::  2 Word.word)) in
   (let entryMask = ((get_TLBEntry_pagemask entry  ::  16 Word.word)) in
   (let entryVPN = ((get_TLBEntry_vpn2 entry  ::  27 Word.word)) in
   (let entryASID = ((get_TLBEntry_asid entry  ::  8 Word.word)) in
   (let entryG = ((get_TLBEntry_g entry  ::  1 Word.word)) in
   (let (vpnMask :: 27 bits) =
     ((not_vec ((mips_zero_extend (( 27 :: int)::ii) entryMask  ::  27 Word.word))  ::  27 Word.word)) in
   (((bits_to_bool entryValid)) \<and> ((((((r = entryR))) \<and> ((((((((and_vec vpn2 vpnMask  ::  27 Word.word)) = ((and_vec entryVPN vpnMask  ::  27 Word.word))))) \<and> ((((((asid = entryASID))) \<or> ((bits_to_bool entryG))))))))))))))))))))\<close> 
  for  r  :: "(2)Word.word " 
  and  vpn2  :: "(27)Word.word " 
  and  asid  :: "(8)Word.word " 
  and  entry  :: " TLBEntry "


\<comment> \<open>\<open>val tlbSearch : mword ty64 -> M (maybe (mword ty6))\<close>\<close>

definition tlbSearch  :: \<open>(64)Word.word \<Rightarrow>((register_value),(((6)Word.word)option),(exception))monad \<close>  where 
     \<open> tlbSearch VAddr = (
   catch_early_return
     ((let r = ((subrange_vec_dec VAddr (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word)) in
     (let vpn2 = ((subrange_vec_dec VAddr (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word)) in
     liftR (read_reg TLBEntryHi_ref) \<bind> ((\<lambda> (w__0 :: TLBEntryHiReg) . 
     (let asid = ((get_TLBEntryHiReg_ASID w__0  ::  8 Word.word)) in
     (let loop_idx_lower = ((( 0 :: int)::ii)) in
     (let loop_idx_upper = ((( 63 :: int)::ii)) in
     (foreachM (index_list loop_idx_lower loop_idx_upper (( 1 :: int)::ii)) () 
       ((\<lambda> idx unit_var . 
         liftR (read_reg ((access_list_dec TLBEntries idx))) \<bind> ((\<lambda> (w__1 :: TLBEntry) . 
         if ((tlbEntryMatch r vpn2 asid w__1)) then
           (early_return (Some ((to_bits (( 6 :: int)::ii) idx  ::  6 Word.word))) :: (unit, ( ( 6 Word.word)option)) MR)
         else return () ))))) \<then>
     return None)))))))))\<close> 
  for  VAddr  :: "(64)Word.word "


\<comment> \<open>\<open>val MIPSSegmentOf : mword ty64 -> M (AccessLevel * maybe (mword ty64))\<close>\<close>

definition MIPSSegmentOf  :: \<open>(64)Word.word \<Rightarrow>((register_value),(AccessLevel*((64)Word.word)option),(exception))monad \<close>  where 
     \<open> MIPSSegmentOf vAddr = (
   (let compat32 =
     (((subrange_vec_dec vAddr (( 61 :: int)::ii) (( 31 :: int)::ii)  ::  31 Word.word)) = ( 0b1111111111111111111111111111111 ::  31 Word.word)) in
   (let b__0 = ((subrange_vec_dec vAddr (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word)) in
   if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     return ((case  (compat32, (subrange_vec_dec vAddr (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) of
       (True, b__1) =>
        if (((b__1 = ( 0b11 ::  2 Word.word)))) then (Kernel, None)
        else if (((b__1 = ( 0b10 ::  2 Word.word)))) then (Supervisor, None)
        else if (((b__1 = ( 0b01 ::  2 Word.word)))) then
          (Kernel,
           Some ((concat_vec ( 0x00000000 ::  32 Word.word)
                    ((concat_vec ( 0b000 ::  3 Word.word)
                        ((subrange_vec_dec vAddr (( 28 :: int)::ii) (( 0 :: int)::ii)  ::  29 Word.word))
                       ::  32 Word.word))
                   ::  64 Word.word)))
        else if (((b__1 = ( 0b00 ::  2 Word.word)))) then
          (Kernel,
           Some ((concat_vec ( 0x00000000 ::  32 Word.word)
                    ((concat_vec ( 0b000 ::  3 Word.word)
                        ((subrange_vec_dec vAddr (( 28 :: int)::ii) (( 0 :: int)::ii)  ::  29 Word.word))
                       ::  32 Word.word))
                   ::  64 Word.word)))
        else (case  (True, b__1) of   (_, _) => (Kernel, None) )
     | (_, _) => (Kernel, None)
     ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     return (Kernel,
             Some ((concat_vec ( 0b00000 ::  5 Word.word)
                      ((subrange_vec_dec vAddr (( 58 :: int)::ii) (( 0 :: int)::ii)  ::  59 Word.word))
                     ::  64 Word.word)))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then return (Supervisor, None)
   else if (((b__0 = ( 0b00 ::  2 Word.word)))) then return (User, None)
   else assert_exp False (''Pattern match failure at ../mips/mips_tlb.sail 64:1 - 75:2'') \<then> exit0 () )))\<close> 
  for  vAddr  :: "(64)Word.word "


\<comment> \<open>\<open>val TLBTranslate2 : mword ty64 -> MemAccessType -> AccessLevel -> M (mword ty64 * MemAccessCapRestriction)\<close>\<close>

definition TLBTranslate2  :: \<open>(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow> AccessLevel \<Rightarrow>((register_value),((64)Word.word*MemAccessCapRestriction),(exception))monad \<close>  where 
     \<open> TLBTranslate2 vAddr accessType accessLevel = (
   (tlbSearch vAddr  :: ( ( 6 Word.word)option) M) \<bind> ((\<lambda> idx . 
   (case  idx of
     Some (idx) =>
      (let i = (Word.uint idx) in
      read_reg ((access_list_dec TLBEntries i)) \<bind> ((\<lambda> entry . 
      (let entryMask = ((get_TLBEntry_pagemask entry  ::  16 Word.word)) in
      (let b__0 = entryMask in
      (if (((b__0 = ( 0x0000 ::  16 Word.word)))) then return (( 12 :: int)::ii)
       else if (((b__0 = ( 0x0003 ::  16 Word.word)))) then return (( 14 :: int)::ii)
       else if (((b__0 = ( 0x000F ::  16 Word.word)))) then return (( 16 :: int)::ii)
       else if (((b__0 = ( 0x003F ::  16 Word.word)))) then return (( 18 :: int)::ii)
       else if (((b__0 = ( 0x00FF ::  16 Word.word)))) then return (( 20 :: int)::ii)
       else if (((b__0 = ( 0x03FF ::  16 Word.word)))) then return (( 22 :: int)::ii)
       else if (((b__0 = ( 0x0FFF ::  16 Word.word)))) then return (( 24 :: int)::ii)
       else if (((b__0 = ( 0x3FFF ::  16 Word.word)))) then return (( 26 :: int)::ii)
       else if (((b__0 = ( 0xFFFF ::  16 Word.word)))) then return (( 28 :: int)::ii)
       else undefined_range (( 12 :: int)::ii) (( 28 :: int)::ii)) \<bind> ((\<lambda> (evenOddBit :: int) . 
      (let isOdd = (access_vec_dec vAddr evenOddBit) in
      (let ((caps :: 1 bits), (caplg :: 1 bits), (capl :: 1 bits), (pfn :: 24 bits), (d :: 1
        bits), (v :: 1 bits)) =
        (if ((bit_to_bool isOdd)) then
          ((get_TLBEntry_caps1 entry  ::  1 Word.word),
           (get_TLBEntry_caplg1 entry  ::  1 Word.word),
           (get_TLBEntry_capl1 entry  ::  1 Word.word),
           (get_TLBEntry_pfn1 entry  ::  24 Word.word),
           (get_TLBEntry_d1 entry  ::  1 Word.word),
           (get_TLBEntry_v1 entry  ::  1 Word.word))
        else
          ((get_TLBEntry_caps0 entry  ::  1 Word.word),
           (get_TLBEntry_caplg0 entry  ::  1 Word.word),
           (get_TLBEntry_capl0 entry  ::  1 Word.word),
           (get_TLBEntry_pfn0 entry  ::  24 Word.word),
           (get_TLBEntry_d0 entry  ::  1 Word.word),
           (get_TLBEntry_v0 entry  ::  1 Word.word))) in
      if ((\<not> ((bits_to_bool v)))) then
        (SignalExceptionTLB (if (((accessType = StoreData))) then XTLBInvS else XTLBInvL) vAddr
          :: (( 64 Word.word * MemAccessCapRestriction)) M)
      else if ((((((accessType = StoreData))) \<and> ((\<not> ((bits_to_bool d))))))) then
        (SignalExceptionTLB TLBMod vAddr  :: (( 64 Word.word * MemAccessCapRestriction)) M)
      else
        (let (res :: 64 bits) =
          ((subrange_subrange_concat (( 64 :: int)::ii) pfn (( 23 :: int)::ii) ((evenOddBit - (( 12 :: int)::ii))) vAddr
             ((evenOddBit - (( 1 :: int)::ii))) (( 0 :: int)::ii)
            ::  64 Word.word)) in
        (if (((accessType = StoreData))) then
           return (if ((bits_to_bool caps)) then Trap
                   else Unrestricted)
         else if ((bits_to_bool capl)) then return Clear
         else
           (case  accessLevel of
             User =>
              read_reg TLBEntryHi_ref \<bind> ((\<lambda> (w__11 :: TLBEntryHiReg) . 
              return ((get_TLBEntryHiReg_CLGU w__11  ::  1 Word.word))))
           | Supervisor =>
              read_reg TLBEntryHi_ref \<bind> ((\<lambda> (w__12 :: TLBEntryHiReg) . 
              return ((get_TLBEntryHiReg_CLGS w__12  ::  1 Word.word))))
           | Kernel =>
              read_reg TLBEntryHi_ref \<bind> ((\<lambda> (w__13 :: TLBEntryHiReg) . 
              return ((get_TLBEntryHiReg_CLGK w__13  ::  1 Word.word))))
           ) \<bind> ((\<lambda> (gclg :: 1 bits) . 
           return (if ((neq_bool ((bits_to_bool gclg)) ((bits_to_bool caplg)))) then Trap
                   else Unrestricted)))) \<bind> ((\<lambda> macr . 
        return (res, macr)))))))))))))
   | None =>
      (SignalExceptionTLB (if (((accessType = StoreData))) then XTLBRefillS else XTLBRefillL) vAddr
        :: (( 64 Word.word * MemAccessCapRestriction)) M)
   ))))\<close> 
  for  vAddr  :: "(64)Word.word " 
  and  accessType  :: " MemAccessType " 
  and  accessLevel  :: " AccessLevel "


\<comment> \<open>\<open>
THIS is the same as [TLBTranslate] except that it also returns any
constraints on tagged capability operations.
\<close>\<close>
\<comment> \<open>\<open>val TLBTranslateC : mword ty64 -> MemAccessType -> M (mword ty64 * MemAccessCapRestriction)\<close>\<close>

definition TLBTranslateC  :: \<open>(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow>((register_value),((64)Word.word*MemAccessCapRestriction),(exception))monad \<close>  where 
     \<open> TLBTranslateC vAddr accessType = (
   getAccessLevel ()  \<bind> ((\<lambda> currentAccessLevel . 
   (let compat32 =
     (((subrange_vec_dec vAddr (( 61 :: int)::ii) (( 31 :: int)::ii)  ::  31 Word.word)) = ( 0b1111111111111111111111111111111 ::  31 Word.word)) in
   (MIPSSegmentOf vAddr  :: ((AccessLevel *  ( 64 Word.word)option)) M) \<bind> ((\<lambda> varstup .  (let ((requiredLevel ::
     AccessLevel), (addr ::  ( 64 bits)option)) = varstup in
   if ((\<not> ((grantsAccess currentAccessLevel requiredLevel)))) then
     (SignalExceptionBadAddr (if (((accessType = StoreData))) then AdES else AdEL) vAddr
       :: (( 64 Word.word * MemAccessCapRestriction)) M)
   else
     (case  addr of
       Some (a) => return (a, Unrestricted)
     | None =>
        if (((((\<not> compat32)) \<and> ((((Word.uint ((subrange_vec_dec vAddr (( 61 :: int)::ii) (( 0 :: int)::ii)  ::  62 Word.word)))) > MAX_VA))))) then
          (SignalExceptionBadAddr (if (((accessType = StoreData))) then AdES else AdEL) vAddr
            :: (( 64 Word.word * MemAccessCapRestriction)) M)
        else
          (TLBTranslate2 vAddr accessType requiredLevel
            :: (( 64 Word.word * MemAccessCapRestriction)) M)
     ) \<bind> ((\<lambda> varstup .  (let ((pa :: 64 bits), (c :: MemAccessCapRestriction)) = varstup in
     if ((((Word.uint pa)) > MAX_PA)) then
       (SignalExceptionBadAddr (if (((accessType = StoreData))) then AdES else AdEL) vAddr
         :: (( 64 Word.word * MemAccessCapRestriction)) M)
     else return (pa, c)))))))))))\<close> 
  for  vAddr  :: "(64)Word.word " 
  and  accessType  :: " MemAccessType "


\<comment> \<open>\<open>
THIS`(addr, acces_type)` translates the virtual address, `addr`, to a physical address assuming the given `access_type` (load or store). If the TLB lookup fails an ISA exception is raised.
\<close>\<close>
\<comment> \<open>\<open>val TLBTranslate : mword ty64 -> MemAccessType -> M (mword ty64)\<close>\<close>

definition TLBTranslate  :: \<open>(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> TLBTranslate vAddr accessType = (
   (TLBTranslateC vAddr accessType  :: (( 64 Word.word * MemAccessCapRestriction)) M) \<bind> ((\<lambda> varstup .  (let (addr, c) = varstup in
   return addr))))\<close> 
  for  vAddr  :: "(64)Word.word " 
  and  accessType  :: " MemAccessType "


\<comment> \<open>\<open>val CPtrCmpOp_of_num : integer -> CPtrCmpOp\<close>\<close>

definition CPtrCmpOp_of_num  :: \<open> int \<Rightarrow> CPtrCmpOp \<close>  where 
     \<open> CPtrCmpOp_of_num arg1 = (
   (let l__111 = arg1 in
   if (((l__111 = (( 0 :: int)::ii)))) then CEQ
   else if (((l__111 = (( 1 :: int)::ii)))) then CNE
   else if (((l__111 = (( 2 :: int)::ii)))) then CLT
   else if (((l__111 = (( 3 :: int)::ii)))) then CLE
   else if (((l__111 = (( 4 :: int)::ii)))) then CLTU
   else if (((l__111 = (( 5 :: int)::ii)))) then CLEU
   else if (((l__111 = (( 6 :: int)::ii)))) then CEXEQ
   else CNEXEQ))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_CPtrCmpOp : CPtrCmpOp -> integer\<close>\<close>

fun num_of_CPtrCmpOp  :: \<open> CPtrCmpOp \<Rightarrow> int \<close>  where 
     \<open> num_of_CPtrCmpOp CEQ = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_CPtrCmpOp CNE = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_CPtrCmpOp CLT = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_CPtrCmpOp CLE = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_CPtrCmpOp CLTU = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_CPtrCmpOp CLEU = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_CPtrCmpOp CEXEQ = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_CPtrCmpOp CNEXEQ = ( (( 7 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_CPtrCmpOp : unit -> M CPtrCmpOp\<close>\<close>

definition undefined_CPtrCmpOp  :: \<open> unit \<Rightarrow>((register_value),(CPtrCmpOp),(exception))monad \<close>  where 
     \<open> undefined_CPtrCmpOp _ = ( internal_pick [CEQ,CNE,CLT,CLE,CLTU,CLEU,CEXEQ,CNEXEQ])\<close>


\<comment> \<open>\<open>val ClearRegSet_of_num : integer -> ClearRegSet\<close>\<close>

definition ClearRegSet_of_num  :: \<open> int \<Rightarrow> ClearRegSet \<close>  where 
     \<open> ClearRegSet_of_num arg1 = (
   (let l__108 = arg1 in
   if (((l__108 = (( 0 :: int)::ii)))) then GPLo
   else if (((l__108 = (( 1 :: int)::ii)))) then GPHi
   else if (((l__108 = (( 2 :: int)::ii)))) then CLo
   else CHi))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_ClearRegSet : ClearRegSet -> integer\<close>\<close>

fun num_of_ClearRegSet  :: \<open> ClearRegSet \<Rightarrow> int \<close>  where 
     \<open> num_of_ClearRegSet GPLo = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_ClearRegSet GPHi = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_ClearRegSet CLo = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_ClearRegSet CHi = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_ClearRegSet : unit -> M ClearRegSet\<close>\<close>

definition undefined_ClearRegSet  :: \<open> unit \<Rightarrow>((register_value),(ClearRegSet),(exception))monad \<close>  where 
     \<open> undefined_ClearRegSet _ = ( internal_pick [GPLo,GPHi,CLo,CHi])\<close>


definition num_flags  :: \<open> int \<close>  where 
     \<open> num_flags = ( (( 1 :: int)::ii))\<close>


definition reserved_otypes  :: \<open> int \<close>  where 
     \<open> reserved_otypes = ( (( 16 :: int)::ii))\<close>


definition otype_unsealed  :: \<open> int \<close>  where 
     \<open> otype_unsealed = ( ((( 0 :: int)-( 1 :: int))::ii))\<close>


definition otype_sentry  :: \<open> int \<close>  where 
     \<open> otype_sentry = ( ((( 0 :: int)-( 2 :: int))::ii))\<close>


definition otype_unsealed_bits  :: \<open>(64)Word.word \<close>  where 
     \<open> otype_unsealed_bits = ( ( 0xFFFFFFFFFFFFFFFF ::  64 Word.word))\<close>


definition otype_sentry_bits  :: \<open>(64)Word.word \<close>  where 
     \<open> otype_sentry_bits = ( ( 0xFFFFFFFFFFFFFFFE ::  64 Word.word))\<close>


definition max_otype  :: \<open> int \<close>  where 
     \<open> max_otype = ( (( 262127 :: int)::ii))\<close>


definition resetE  :: \<open>(6)Word.word \<close>  where 
     \<open> resetE = ( ( 0b110100 ::  6 Word.word))\<close>


definition resetT  :: \<open>(14)Word.word \<close>  where 
     \<open> resetT = ( ( 0b01000000000000 ::  14 Word.word))\<close>


definition null_cap  :: \<open> Capability \<close>  where 
     \<open> null_cap = (
  (| Capability_tag = False, 
     Capability_uperms = ((zeros_implicit (( 4 :: int)::ii) ()   ::  4 Word.word)), 
     Capability_permit_set_CID = False, 
     Capability_access_system_regs = False, 
     Capability_permit_unseal = False, 
     Capability_permit_ccall = False, 
     Capability_permit_seal = False, 
     Capability_permit_store_local_cap = False, 
     Capability_permit_store_cap = False, 
     Capability_permit_load_cap = False, 
     Capability_permit_store = False, 
     Capability_permit_load = False, 
     Capability_permit_execute = False, 
     Capability_global = False, 
     Capability_reserved = ((zeros_implicit (( 3 :: int)::ii) ()   ::  3 Word.word)), 
     Capability_internal_e = True, 
     Capability_E = resetE, 
     Capability_sealed = False, 
     Capability_B = ((zeros_implicit (( 14 :: int)::ii) ()   ::  14 Word.word)), 
     Capability_T = resetT, 
     Capability_otype = ((ones_implicit (( 18 :: int)::ii) ()   ::  18 Word.word)), 
     Capability_address = ((zeros_implicit (( 64 :: int)::ii) ()   ::  64 Word.word)) |) )\<close>


definition default_cap  :: \<open> Capability \<close>  where 
     \<open> default_cap = (
  (| Capability_tag = True, 
     Capability_uperms = ((ones_implicit (( 4 :: int)::ii) ()   ::  4 Word.word)), 
     Capability_permit_set_CID = True, 
     Capability_access_system_regs = True, 
     Capability_permit_unseal = True, 
     Capability_permit_ccall = True, 
     Capability_permit_seal = True, 
     Capability_permit_store_local_cap = True, 
     Capability_permit_store_cap = True, 
     Capability_permit_load_cap = True, 
     Capability_permit_store = True, 
     Capability_permit_load = True, 
     Capability_permit_execute = True, 
     Capability_global = True, 
     Capability_reserved = ((zeros_implicit (( 3 :: int)::ii) ()   ::  3 Word.word)), 
     Capability_internal_e = True, 
     Capability_E = resetE, 
     Capability_sealed = False, 
     Capability_B = ((zeros_implicit (( 14 :: int)::ii) ()   ::  14 Word.word)), 
     Capability_T = resetT, 
     Capability_otype = ((ones_implicit (( 18 :: int)::ii) ()   ::  18 Word.word)), 
     Capability_address = ((zeros_implicit (( 64 :: int)::ii) ()   ::  64 Word.word)) |) )\<close>


definition cap_size  :: \<open> int \<close>  where 
     \<open> cap_size = ( (( 16 :: int)::ii))\<close>


definition caps_per_cacheline  :: \<open> int \<close>  where 
     \<open> caps_per_cacheline = ( (( 8 :: int)::ii))\<close>


\<comment> \<open>\<open>val capBitsToCapability : bool -> mword ty128 -> Capability\<close>\<close>

definition capBitsToCapability  :: \<open> bool \<Rightarrow>(128)Word.word \<Rightarrow> Capability \<close>  where 
     \<open> capBitsToCapability t c = (
   (let (internal_exponent :: bool) = (bit_to_bool ((access_vec_dec c (( 90 :: int)::ii)))) in
   (let (otype :: 18 bits) = ((subrange_vec_dec c (( 108 :: int)::ii) (( 91 :: int)::ii)  ::  18 Word.word)) in
   (let (sealed :: bool) = (otype \<noteq> ((ones_implicit (( 18 :: int)::ii) ()   ::  18 Word.word))) in
   (let (E :: 6 bits) = ((zeros_implicit (( 6 :: int)::ii) ()   ::  6 Word.word)) in
   (let (Bs :: 14 bits) = ((zeros_implicit (( 14 :: int)::ii) ()   ::  14 Word.word)) in
   (let (T :: 12 bits) = ((zeros_implicit (( 12 :: int)::ii) ()   ::  12 Word.word)) in
   (let (lenMSBs :: 2 bits) = ((zeros_implicit (( 2 :: int)::ii) ()   ::  2 Word.word)) in
   (let ((Bs ::  14 Word.word), (E ::  6 Word.word), (T ::  12 Word.word), (lenMSBs ::  2 Word.word)) =
     (if internal_exponent then
       (let (E :: 6 bits) =
         ((concat_vec ((subrange_vec_dec c (( 80 :: int)::ii) (( 78 :: int)::ii)  ::  3 Word.word))
            ((subrange_vec_dec c (( 66 :: int)::ii) (( 64 :: int)::ii)  ::  3 Word.word))
           ::  6 Word.word)) in
       (let (lenMSBs :: 2 bits) = (( 0b01 ::  2 Word.word)) in
       (let (T :: 12 bits) =
         ((concat_vec ((subrange_vec_dec c (( 89 :: int)::ii) (( 81 :: int)::ii)  ::  9 Word.word)) ( 0b000 ::  3 Word.word)
           ::  12 Word.word)) in
       (let (Bs :: 14 bits) =
         ((concat_vec ((subrange_vec_dec c (( 77 :: int)::ii) (( 67 :: int)::ii)  ::  11 Word.word)) ( 0b000 ::  3 Word.word)
           ::  14 Word.word)) in
       (Bs, E, T, lenMSBs)))))
     else
       (let (lenMSBs :: 2 bits) = (( 0b00 ::  2 Word.word)) in
       (let (T :: 12 bits) = ((subrange_vec_dec c (( 89 :: int)::ii) (( 78 :: int)::ii)  ::  12 Word.word)) in
       (let (Bs :: 14 bits) = ((subrange_vec_dec c (( 77 :: int)::ii) (( 64 :: int)::ii)  ::  14 Word.word)) in
       (Bs, E, T, lenMSBs))))) in
   (let carry_out =
     (if ((zopz0zI_u T ((subrange_vec_dec Bs (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word)))) then ( 0b01 ::  2 Word.word)
     else ( 0b00 ::  2 Word.word)) in
   (let Ttop2 =
     ((add_vec ((add_vec ((subrange_vec_dec Bs (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) lenMSBs  ::  2 Word.word))
        carry_out
       ::  2 Word.word)) in
   (| Capability_tag = t, 
      Capability_uperms = ((subrange_vec_dec c (( 127 :: int)::ii) (( 124 :: int)::ii)  ::  4 Word.word)), 
      Capability_permit_set_CID = ((bit_to_bool ((access_vec_dec c (( 123 :: int)::ii))))), 
      Capability_access_system_regs = ((bit_to_bool ((access_vec_dec c (( 122 :: int)::ii))))), 
      Capability_permit_unseal = ((bit_to_bool ((access_vec_dec c (( 121 :: int)::ii))))), 
      Capability_permit_ccall = ((bit_to_bool ((access_vec_dec c (( 120 :: int)::ii))))), 
      Capability_permit_seal = ((bit_to_bool ((access_vec_dec c (( 119 :: int)::ii))))), 
      Capability_permit_store_local_cap = ((bit_to_bool ((access_vec_dec c (( 118 :: int)::ii))))), 
      Capability_permit_store_cap = ((bit_to_bool ((access_vec_dec c (( 117 :: int)::ii))))), 
      Capability_permit_load_cap = ((bit_to_bool ((access_vec_dec c (( 116 :: int)::ii))))), 
      Capability_permit_store = ((bit_to_bool ((access_vec_dec c (( 115 :: int)::ii))))), 
      Capability_permit_load = ((bit_to_bool ((access_vec_dec c (( 114 :: int)::ii))))), 
      Capability_permit_execute = ((bit_to_bool ((access_vec_dec c (( 113 :: int)::ii))))), 
      Capability_global = ((bit_to_bool ((access_vec_dec c (( 112 :: int)::ii))))), 
      Capability_reserved = ((subrange_vec_dec c (( 111 :: int)::ii) (( 109 :: int)::ii)  ::  3 Word.word)), 
      Capability_internal_e = internal_exponent, 
      Capability_E = E, 
      Capability_sealed = sealed, 
      Capability_B = Bs, 
      Capability_T = ((concat_vec Ttop2 T  ::  14 Word.word)), 
      Capability_otype = otype, 
      Capability_address = ((subrange_vec_dec c (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |))))))))))))\<close> 
  for  t  :: " bool " 
  and  c  :: "(128)Word.word "


\<comment> \<open>\<open>val getCapHardPerms : Capability -> mword ty12\<close>\<close>

definition getCapHardPerms  :: \<open> Capability \<Rightarrow>(12)Word.word \<close>  where 
     \<open> getCapHardPerms cap = (
   (concat_vec ((bool_to_bits(Capability_permit_set_CID   cap)  ::  1 Word.word))
      ((concat_vec ((bool_to_bits(Capability_access_system_regs   cap)  ::  1 Word.word))
          ((concat_vec ((bool_to_bits(Capability_permit_unseal   cap)  ::  1 Word.word))
              ((concat_vec ((bool_to_bits(Capability_permit_ccall   cap)  ::  1 Word.word))
                  ((concat_vec ((bool_to_bits(Capability_permit_seal   cap)  ::  1 Word.word))
                      ((concat_vec
                          ((bool_to_bits(Capability_permit_store_local_cap   cap)  ::  1 Word.word))
                          ((concat_vec ((bool_to_bits(Capability_permit_store_cap   cap)  ::  1 Word.word))
                              ((concat_vec
                                  ((bool_to_bits(Capability_permit_load_cap   cap)  ::  1 Word.word))
                                  ((concat_vec
                                      ((bool_to_bits(Capability_permit_store   cap)  ::  1 Word.word))
                                      ((concat_vec
                                          ((bool_to_bits(Capability_permit_load   cap)  ::  1 Word.word))
                                          ((concat_vec
                                              ((bool_to_bits(Capability_permit_execute   cap)
                                                 ::  1 Word.word))
                                              ((bool_to_bits(Capability_global   cap)  ::  1 Word.word))
                                             ::  2 Word.word))
                                         ::  3 Word.word))
                                     ::  4 Word.word))
                                 ::  5 Word.word))
                             ::  6 Word.word))
                         ::  7 Word.word))
                     ::  8 Word.word))
                 ::  9 Word.word))
             ::  10 Word.word))
         ::  11 Word.word))
     ::  12 Word.word))\<close> 
  for  cap  :: " Capability "


\<comment> \<open>\<open>val capToBits : Capability -> mword ty128\<close>\<close>

definition capToBits  :: \<open> Capability \<Rightarrow>(128)Word.word \<close>  where 
     \<open> capToBits cap = (
   (let (t_hi :: 9 bits) = ((subrange_vec_dec(Capability_T   cap) (( 11 :: int)::ii) (( 3 :: int)::ii)  ::  9 Word.word)) in
   (let (t_lo :: 3 bits) = ((subrange_vec_dec(Capability_T   cap) (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
   (let (b_hi :: 11 bits) = ((subrange_vec_dec(Capability_B   cap) (( 13 :: int)::ii) (( 3 :: int)::ii)  ::  11 Word.word)) in
   (let (b_lo :: 3 bits) = ((subrange_vec_dec(Capability_B   cap) (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
   (let ((b_lo ::  3 Word.word), (t_lo ::  3 Word.word)) =
     (if(Capability_internal_e   cap) then
       (let (t_lo :: 3 bits) = ((subrange_vec_dec(Capability_E   cap) (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
       (let (b_lo :: 3 bits) = ((subrange_vec_dec(Capability_E   cap) (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
       (b_lo, t_lo)))
     else (b_lo, t_lo)) in
   (concat_vec(Capability_uperms   cap)
      ((concat_vec ((getCapHardPerms cap  ::  12 Word.word))
          ((concat_vec(Capability_reserved   cap)
              ((concat_vec(Capability_otype   cap)
                  ((concat_vec ((bool_to_bits(Capability_internal_e   cap)  ::  1 Word.word))
                      ((concat_vec t_hi
                          ((concat_vec t_lo
                              ((concat_vec b_hi
                                  ((concat_vec b_lo(Capability_address   cap)  ::  67 Word.word))
                                 ::  78 Word.word))
                             ::  81 Word.word))
                         ::  90 Word.word))
                     ::  91 Word.word))
                 ::  109 Word.word))
             ::  112 Word.word))
         ::  124 Word.word))
     ::  128 Word.word)))))))\<close> 
  for  cap  :: " Capability "


definition null_cap_bits  :: \<open>(128)Word.word \<close>  where 
     \<open> null_cap_bits = ( (capToBits null_cap  ::  128 Word.word))\<close>


\<comment> \<open>\<open>val capToMemBits : Capability -> mword ty128\<close>\<close>

definition capToMemBits  :: \<open> Capability \<Rightarrow>(128)Word.word \<close>  where 
     \<open> capToMemBits cap = ( (xor_vec ((capToBits cap  ::  128 Word.word)) null_cap_bits  ::  128 Word.word))\<close> 
  for  cap  :: " Capability "


\<comment> \<open>\<open>val memBitsToCapability : bool -> mword ty128 -> Capability\<close>\<close>

definition memBitsToCapability  :: \<open> bool \<Rightarrow>(128)Word.word \<Rightarrow> Capability \<close>  where 
     \<open> memBitsToCapability tag b = ( capBitsToCapability tag ((xor_vec b null_cap_bits  ::  128 Word.word)))\<close> 
  for  tag  :: " bool " 
  and  b  :: "(128)Word.word "


\<comment> \<open>\<open>val getCapPerms : Capability -> mword ty31\<close>\<close>

definition getCapPerms  :: \<open> Capability \<Rightarrow>(31)Word.word \<close>  where 
     \<open> getCapPerms cap = (
   (let (perms :: 15 bits) =
     ((mips_zero_extend (( 15 :: int)::ii) ((getCapHardPerms cap  ::  12 Word.word))  ::  15 Word.word)) in
   (concat_vec ( 0x000 ::  12 Word.word) ((concat_vec(Capability_uperms   cap) perms  ::  19 Word.word))
     ::  31 Word.word)))\<close> 
  for  cap  :: " Capability "


\<comment> \<open>\<open>val setCapPerms : Capability -> mword ty31 -> Capability\<close>\<close>

definition setCapPerms  :: \<open> Capability \<Rightarrow>(31)Word.word \<Rightarrow> Capability \<close>  where 
     \<open> setCapPerms cap perms = (
   ( cap (|
     Capability_uperms := ((subrange_vec_dec perms (( 18 :: int)::ii) (( 15 :: int)::ii)  ::  4 Word.word)), Capability_permit_set_CID :=
       ((bit_to_bool ((access_vec_dec perms (( 11 :: int)::ii))))), Capability_access_system_regs :=
       ((bit_to_bool ((access_vec_dec perms (( 10 :: int)::ii))))), Capability_permit_unseal :=
       ((bit_to_bool ((access_vec_dec perms (( 9 :: int)::ii))))), Capability_permit_ccall :=
       ((bit_to_bool ((access_vec_dec perms (( 8 :: int)::ii))))), Capability_permit_seal :=
       ((bit_to_bool ((access_vec_dec perms (( 7 :: int)::ii))))), Capability_permit_store_local_cap :=
       ((bit_to_bool ((access_vec_dec perms (( 6 :: int)::ii))))), Capability_permit_store_cap :=
       ((bit_to_bool ((access_vec_dec perms (( 5 :: int)::ii))))), Capability_permit_load_cap :=
       ((bit_to_bool ((access_vec_dec perms (( 4 :: int)::ii))))), Capability_permit_store :=
       ((bit_to_bool ((access_vec_dec perms (( 3 :: int)::ii))))), Capability_permit_load :=
       ((bit_to_bool ((access_vec_dec perms (( 2 :: int)::ii))))), Capability_permit_execute :=
       ((bit_to_bool ((access_vec_dec perms (( 1 :: int)::ii))))), Capability_global :=
       ((bit_to_bool ((access_vec_dec perms (( 0 :: int)::ii))))) |)))\<close> 
  for  cap  :: " Capability " 
  and  perms  :: "(31)Word.word "


\<comment> \<open>\<open>val sealCap : Capability -> mword ty24 -> (bool * Capability)\<close>\<close>

definition sealCap  :: \<open> Capability \<Rightarrow>(24)Word.word \<Rightarrow> bool*Capability \<close>  where 
     \<open> sealCap cap otyp = (
   (True,
    ( cap (|
      Capability_sealed := True, Capability_otype :=
        ((subrange_vec_dec otyp (( 17 :: int)::ii) (( 0 :: int)::ii)  ::  18 Word.word)) |))))\<close> 
  for  cap  :: " Capability " 
  and  otyp  :: "(24)Word.word "


\<comment> \<open>\<open>val unsealCap : Capability -> Capability\<close>\<close>

definition unsealCap  :: \<open> Capability \<Rightarrow> Capability \<close>  where 
     \<open> unsealCap cap = (
   ( cap (|
     Capability_sealed := False, Capability_otype := ((ones_implicit (( 18 :: int)::ii) ()   ::  18 Word.word)) |)))\<close> 
  for  cap  :: " Capability "


\<comment> \<open>\<open>val getCapTop : Capability -> integer\<close>\<close>

definition getCapTop  :: \<open> Capability \<Rightarrow> int \<close>  where 
     \<open> getCapTop c = (
   (let (_, top1) = (getCapBounds c) in
   top1))\<close> 
  for  c  :: " Capability "


\<comment> \<open>\<open>val getCapOffset : Capability -> integer\<close>\<close>

definition getCapOffset  :: \<open> Capability \<Rightarrow> int \<close>  where 
     \<open> getCapOffset c = (
   (let base = (getCapBase c) in
   ((((Word.uint(Capability_address   c))) - base)) mod ((pow2 (( 64 :: int)::ii)))))\<close> 
  for  c  :: " Capability "


\<comment> \<open>\<open>val getCapLength : Capability -> M integer\<close>\<close>

definition getCapLength  :: \<open> Capability \<Rightarrow>((register_value),(int),(exception))monad \<close>  where 
     \<open> getCapLength c = (
   (let (base, top1) = (getCapBounds c) in
   assert_exp (((((\<not>(Capability_tag   c))) \<or> ((top1 \<ge> base))))) (''cheri_prelude_128.sail 318:40 - 318:41'') \<then>
   return ((((top1 - base)) mod ((pow2 (( 65 :: int)::ii)))))))\<close> 
  for  c  :: " Capability "


\<comment> \<open>\<open>val getCapCursor : Capability -> integer\<close>\<close>

definition getCapCursor  :: \<open> Capability \<Rightarrow> int \<close>  where 
     \<open> getCapCursor cap = ( Word.uint(Capability_address   cap))\<close> 
  for  cap  :: " Capability "


\<comment> \<open>\<open>val setCapAddr : Capability -> mword ty64 -> (bool * Capability)\<close>\<close>

definition setCapAddr  :: \<open> Capability \<Rightarrow>(64)Word.word \<Rightarrow> bool*Capability \<close>  where 
     \<open> setCapAddr c addr = (
   (let newCap = (( c (| Capability_address := addr |))) in
   (let representable = (capBoundsEqual c newCap) in
   (representable, newCap))))\<close> 
  for  c  :: " Capability " 
  and  addr  :: "(64)Word.word "


\<comment> \<open>\<open>val incCapOffset : Capability -> mword ty64 -> (bool * Capability)\<close>\<close>

definition incCapOffset  :: \<open> Capability \<Rightarrow>(64)Word.word \<Rightarrow> bool*Capability \<close>  where 
     \<open> incCapOffset c delta = (
   (let (newAddress :: 64 bits) = ((add_vec(Capability_address   c) delta  ::  64 Word.word)) in
   (let newCap = (( c (| Capability_address := newAddress |))) in
   (let representable = (capBoundsEqual c newCap) in
   (representable, newCap)))))\<close> 
  for  c  :: " Capability " 
  and  delta  :: "(64)Word.word "


\<comment> \<open>\<open>val setCapBounds : Capability -> mword ty64 -> mword ty65 -> (bool * Capability)\<close>\<close>

definition setCapBounds  :: \<open> Capability \<Rightarrow>(64)Word.word \<Rightarrow>(65)Word.word \<Rightarrow> bool*Capability \<close>  where 
     \<open> setCapBounds cap base top1 = (
   (let base65 = ((concat_vec ( 0b0 ::  1 Word.word) base  ::  65 Word.word)) in
   (let length1 = ((sub_vec top1 base65  ::  65 Word.word)) in
   (let e =
     ((( 52 :: int)::ii) -
       ((count_leading_zeros ((subrange_vec_dec length1 (( 64 :: int)::ii) (( 13 :: int)::ii)  ::  52 Word.word))))) in
   (let ie = ((((e \<noteq> (( 0 :: int)::ii)))) \<or> ((bit_to_bool ((access_vec_dec length1 (( 12 :: int)::ii)))))) in
   (let Bbits = ((vector_truncate base (( 14 :: int)::ii)  ::  14 Word.word)) in
   (let Tbits = ((vector_truncate top1 (( 14 :: int)::ii)  ::  14 Word.word)) in
   (let (lostSignificantTop :: bool) = False in
   (let (lostSignificantBase :: bool) = False in
   (let (incE :: bool) = False in
   (let ((Bbits ::  14 Word.word), (Tbits ::  14 Word.word), (incE :: bool), (lostSignificantBase :: bool), (lostSignificantTop ::
     bool)) =
     (if ie then
       (let B_ie =
         ((vector_truncate ((shiftr base ((e + (( 3 :: int)::ii)))  ::  64 Word.word)) (( 11 :: int)::ii)
           ::  11 Word.word)) in
       (let T_ie =
         ((vector_truncate ((shiftr top1 ((e + (( 3 :: int)::ii)))  ::  65 Word.word)) (( 11 :: int)::ii)  ::  11 Word.word)) in
       (let (maskLo :: 65 bits) = ((zext_ones (( 65 :: int)::ii) ((e + (( 3 :: int)::ii)))  ::  65 Word.word)) in
       (let (z65 :: 65 bits) = ((zeros_implicit (( 65 :: int)::ii) ()   ::  65 Word.word)) in
       (let (lostSignificantBase :: bool) = (((and_vec base65 maskLo  ::  65 Word.word)) \<noteq> z65) in
       (let (lostSignificantTop :: bool) = (((and_vec top1 maskLo  ::  65 Word.word)) \<noteq> z65) in
       (let (T_ie ::  11 Word.word) =
         (if lostSignificantTop then (add_vec_int T_ie (( 1 :: int)::ii)  ::  11 Word.word)
         else T_ie) in
       (let len_ie = ((sub_vec T_ie B_ie  ::  11 Word.word)) in
       (let ((B_ie ::  11 Word.word), (T_ie ::  11 Word.word), (incE :: bool), (lostSignificantBase :: bool), (lostSignificantTop ::
         bool)) =
         (if ((bit_to_bool ((access_vec_dec len_ie (( 10 :: int)::ii))))) then
           (let (incE :: bool) = True in
           (let (lostSignificantBase :: bool) =
             (lostSignificantBase \<or> ((bit_to_bool ((access_vec_dec B_ie (( 0 :: int)::ii)))))) in
           (let (lostSignificantTop :: bool) =
             (lostSignificantTop \<or> ((bit_to_bool ((access_vec_dec T_ie (( 0 :: int)::ii)))))) in
           (let (B_ie ::  11 Word.word) =
             ((vector_truncate ((shiftr base ((e + (( 4 :: int)::ii)))  ::  64 Word.word)) (( 11 :: int)::ii)
               ::  11 Word.word)) in
           (let (incT :: int) = (if lostSignificantTop then (( 1 :: int)::ii) else (( 0 :: int)::ii)) in
           (let (T_ie ::  11 Word.word) =
             ((add_vec_int
                ((vector_truncate ((shiftr top1 ((e + (( 4 :: int)::ii)))  ::  65 Word.word)) (( 11 :: int)::ii)
                   ::  11 Word.word)) incT
               ::  11 Word.word)) in
           (B_ie, T_ie, incE, lostSignificantBase, lostSignificantTop)))))))
         else (B_ie, T_ie, incE, lostSignificantBase, lostSignificantTop)) in
       (let (Bbits ::  14 Word.word) = ((concat_vec B_ie ( 0b000 ::  3 Word.word)  ::  14 Word.word)) in
       (let (Tbits ::  14 Word.word) = ((concat_vec T_ie ( 0b000 ::  3 Word.word)  ::  14 Word.word)) in
       (Bbits, Tbits, incE, lostSignificantBase, lostSignificantTop))))))))))))
     else (Bbits, Tbits, incE, lostSignificantBase, lostSignificantTop)) in
   (let newCap =
     (( cap (|
       Capability_address := base, Capability_E :=
         ((to_bits (( 6 :: int)::ii) (if incE then e + (( 1 :: int)::ii) else e)  ::  6 Word.word)), Capability_B :=
         Bbits, Capability_T := Tbits, Capability_internal_e := ie |))) in
   (let exact = (\<not> (((lostSignificantBase \<or> lostSignificantTop)))) in
   (exact, newCap))))))))))))))\<close> 
  for  cap  :: " Capability " 
  and  base  :: "(64)Word.word " 
  and  top1  :: "(65)Word.word "


\<comment> \<open>\<open>val getRepresentableAlignmentMask : mword ty64 -> mword ty64\<close>\<close>

definition getRepresentableAlignmentMask  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> getRepresentableAlignmentMask len = (
   (let (exact, c) =
     (setCapBounds default_cap
       ((sub_vec ((ones_implicit (( 64 :: int)::ii) ()   ::  64 Word.word)) len  ::  64 Word.word))
       ((concat_vec ( 0b0 ::  1 Word.word) ( 0xFFFFFFFFFFFFFFFF ::  64 Word.word)  ::  65 Word.word))) in
   (let (e :: int) = (min ((Word.uint(Capability_E   c))) (( 52 :: int)::ii)) in
   (let (e' :: int) = (if(Capability_internal_e   c) then e + (( 3 :: int)::ii) else (( 0 :: int)::ii)) in
   (slice_mask (( 64 :: int)::ii) e' (((( 64 :: int)::ii) - e'))  ::  64 Word.word)))))\<close> 
  for  len  :: "(64)Word.word "


\<comment> \<open>\<open>val getRepresentableLength : mword ty64 -> mword ty64\<close>\<close>

definition getRepresentableLength  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> getRepresentableLength len = (
   (let m = ((getRepresentableAlignmentMask len  ::  64 Word.word)) in
   (and_vec ((add_vec len ((not_vec m  ::  64 Word.word))  ::  64 Word.word)) m  ::  64 Word.word)))\<close> 
  for  len  :: "(64)Word.word "


definition CapRegs  :: \<open>(((regstate),(register_value),(Capability))register_ref)list \<close>  where 
     \<open> CapRegs = (
  [C31_ref,C30_ref,C29_ref,C28_ref,C27_ref,C26_ref,C25_ref,C24_ref,C23_ref,C22_ref,C21_ref,C20_ref,
   C19_ref,C18_ref,C17_ref,C16_ref,C15_ref,C14_ref,C13_ref,C12_ref,C11_ref,C10_ref,C09_ref,C08_ref,
   C07_ref,C06_ref,C05_ref,C04_ref,C03_ref,C02_ref,C01_ref,DDC_ref])\<close>


definition have_cp2  :: \<open> bool \<close>  where 
     \<open> have_cp2 = ( True )\<close>


\<comment> \<open>\<open>val capToString : Capability -> bool -> M string\<close>\<close>

\<comment> \<open>\<open>
THIS reads a given capability register or,
the null capabiility if the argument is zero.
\<close>\<close>
\<comment> \<open>\<open>val readCapReg : mword ty5 -> M Capability\<close>\<close>

definition readCapReg  :: \<open>(5)Word.word \<Rightarrow>((register_value),(Capability),(exception))monad \<close>  where 
     \<open> readCapReg n = (
   if (((n = ( 0b00000 ::  5 Word.word)))) then return null_cap
   else
     (let i = (Word.uint n) in
     read_reg ((access_list_dec CapRegs i))))\<close> 
  for  n  :: "(5)Word.word "


\<comment> \<open>\<open>
THIS is the same as [readCapReg] except that when the argument is zero the value of DDC is returned
instead of the null capability. This is used for instructions that expect an address, where using
null would always generate an exception.
\<close>\<close>
\<comment> \<open>\<open>val readCapRegDDC : mword ty5 -> M Capability\<close>\<close>

definition readCapRegDDC  :: \<open>(5)Word.word \<Rightarrow>((register_value),(Capability),(exception))monad \<close>  where 
     \<open> readCapRegDDC n = (
   (let i = (Word.uint n) in
   read_reg ((access_list_dec CapRegs i))))\<close> 
  for  n  :: "(5)Word.word "


\<comment> \<open>\<open>
THIS`(cd, cap_val)` writes capability, `cap_val` capability register `cd`. Writes to register zero are ignored.
\<close>\<close>
\<comment> \<open>\<open>val writeCapReg : mword ty5 -> Capability -> M unit\<close>\<close>

definition writeCapReg  :: \<open>(5)Word.word \<Rightarrow> Capability \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> writeCapReg n cap = (
   if (((n = ( 0b00000 ::  5 Word.word)))) then return () 
   else
     (let i = (Word.uint n) in
     skip ()  \<then> write_reg ((access_list_dec CapRegs i)) cap))\<close> 
  for  n  :: "(5)Word.word " 
  and  cap  :: " Capability "


\<comment> \<open>\<open>val CapEx_of_num : integer -> CapEx\<close>\<close>

definition CapEx_of_num  :: \<open> int \<Rightarrow> CapEx \<close>  where 
     \<open> CapEx_of_num arg1 = (
   (let l__84 = arg1 in
   if (((l__84 = (( 0 :: int)::ii)))) then CapEx_None
   else if (((l__84 = (( 1 :: int)::ii)))) then CapEx_LengthViolation
   else if (((l__84 = (( 2 :: int)::ii)))) then CapEx_TagViolation
   else if (((l__84 = (( 3 :: int)::ii)))) then CapEx_SealViolation
   else if (((l__84 = (( 4 :: int)::ii)))) then CapEx_TypeViolation
   else if (((l__84 = (( 5 :: int)::ii)))) then CapEx_CallTrap
   else if (((l__84 = (( 6 :: int)::ii)))) then CapEx_ReturnTrap
   else if (((l__84 = (( 7 :: int)::ii)))) then CapEx_TSSUnderFlow
   else if (((l__84 = (( 8 :: int)::ii)))) then CapEx_UserDefViolation
   else if (((l__84 = (( 9 :: int)::ii)))) then CapEx_TLBNoStoreCap
   else if (((l__84 = (( 10 :: int)::ii)))) then CapEx_InexactBounds
   else if (((l__84 = (( 11 :: int)::ii)))) then CapEx_GlobalViolation
   else if (((l__84 = (( 12 :: int)::ii)))) then CapEx_PermitExecuteViolation
   else if (((l__84 = (( 13 :: int)::ii)))) then CapEx_PermitLoadViolation
   else if (((l__84 = (( 14 :: int)::ii)))) then CapEx_PermitStoreViolation
   else if (((l__84 = (( 15 :: int)::ii)))) then CapEx_PermitLoadCapViolation
   else if (((l__84 = (( 16 :: int)::ii)))) then CapEx_PermitStoreCapViolation
   else if (((l__84 = (( 17 :: int)::ii)))) then CapEx_PermitStoreLocalCapViolation
   else if (((l__84 = (( 18 :: int)::ii)))) then CapEx_PermitSealViolation
   else if (((l__84 = (( 19 :: int)::ii)))) then CapEx_AccessSystemRegsViolation
   else if (((l__84 = (( 20 :: int)::ii)))) then CapEx_PermitCCallViolation
   else if (((l__84 = (( 21 :: int)::ii)))) then CapEx_AccessCCallIDCViolation
   else if (((l__84 = (( 22 :: int)::ii)))) then CapEx_PermitUnsealViolation
   else if (((l__84 = (( 23 :: int)::ii)))) then CapEx_PermitSetCIDViolation
   else CapEx_TLBLoadCap))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_CapEx : CapEx -> integer\<close>\<close>

fun num_of_CapEx  :: \<open> CapEx \<Rightarrow> int \<close>  where 
     \<open> num_of_CapEx CapEx_None = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_LengthViolation = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_TagViolation = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_SealViolation = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_TypeViolation = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_CallTrap = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_ReturnTrap = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_TSSUnderFlow = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_UserDefViolation = ( (( 8 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_TLBNoStoreCap = ( (( 9 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_InexactBounds = ( (( 10 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_GlobalViolation = ( (( 11 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitExecuteViolation = ( (( 12 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitLoadViolation = ( (( 13 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitStoreViolation = ( (( 14 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitLoadCapViolation = ( (( 15 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitStoreCapViolation = ( (( 16 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitStoreLocalCapViolation = ( (( 17 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitSealViolation = ( (( 18 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_AccessSystemRegsViolation = ( (( 19 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitCCallViolation = ( (( 20 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_AccessCCallIDCViolation = ( (( 21 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitUnsealViolation = ( (( 22 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_PermitSetCIDViolation = ( (( 23 :: int)::ii))\<close>
|\<open> num_of_CapEx CapEx_TLBLoadCap = ( (( 24 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_CapEx : unit -> M CapEx\<close>\<close>

definition undefined_CapEx  :: \<open> unit \<Rightarrow>((register_value),(CapEx),(exception))monad \<close>  where 
     \<open> undefined_CapEx _ = (
   internal_pick
     [CapEx_None,CapEx_LengthViolation,CapEx_TagViolation,CapEx_SealViolation,CapEx_TypeViolation,CapEx_CallTrap,CapEx_ReturnTrap,CapEx_TSSUnderFlow,CapEx_UserDefViolation,CapEx_TLBNoStoreCap,CapEx_InexactBounds,CapEx_GlobalViolation,CapEx_PermitExecuteViolation,CapEx_PermitLoadViolation,CapEx_PermitStoreViolation,CapEx_PermitLoadCapViolation,CapEx_PermitStoreCapViolation,CapEx_PermitStoreLocalCapViolation,CapEx_PermitSealViolation,CapEx_AccessSystemRegsViolation,CapEx_PermitCCallViolation,CapEx_AccessCCallIDCViolation,CapEx_PermitUnsealViolation,CapEx_PermitSetCIDViolation,CapEx_TLBLoadCap])\<close>


\<comment> \<open>\<open>val string_of_capex : CapEx -> string\<close>\<close>

fun string_of_capex  :: \<open> CapEx \<Rightarrow> string \<close>  where 
     \<open> string_of_capex CapEx_None = ( (''None''))\<close>
|\<open> string_of_capex CapEx_LengthViolation = ( (''LengthViolation''))\<close>
|\<open> string_of_capex CapEx_TagViolation = ( (''TagViolation''))\<close>
|\<open> string_of_capex CapEx_SealViolation = ( (''SealViolation''))\<close>
|\<open> string_of_capex CapEx_TypeViolation = ( (''TypeViolation''))\<close>
|\<open> string_of_capex CapEx_CallTrap = ( (''CallTrap''))\<close>
|\<open> string_of_capex CapEx_ReturnTrap = ( (''ReturnTrap''))\<close>
|\<open> string_of_capex CapEx_TSSUnderFlow = ( (''TSSUnderFlow''))\<close>
|\<open> string_of_capex CapEx_UserDefViolation = ( (''UserDefViolation''))\<close>
|\<open> string_of_capex CapEx_TLBNoStoreCap = ( (''TLBNoStoreCap''))\<close>
|\<open> string_of_capex CapEx_InexactBounds = ( (''InexactBounds''))\<close>
|\<open> string_of_capex CapEx_GlobalViolation = ( (''GlobalViolation''))\<close>
|\<open> string_of_capex CapEx_PermitExecuteViolation = ( (''PermitExecuteViolation''))\<close>
|\<open> string_of_capex CapEx_PermitLoadViolation = ( (''PermitLoadViolation''))\<close>
|\<open> string_of_capex CapEx_PermitStoreViolation = ( (''PermitStoreViolation''))\<close>
|\<open> string_of_capex CapEx_PermitLoadCapViolation = ( (''PermitLoadCapViolation''))\<close>
|\<open> string_of_capex CapEx_PermitStoreCapViolation = ( (''PermitStoreCapViolation''))\<close>
|\<open> string_of_capex CapEx_PermitStoreLocalCapViolation = ( (''PermitStoreLocalCapViolation''))\<close>
|\<open> string_of_capex CapEx_PermitSealViolation = ( (''PermitSealViolation''))\<close>
|\<open> string_of_capex CapEx_AccessSystemRegsViolation = ( (''AccessSystemRegsViolation''))\<close>
|\<open> string_of_capex CapEx_PermitCCallViolation = ( (''PermitCCallViolation''))\<close>
|\<open> string_of_capex CapEx_AccessCCallIDCViolation = ( (''AccessCCallIDCViolation''))\<close>
|\<open> string_of_capex CapEx_PermitUnsealViolation = ( (''PermitUnsealViolation''))\<close>
|\<open> string_of_capex CapEx_PermitSetCIDViolation = ( (''PermitSetCIDViolation''))\<close>
|\<open> string_of_capex CapEx_TLBLoadCap = ( (''TLBLoadCap''))\<close>


\<comment> \<open>\<open>val Mk_CapCauseReg : mword ty16 -> CapCauseReg\<close>\<close>

definition Mk_CapCauseReg  :: \<open>(16)Word.word \<Rightarrow> CapCauseReg \<close>  where 
     \<open> Mk_CapCauseReg v = ( (| CapCauseReg_bits = v |) )\<close> 
  for  v  :: "(16)Word.word "


definition get_CapCauseReg_bits  :: \<open> CapCauseReg \<Rightarrow>(16)Word.word \<close>  where 
     \<open> get_CapCauseReg_bits v = ( (subrange_vec_dec(CapCauseReg_bits   v) (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))\<close> 
  for  v  :: " CapCauseReg "


definition set_CapCauseReg_bits  :: \<open>((regstate),(register_value),(CapCauseReg))register_ref \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CapCauseReg_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       CapCauseReg_bits :=
         ((update_subrange_vec_dec(CapCauseReg_bits   r) (( 15 :: int)::ii) (( 0 :: int)::ii) v  ::  16 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(CapCauseReg))register_ref " 
  and  v  :: "(16)Word.word "


definition update_CapCauseReg_bits  :: \<open> CapCauseReg \<Rightarrow>(16)Word.word \<Rightarrow> CapCauseReg \<close>  where 
     \<open> update_CapCauseReg_bits v x = (
   ( v (|
     CapCauseReg_bits :=
       ((update_subrange_vec_dec(CapCauseReg_bits   v) (( 15 :: int)::ii) (( 0 :: int)::ii) x  ::  16 Word.word)) |)))\<close> 
  for  v  :: " CapCauseReg " 
  and  x  :: "(16)Word.word "


definition get_CapCauseReg_ExcCode  :: \<open> CapCauseReg \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_CapCauseReg_ExcCode v = ( (subrange_vec_dec(CapCauseReg_bits   v) (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " CapCauseReg "


definition update_CapCauseReg_ExcCode  :: \<open> CapCauseReg \<Rightarrow>(8)Word.word \<Rightarrow> CapCauseReg \<close>  where 
     \<open> update_CapCauseReg_ExcCode v x = (
   ( v (|
     CapCauseReg_bits :=
       ((update_subrange_vec_dec(CapCauseReg_bits   v) (( 15 :: int)::ii) (( 8 :: int)::ii) x  ::  16 Word.word)) |)))\<close> 
  for  v  :: " CapCauseReg " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_CapCauseReg_RegNum : CapCauseReg -> mword ty8\<close>\<close>

definition get_CapCauseReg_RegNum  :: \<open> CapCauseReg \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_CapCauseReg_RegNum v = ( (subrange_vec_dec(CapCauseReg_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " CapCauseReg "


\<comment> \<open>\<open>val _update_CapCauseReg_RegNum : CapCauseReg -> mword ty8 -> CapCauseReg\<close>\<close>

definition update_CapCauseReg_RegNum  :: \<open> CapCauseReg \<Rightarrow>(8)Word.word \<Rightarrow> CapCauseReg \<close>  where 
     \<open> update_CapCauseReg_RegNum v x = (
   ( v (|
     CapCauseReg_bits := ((update_subrange_vec_dec(CapCauseReg_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii) x  ::  16 Word.word)) |)))\<close> 
  for  v  :: " CapCauseReg " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>
THIS executes a branch to the given capability, replacing PCC and taking the new PC from the offset field. Note that on MIPS the new PCC does not take effect until after the branch delay slot.
\<close>\<close>
\<comment> \<open>\<open>val execute_branch_pcc : Capability -> M unit\<close>\<close>

definition execute_branch_pcc  :: \<open> Capability \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_branch_pcc newPCC = (
   ((write_reg DelayedPC_ref ((to_bits (( 64 :: int)::ii) ((getCapOffset newPCC))  ::  64 Word.word)) \<then>
   write_reg DelayedPCC_ref newPCC) \<then>
   write_reg BranchPending_ref ( 0b1 ::  1 Word.word)) \<then>
   write_reg NextInBranchDelay_ref ( 0b1 ::  1 Word.word))\<close> 
  for  newPCC  :: " Capability "


\<comment> \<open>\<open>
causes the processor to raise a capability exception by writing the given capability exception cause and register number to the CapCause register then signalling an exception using [SignalException] (on CHERI-MIPS this is a C2E exception in most cases, or a special C2Trap for CCall and CReturn).\<close>\<close>
\<comment> \<open>\<open>val raise_c2_exception : forall 'o. CapEx -> mword ty5 -> M 'o\<close>\<close>

definition raise_c2_exception  :: \<open> CapEx \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),'o,(exception))monad \<close>  where 
     \<open> raise_c2_exception capEx regnum = (
   (let reg8 = ((concat_vec ( 0b000 ::  3 Word.word) regnum  ::  8 Word.word)) in
   raise_c2_exception8 capEx reg8))\<close> 
  for  capEx  :: " CapEx " 
  and  regnum  :: "(5)Word.word "


\<comment> \<open>\<open>val raise_c2_exception_badaddr : forall 'o. CapEx -> mword ty5 -> mword ty64 -> M 'o\<close>\<close>

definition raise_c2_exception_badaddr  :: \<open> CapEx \<Rightarrow>(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),'o,(exception))monad \<close>  where 
     \<open> raise_c2_exception_badaddr capEx regnum badAddr = (
   write_reg CP0BadVAddr_ref badAddr \<then> raise_c2_exception capEx regnum )\<close> 
  for  capEx  :: " CapEx " 
  and  regnum  :: "(5)Word.word " 
  and  badAddr  :: "(64)Word.word "


definition cap_addr_mask  :: \<open>(64)Word.word \<close>  where 
     \<open> cap_addr_mask = ( (to_bits (( 64 :: int)::ii) ((((pow2 (( 64 :: int)::ii))) - cap_size))  ::  64 Word.word))\<close>










\<comment> \<open>\<open>
THIS`(addr, size, value)` writes `size` bytes of `value` to physical address `addr`.
\<close>\<close>
\<comment> \<open>\<open>val MEMw_wrapper : forall 'p8_times_n. Size 'p8_times_n => mword ty64 -> integer -> mword 'p8_times_n -> M unit\<close>\<close>

definition MEMw_wrapper  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('p8_times_n::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> MEMw_wrapper addr size1 data = (
   if (((addr = ( 0x000000007F000000 ::  64 Word.word)))) then
     (let ledata = ((reverse_endianness data  :: ( 'p8_times_n::len)Word.word)) in
     write_reg UART_WDATA_ref ((subrange_vec_dec ledata (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) \<then>
     write_reg UART_WRITTEN_ref ( 0b1 ::  1 Word.word))
   else
     assert_exp (((((and_vec addr cap_addr_mask  ::  64 Word.word)) = ((and_vec
                        ((add_vec addr
                            ((to_bits (( 64 :: int)::ii) ((size1 - (( 1 :: int)::ii)))  ::  64 Word.word))
                           ::  64 Word.word)) cap_addr_mask
                       ::  64 Word.word))))) (''cheri_prelude_common.sail 460:85 - 460:86'') \<then>
     MEMw_tagged addr size1 False data )\<close> 
  for  addr  :: "(64)Word.word " 
  and  size1  :: " int " 
  and  data  :: "('p8_times_n::len)Word.word "


\<comment> \<open>\<open>
THIS`(addr, size, value)` attempts to write `size` bytes of `value` to physical address `addr` and returns a boolean indicating store conditional success or failure.
\<close>\<close>
\<comment> \<open>\<open>val MEMw_conditional_wrapper : forall 'p8_times_n. Size 'p8_times_n => mword ty64 -> integer -> mword 'p8_times_n -> M bool\<close>\<close>

definition MEMw_conditional_wrapper  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('p8_times_n::len)Word.word \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> MEMw_conditional_wrapper addr size1 data = (
   assert_exp (((((and_vec addr cap_addr_mask  ::  64 Word.word)) = ((and_vec
                      ((add_vec addr ((to_bits (( 64 :: int)::ii) ((size1 - (( 1 :: int)::ii)))  ::  64 Word.word))
                         ::  64 Word.word)) cap_addr_mask
                     ::  64 Word.word))))) (''cheri_prelude_common.sail 472:85 - 472:86'') \<then>
   MEMw_tagged_conditional addr size1 False data )\<close> 
  for  addr  :: "(64)Word.word " 
  and  size1  :: " int " 
  and  data  :: "('p8_times_n::len)Word.word "


\<comment> \<open>\<open>val checkDDCPerms : Capability -> MemAccessType -> M unit\<close>\<close>

definition checkDDCPerms  :: \<open> Capability \<Rightarrow> MemAccessType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> checkDDCPerms (ddc :: Capability) (accessType :: MemAccessType) = (
   (if ((\<not>(Capability_tag   ddc))) then raise_c2_exception CapEx_TagViolation ( 0b00000 ::  5 Word.word)
    else if(Capability_sealed   ddc) then raise_c2_exception CapEx_SealViolation ( 0b00000 ::  5 Word.word)
    else return () ) \<then>
   (case  accessType of
     Instruction => assert_exp False (''cheri_prelude_common.sail 485:34 - 485:35'') \<then> exit0 () 
   | LoadData =>
      if ((\<not>(Capability_permit_load   ddc))) then
        raise_c2_exception CapEx_PermitLoadViolation ( 0b00000 ::  5 Word.word)
      else return () 
   | StoreData =>
      if ((\<not>(Capability_permit_store   ddc))) then
        raise_c2_exception CapEx_PermitStoreViolation ( 0b00000 ::  5 Word.word)
      else return () 
   ))\<close> 
  for  ddc  :: " Capability " 
  and  accessType  :: " MemAccessType "


\<comment> \<open>\<open>val addrWrapper : mword ty64 -> MemAccessType -> WordType -> M (mword ty64)\<close>\<close>

definition addrWrapper  :: \<open>(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow> WordType \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> addrWrapper addr accessType width = (
   read_reg DDC_ref \<bind> ((\<lambda> ddc . 
   checkDDCPerms ddc accessType \<then>
   ((let cursor = (getCapCursor ddc) in
   (let vAddr = (((cursor + ((Word.uint addr)))) mod ((pow2 (( 64 :: int)::ii)))) in
   (let size1 = (wordWidthBytes width) in
   (let (base, top1) = (getCapBounds ddc) in
   if ((((vAddr + size1)) > top1)) then
     (raise_c2_exception CapEx_LengthViolation ( 0b00000 ::  5 Word.word)  :: ( 64 Word.word) M)
   else if ((vAddr < base)) then
     (raise_c2_exception CapEx_LengthViolation ( 0b00000 ::  5 Word.word)  :: ( 64 Word.word) M)
   else return ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word))))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  accessType  :: " MemAccessType " 
  and  width  :: " WordType "


\<comment> \<open>\<open>val addrWrapperUnaligned : mword ty64 -> MemAccessType -> WordTypeUnaligned -> M (mword ty64 * ii)\<close>\<close>

definition addrWrapperUnaligned  :: \<open>(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow> WordTypeUnaligned \<Rightarrow>((register_value),((64)Word.word*ii),(exception))monad \<close>  where 
     \<open> addrWrapperUnaligned addr accessType width = (
   read_reg DDC_ref \<bind> ((\<lambda> ddc . 
   checkDDCPerms ddc accessType \<then>
   ((let cursor = (getCapCursor ddc) in
   (let vAddr = (((cursor + ((Word.uint addr)))) mod ((pow2 (( 64 :: int)::ii)))) in
   (let (waddr, size1) = (unalignedBytesTouched vAddr width) in
   (let (base, top1) = (getCapBounds ddc) in
   if ((((waddr + size1)) > top1)) then
     (raise_c2_exception CapEx_LengthViolation ( 0b00000 ::  5 Word.word)  :: (( 64 Word.word * ii)) M)
   else if ((waddr < base)) then
     (raise_c2_exception CapEx_LengthViolation ( 0b00000 ::  5 Word.word)  :: (( 64 Word.word * ii)) M)
   else return ((to_bits (( 64 :: int)::ii) waddr  ::  64 Word.word), size1)))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  accessType  :: " MemAccessType " 
  and  width  :: " WordTypeUnaligned "


definition execute_branch  :: \<open>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_branch pc = (
   read_reg PCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   getCapLength w__0 \<bind> ((\<lambda> len . 
   (if ((((((Word.uint pc)) + (( 4 :: int)::ii))) > len)) then
      raise_c2_exception_noreg CapEx_LengthViolation
    else return () ) \<then>
   execute_branch_mips pc)))))\<close> 
  for  pc  :: "(64)Word.word "


\<comment> \<open>\<open>val TranslatePC : mword ty64 -> M (mword ty64)\<close>\<close>

definition TranslatePC  :: \<open>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> TranslatePC vAddr = (
   (incrementCP0Count ()  \<then>
   read_reg PCC_ref) \<bind> ((\<lambda> pcc . 
   (let (base, top1) = (getCapBounds pcc) in
   (let absPC = (base + ((Word.uint vAddr))) in
   if (((((absPC mod (( 4 :: int)::ii))) \<noteq> (( 0 :: int)::ii)))) then
     (SignalExceptionBadAddr AdEL ((to_bits (( 64 :: int)::ii) absPC  ::  64 Word.word))  :: ( 64 Word.word) M)
   else if ((\<not>(Capability_tag   pcc))) then
     (raise_c2_exception_noreg CapEx_TagViolation  :: ( 64 Word.word) M)
   else if(Capability_sealed   pcc) then
     (raise_c2_exception_noreg CapEx_SealViolation  :: ( 64 Word.word) M)
   else if ((\<not>(Capability_permit_execute   pcc))) then
     (raise_c2_exception_noreg CapEx_PermitExecuteViolation  :: ( 64 Word.word) M)
   else if ((((absPC + (( 4 :: int)::ii))) > top1)) then
     (raise_c2_exception_noreg CapEx_LengthViolation  :: ( 64 Word.word) M)
   else (TLBTranslate ((to_bits (( 64 :: int)::ii) absPC  ::  64 Word.word)) Instruction  :: ( 64 Word.word) M))))))\<close> 
  for  vAddr  :: "(64)Word.word "


\<comment> \<open>\<open>
THIS raises a co-processor unusable exception if `CP0Status.CU[2]`
is not set. All capability instructions must first check that the
capability co-processor is enabled. This allows the operating system
to only save and restore the full capability context for processes
that use capabilities.
\<close>\<close>
\<comment> \<open>\<open>val checkCP2usable : unit -> M unit\<close>\<close>

definition checkCP2usable  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> checkCP2usable _ = (
   read_reg CP0Status_ref \<bind> ((\<lambda> (w__0 :: StatusReg) . 
   if ((\<not> ((bit_to_bool ((access_vec_dec ((get_StatusReg_CU w__0  ::  4 Word.word)) (( 2 :: int)::ii))))))) then
     set_CauseReg_CE CP0Cause_ref ( 0b10 ::  2 Word.word) \<then> SignalException CpU
   else return () )))\<close>


definition init_cp2_state  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_cp2_state _ = (
   (((((((((((write_reg PCC_ref default_cap \<then>
   write_reg NextPCC_ref default_cap) \<then>
   write_reg DelayedPCC_ref default_cap) \<then>
   write_reg DDC_ref default_cap) \<then>
   write_reg KCC_ref default_cap) \<then>
   write_reg EPCC_ref default_cap) \<then>
   write_reg ErrorEPCC_ref default_cap) \<then>
   write_reg KDC_ref null_cap) \<then>
   write_reg KR1C_ref null_cap) \<then>
   write_reg KR2C_ref null_cap) \<then>
   write_reg CPLR_ref null_cap) \<then>
   write_reg CULR_ref null_cap) \<then>
   ((let loop_i_lower = ((( 1 :: int)::ii)) in
   (let loop_i_upper = ((( 31 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) () 
     ((\<lambda> i unit_var . 
       (let idx = ((to_bits (( 5 :: int)::ii) i  ::  5 Word.word)) in
       writeCapReg idx null_cap))))))))\<close>


definition cp2_next_pc  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> cp2_next_pc _ = (
   read_reg NextPCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   (write_reg PCC_ref w__0 \<then>
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  1 Word.word) . 
   if ((bits_to_bool w__1)) then
     read_reg DelayedPCC_ref \<bind> ((\<lambda> (w__2 :: Capability) .  write_reg NextPCC_ref w__2))
   else return () )))))\<close>


definition get_CP0EPC  :: \<open> unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> get_CP0EPC _ = (
   read_reg EPCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   return ((to_bits (( 64 :: int)::ii) ((getCapOffset w__0))  ::  64 Word.word)))))\<close>


definition set_CP0EPC  :: \<open>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CP0EPC newEPC = (
   read_reg EPCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   (let (representable, newEPCC) = (setCapOffset w__0 newEPC) in
   write_reg
     EPCC_ref
     (if representable then
        ( newEPCC (|
          Capability_tag := ((((Capability_tag   newEPCC) \<and> ((\<not>(Capability_sealed   newEPCC)))))) |))
      else unrepCap newEPCC)))))\<close> 
  for  newEPC  :: "(64)Word.word "


definition get_CP0ErrorEPC  :: \<open> unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> get_CP0ErrorEPC _ = (
   read_reg ErrorEPCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   return ((to_bits (( 64 :: int)::ii) ((getCapOffset w__0))  ::  64 Word.word)))))\<close>


definition set_CP0ErrorEPC  :: \<open>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_CP0ErrorEPC v = (
   read_reg ErrorEPCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   (let (representable, newErrorEPCC) = (setCapOffset w__0 v) in
   write_reg
     ErrorEPCC_ref
     (if representable then
        ( newErrorEPCC (|
          Capability_tag :=
            ((((Capability_tag   newErrorEPCC) \<and> ((\<not>(Capability_sealed   newErrorEPCC)))))) |))
      else unrepCap newErrorEPCC)))))\<close> 
  for  v  :: "(64)Word.word "


\<comment> \<open>\<open>Tests whether the capability has a reserved otype (larger than max_otype).
    Note that this includes both sealed (e.g. sentry) and unsealed (e.g. all ones)
    otypes.\<close>\<close>
\<comment> \<open>\<open>val hasReservedOType : Capability -> bool\<close>\<close>

definition hasReservedOType  :: \<open> Capability \<Rightarrow> bool \<close>  where 
     \<open> hasReservedOType cap = ( ((Word.uint(Capability_otype   cap))) > max_otype )\<close> 
  for  cap  :: " Capability "


definition capToString  :: \<open> Capability \<Rightarrow> bool \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> capToString cap fixlen = (
   (skip ()  \<then>
   getCapLength cap) \<bind> ((\<lambda> len . 
   (let len_str =
     (if fixlen then string_of_bits ((to_bits (( 64 :: int)::ii) ((min len ((MAX0 (( 64 :: int)::ii)))))  ::  64 Word.word))
     else string_of_bits ((to_bits (( 68 :: int)::ii) len  ::  68 Word.word))) in
   (let (otype64 :: 64 bits) =
     (if ((hasReservedOType cap)) then (mips_sign_extend (( 64 :: int)::ii)(Capability_otype   cap)  ::  64 Word.word)
     else (mips_zero_extend (( 64 :: int)::ii)(Capability_otype   cap)  ::  64 Word.word)) in
   return (((@) ('' t:'')
              (((@) (if(Capability_tag   cap) then (''1'') else (''0''))
                  (((@) ('' s:'')
                      (((@) (if(Capability_sealed   cap) then (''1'') else (''0''))
                          (((@) ('' perms:'')
                              (((@)
                                  ((string_of_bits
                                      ((concat_vec ( 0b0 ::  1 Word.word)
                                          ((getCapPerms cap  ::  31 Word.word))
                                         ::  32 Word.word))))
                                  (((@) ('' type:'')
                                      (((@) ((string_of_bits otype64))
                                          (((@) ('' offset:'')
                                              (((@)
                                                  ((string_of_bits
                                                      ((to_bits (( 64 :: int)::ii) ((getCapOffset cap))
                                                         ::  64 Word.word))))
                                                  (((@) ('' base:'')
                                                      (((@)
                                                          ((string_of_bits
                                                              ((to_bits (( 64 :: int)::ii) ((getCapBase cap))
                                                                 ::  64 Word.word))))
                                                          (((@) ('' length:'') len_str)))))))))))))))))))))))))))))))\<close> 
  for  cap  :: " Capability " 
  and  fixlen  :: " bool "


definition dump_cp2_state  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> dump_cp2_state _ = (
   read_reg PCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   capToString w__0 True \<bind> ((\<lambda> (w__1 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP PCC'') w__1))) in
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 31 :: int)::ii)) in
   ((foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) () 
     ((\<lambda> i unit_var . 
       readCapReg ((to_bits (( 5 :: int)::ii) i  ::  5 Word.word)) \<bind> ((\<lambda> (w__2 :: Capability) . 
       capToString w__2 True \<bind> ((\<lambda> (w__3 :: string) . 
       return ((let (_ :: unit) =
         (print_endline (((@) (''DEBUG CAP REG '') (((@) ((string_of_int 
  instance_Show_Show_Num_integer_dict i)) w__3))))) in
       () ))))))))) \<then>
   read_reg DDC_ref) \<bind> ((\<lambda> (w__4 :: Capability) . 
   capToString w__4 True \<bind> ((\<lambda> (w__5 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 00'') w__5))) in
   read_reg CULR_ref \<bind> ((\<lambda> (w__6 :: Capability) . 
   capToString w__6 True \<bind> ((\<lambda> (w__7 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 01'') w__7))) in
   read_reg CPLR_ref \<bind> ((\<lambda> (w__8 :: Capability) . 
   capToString w__8 True \<bind> ((\<lambda> (w__9 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 08'') w__9))) in
   read_reg KR1C_ref \<bind> ((\<lambda> (w__10 :: Capability) . 
   capToString w__10 True \<bind> ((\<lambda> (w__11 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 22'') w__11))) in
   read_reg KR2C_ref \<bind> ((\<lambda> (w__12 :: Capability) . 
   capToString w__12 True \<bind> ((\<lambda> (w__13 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 23'') w__13))) in
   read_reg ErrorEPCC_ref \<bind> ((\<lambda> (w__14 :: Capability) . 
   capToString w__14 True \<bind> ((\<lambda> (w__15 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 28'') w__15))) in
   read_reg KCC_ref \<bind> ((\<lambda> (w__16 :: Capability) . 
   capToString w__16 True \<bind> ((\<lambda> (w__17 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 29'') w__17))) in
   read_reg KDC_ref \<bind> ((\<lambda> (w__18 :: Capability) . 
   capToString w__18 True \<bind> ((\<lambda> (w__19 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 30'') w__19))) in
   read_reg EPCC_ref \<bind> ((\<lambda> (w__20 :: Capability) . 
   capToString w__20 True \<bind> ((\<lambda> (w__21 :: string) . 
   return ((print_endline (((@) (''DEBUG CAP HWREG 31'') w__21))))))))))))))))))))))))))))))))))))))))))))))))))))))))\<close>


\<comment> \<open>\<open>
Gets the architecture specific capability flags for given capability.
\<close>\<close>
\<comment> \<open>\<open>val getCapFlags : Capability -> mword ty1\<close>\<close>

definition getCapFlags  :: \<open> Capability \<Rightarrow>(1)Word.word \<close>  where 
     \<open> getCapFlags cap = ( ( 0b0 ::  1 Word.word))\<close> 
  for  cap  :: " Capability "


\<comment> \<open>\<open>
THIS`(cap, flags)` sets the architecture specific capability flags on `cap` to `flags` and returns the result as new capability.
\<close>\<close>
\<comment> \<open>\<open>val setCapFlags : Capability -> mword ty1 -> Capability\<close>\<close>

definition setCapFlags  :: \<open> Capability \<Rightarrow>(1)Word.word \<Rightarrow> Capability \<close>  where 
     \<open> setCapFlags cap flags = ( cap )\<close> 
  for  cap  :: " Capability " 
  and  flags  :: "(1)Word.word "


\<comment> \<open>\<open>Returns true if the given capability is a sealed entry capability.\<close>\<close>
\<comment> \<open>\<open>val isSentryCap : Capability -> bool\<close>\<close>

definition isSentryCap  :: \<open> Capability \<Rightarrow> bool \<close>  where 
     \<open> isSentryCap cap = ( (((Word.sint(Capability_otype   cap))) = otype_sentry))\<close> 
  for  cap  :: " Capability "


\<comment> \<open>\<open>val ERETHook : unit -> M unit\<close>\<close>

definition ERETHook  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> ERETHook _ = (
   read_reg CP0Status_ref \<bind> ((\<lambda> (w__0 :: StatusReg) . 
   (if (((((bits_to_bool ((get_StatusReg_ERL w__0  ::  1 Word.word)))) = ((bit_to_bool B1))))) then
      read_reg ErrorEPCC_ref
    else read_reg EPCC_ref) \<bind> ((\<lambda> epcc_val . 
   (let new_pcc = (if ((isSentryCap epcc_val)) then unsealCap epcc_val else epcc_val) in
   set_next_pcc new_pcc))))))\<close>


\<comment> \<open>\<open>val execute : ast -> M unit\<close>\<close>

\<comment> \<open>\<open>val decode : mword ty32 -> maybe ast\<close>\<close>

\<comment> \<open>\<open>val assembly : ast -> string\<close>\<close>

\<comment> \<open>\<open>val TLBWriteEntry : mword ty6 -> M unit\<close>\<close>

definition TLBWriteEntry  :: \<open>(6)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> TLBWriteEntry idx = (
   (read_reg TLBPageMask_ref  :: ( 16 Word.word) M) \<bind> ((\<lambda> pagemask . 
   (let b__0 = pagemask in
   (if (((b__0 = ( 0x0000 ::  16 Word.word)))) then return () 
    else if (((b__0 = ( 0x0003 ::  16 Word.word)))) then return () 
    else if (((b__0 = ( 0x000F ::  16 Word.word)))) then return () 
    else if (((b__0 = ( 0x003F ::  16 Word.word)))) then return () 
    else if (((b__0 = ( 0x00FF ::  16 Word.word)))) then return () 
    else if (((b__0 = ( 0x03FF ::  16 Word.word)))) then return () 
    else if (((b__0 = ( 0x0FFF ::  16 Word.word)))) then return () 
    else if (((b__0 = ( 0x3FFF ::  16 Word.word)))) then return () 
    else if (((b__0 = ( 0xFFFF ::  16 Word.word)))) then return () 
    else SignalException MCheck) \<then>
   ((let i = (Word.uint idx) in
   (let entry = (access_list_dec TLBEntries i) in
   (set_TLBEntry_pagemask entry pagemask \<then>
   read_reg TLBEntryHi_ref) \<bind> ((\<lambda> (w__0 :: TLBEntryHiReg) . 
   (set_TLBEntry_r entry ((get_TLBEntryHiReg_R w__0  ::  2 Word.word)) \<then>
   read_reg TLBEntryHi_ref) \<bind> ((\<lambda> (w__1 :: TLBEntryHiReg) . 
   (set_TLBEntry_vpn2 entry ((get_TLBEntryHiReg_VPN2 w__1  ::  27 Word.word)) \<then>
   read_reg TLBEntryHi_ref) \<bind> ((\<lambda> (w__2 :: TLBEntryHiReg) . 
   (set_TLBEntry_asid entry ((get_TLBEntryHiReg_ASID w__2  ::  8 Word.word)) \<then>
   and_boolM
     (read_reg TLBEntryLo0_ref \<bind> ((\<lambda> (w__3 :: TLBEntryLoReg) . 
      return ((bits_to_bool ((get_TLBEntryLoReg_G w__3  ::  1 Word.word)))))))
     (read_reg TLBEntryLo1_ref \<bind> ((\<lambda> (w__4 :: TLBEntryLoReg) . 
      return ((bits_to_bool ((get_TLBEntryLoReg_G w__4  ::  1 Word.word)))))))) \<bind> ((\<lambda> (w__5 :: bool) . 
   ((set_TLBEntry_g entry ((bool_to_bits w__5  ::  1 Word.word)) \<then>
   set_TLBEntry_valid entry ((cast_unit_vec0 B1  ::  1 Word.word))) \<then>
   read_reg TLBEntryLo0_ref) \<bind> ((\<lambda> (w__6 :: TLBEntryLoReg) . 
   (set_TLBEntry_caps0 entry ((get_TLBEntryLoReg_CapS w__6  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> ((\<lambda> (w__7 :: TLBEntryLoReg) . 
   (set_TLBEntry_capl0 entry ((get_TLBEntryLoReg_CapL w__7  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> ((\<lambda> (w__8 :: TLBEntryLoReg) . 
   (set_TLBEntry_caplg0 entry ((get_TLBEntryLoReg_CapLG w__8  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> ((\<lambda> (w__9 :: TLBEntryLoReg) . 
   (set_TLBEntry_pfn0 entry ((get_TLBEntryLoReg_PFN w__9  ::  24 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> ((\<lambda> (w__10 :: TLBEntryLoReg) . 
   (set_TLBEntry_c0 entry ((get_TLBEntryLoReg_C w__10  ::  3 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> ((\<lambda> (w__11 :: TLBEntryLoReg) . 
   (set_TLBEntry_d0 entry ((get_TLBEntryLoReg_D w__11  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> ((\<lambda> (w__12 :: TLBEntryLoReg) . 
   (set_TLBEntry_v0 entry ((get_TLBEntryLoReg_V w__12  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> ((\<lambda> (w__13 :: TLBEntryLoReg) . 
   (set_TLBEntry_caps1 entry ((get_TLBEntryLoReg_CapS w__13  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> ((\<lambda> (w__14 :: TLBEntryLoReg) . 
   (set_TLBEntry_capl1 entry ((get_TLBEntryLoReg_CapL w__14  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> ((\<lambda> (w__15 :: TLBEntryLoReg) . 
   (set_TLBEntry_caplg1 entry ((get_TLBEntryLoReg_CapLG w__15  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> ((\<lambda> (w__16 :: TLBEntryLoReg) . 
   (set_TLBEntry_pfn1 entry ((get_TLBEntryLoReg_PFN w__16  ::  24 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> ((\<lambda> (w__17 :: TLBEntryLoReg) . 
   (set_TLBEntry_c1 entry ((get_TLBEntryLoReg_C w__17  ::  3 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> ((\<lambda> (w__18 :: TLBEntryLoReg) . 
   (set_TLBEntry_d1 entry ((get_TLBEntryLoReg_D w__18  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> ((\<lambda> (w__19 :: TLBEntryLoReg) . 
   set_TLBEntry_v1 entry ((get_TLBEntryLoReg_V w__19  ::  1 Word.word)))))))))))))))))))))))))))))))))))))))))))))\<close> 
  for  idx  :: "(6)Word.word "


\<comment> \<open>\<open>val strCReg : mword ty5 -> string\<close>\<close>

definition strCReg  :: \<open>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strCReg r = ( concat_str_dec (''$c'') ((Word.uint r)))\<close> 
  for  r  :: "(5)Word.word "


\<comment> \<open>\<open>val strRRArgs : mword ty5 -> mword ty5 -> string\<close>\<close>

definition strRRArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strRRArgs (rd :: IntRegEnc) (r1 :: IntRegEnc) = (
   (@) ((strReg rd)) (((@) ('', '') ((strReg r1)))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  r1  :: "(5)Word.word "


\<comment> \<open>\<open>val strRCArgs : mword ty5 -> mword ty5 -> string\<close>\<close>

definition strRCArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strRCArgs (rd :: IntRegEnc) (c1 :: CapRegEnc) = (
   (@) ((strReg rd)) (((@) ('', '') ((strCReg c1)))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  c1  :: "(5)Word.word "


\<comment> \<open>\<open>val strCRArgs : mword ty5 -> mword ty5 -> string\<close>\<close>

definition strCRArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strCRArgs (cd1 :: CapRegEnc) (r1 :: IntRegEnc) = (
   (@) ((strCReg cd1)) (((@) ('', '') ((strReg r1)))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  r1  :: "(5)Word.word "


\<comment> \<open>\<open>val strCCArgs : mword ty5 -> mword ty5 -> string\<close>\<close>

definition strCCArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strCCArgs (cd1 :: CapRegEnc) (c1 :: CapRegEnc) = (
   (@) ((strCReg cd1)) (((@) ('', '') ((strCReg c1)))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  c1  :: "(5)Word.word "


\<comment> \<open>\<open>val strCCCArgs : mword ty5 -> mword ty5 -> mword ty5 -> string\<close>\<close>

definition strCCCArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strCCCArgs (cd1 :: CapRegEnc) (c1 :: CapRegEnc) (c2 :: CapRegEnc) = (
   (@) ((strCReg cd1))
     (((@) ('', '') (((@) ((strCReg c1)) (((@) ('', '') ((strCReg c2)))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  c1  :: "(5)Word.word " 
  and  c2  :: "(5)Word.word "


\<comment> \<open>\<open>val strCCRArgs : mword ty5 -> mword ty5 -> mword ty5 -> string\<close>\<close>

definition strCCRArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strCCRArgs (cd1 :: CapRegEnc) (c1 :: CapRegEnc) (r2 :: IntRegEnc) = (
   (@) ((strCReg cd1))
     (((@) ('', '') (((@) ((strCReg c1)) (((@) ('', '') ((strReg r2)))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  c1  :: "(5)Word.word " 
  and  r2  :: "(5)Word.word "


\<comment> \<open>\<open>val strRCCArgs : mword ty5 -> mword ty5 -> mword ty5 -> string\<close>\<close>

definition strRCCArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strRCCArgs (rd :: IntRegEnc) (c1 :: CapRegEnc) (c2 :: CapRegEnc) = (
   (@) ((strReg rd))
     (((@) ('', '') (((@) ((strCReg c1)) (((@) ('', '') ((strCReg c2)))))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  c1  :: "(5)Word.word " 
  and  c2  :: "(5)Word.word "


\<comment> \<open>\<open>val strRCRArgs : mword ty5 -> mword ty5 -> mword ty5 -> string\<close>\<close>

definition strRCRArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> strRCRArgs (rd :: IntRegEnc) (c1 :: CapRegEnc) (r2 :: IntRegEnc) = (
   (@) ((strReg rd))
     (((@) ('', '') (((@) ((strCReg c1)) (((@) ('', '') ((strReg r2)))))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  c1  :: "(5)Word.word " 
  and  r2  :: "(5)Word.word "


\<comment> \<open>\<open>val strCCIArgs : forall 'n. Size 'n => mword ty5 -> mword ty5 -> mword 'n -> string\<close>\<close>

definition strCCIArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> strCCIArgs cd1 cs imm = (
   (@) ((strCReg cd1))
     (((@) ('', '')
         (((@) ((strCReg cs)) (((@) ('', '') ((dec_str ((Word.sint imm)))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word " 
  and  imm  :: "('n::len)Word.word "


\<comment> \<open>\<open>val strCCIUArgs : forall 'n. Size 'n => mword ty5 -> mword ty5 -> mword 'n -> string\<close>\<close>

definition strCCIUArgs  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> strCCIUArgs cd1 cs imm = (
   (@) ((strCReg cd1))
     (((@) ('', '')
         (((@) ((strCReg cs)) (((@) ('', '') ((hex_str ((Word.uint imm)))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word " 
  and  imm  :: "('n::len)Word.word "


definition decode  :: \<open>(32)Word.word \<Rightarrow>(ast)option \<close>  where 
     \<open> decode v__0 = (
   if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011001 ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (DADDIU (rs, rt, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000101101 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DADDU (rs, rt, rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011000 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (DADDI (rs, rt, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000101100 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DADD (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000100000 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (ADD (rs, rt, rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b001000 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ADDI (rs, rt, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000100001 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (ADDU (rs, rt, rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b001001 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ADDIU (rs, rt, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000101111 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSUBU (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000101110 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSUB (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000100010 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SUB (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000100011 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SUBU (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000100100 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (AND0 (rs, rt, rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b001100 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ANDI (rs, rt, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000100101 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (OR0 (rs, rt, rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b001101 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ORI (rs, rt, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000100111 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (NOR (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000100110 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (XOR0 (rs, rt, rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b001110 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (XORI (rs, rt, imm)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00111100000 ::  11 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (LUI (rt, imm))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b111000 ::  6 Word.word)))))))
   then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSLL (rt, rd, sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b111100 ::  6 Word.word)))))))
   then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSLL32 (rt, rd, sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000010100 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSLLV (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b111011 ::  6 Word.word)))))))
   then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRA (rt, rd, sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b111111 ::  6 Word.word)))))))
   then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRA32 (rt, rd, sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000010111 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRAV (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b111010 ::  6 Word.word)))))))
   then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRL (rt, rd, sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b111110 ::  6 Word.word)))))))
   then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRL32 (rt, rd, sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000010110 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRLV (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))
   then
     (let (sa :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SLL (rt, rd, sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000100 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SLLV (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000011 ::  6 Word.word)))))))
   then
     (let (sa :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SRA (rt, rd, sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000111 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SRAV (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000010 ::  6 Word.word)))))))
   then
     (let (sa :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SRL (rt, rd, sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000110 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SRLV (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000101010 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SLT (rs, rt, rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b001010 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (SLTI (rs, rt, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000101011 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SLTU (rs, rt, rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b001011 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (SLTIU (rs, rt, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001011 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MOVN (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001010 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MOVZ (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = ( 0x0000 ::  16 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000010000 ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MFHI rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = ( 0x0000 ::  16 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000010010 ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MFLO rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 0 :: int)::ii)  ::  21 Word.word)) = ( 0b000000000000000010001 ::  21 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MTHI rs))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 0 :: int)::ii)  ::  21 Word.word)) = ( 0b000000000000000010011 ::  21 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MTLO rs))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011100 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000010 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MUL (rs, rt, rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x0018 ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MULT (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x0019 ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MULTU (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x001C ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DMULT (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x001D ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DMULTU (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011100 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x0000 ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MADD (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011100 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x0001 ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MADDU (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011100 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x0004 ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MSUB (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011100 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x0005 ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MSUBU (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x001A ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DIV (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x001B ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DIVU (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x001E ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DDIV (rs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x001F ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DDIVU (rs, rt))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000010 ::  6 Word.word))))
   then
     (let (offset :: 26 bits) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 0 :: int)::ii)  ::  26 Word.word)) in
     Some (J offset))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000011 ::  6 Word.word))))
   then
     (let (offset :: 26 bits) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 0 :: int)::ii)  ::  26 Word.word)) in
     Some (JAL offset))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 11 :: int)::ii)  ::  10 Word.word)) = ( 0b0000000000 ::  10 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001000 ::  6 Word.word)))))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (JR rs))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001001 ::  6 Word.word)))))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (JALR (rs, rd))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000100 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BEQ (rs, rt, imm, False, False)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b010100 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BEQ (rs, rt, imm, False, True)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000101 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BEQ (rs, rt, imm, True, False)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b010101 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BEQ (rs, rt, imm, True, True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, LT', False, False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b10000 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, LT', True, False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b00010 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, LT', False, True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b10010 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, LT', True, True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b00001 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, GE, False, False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b10001 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, GE, True, False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b00011 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, GE, False, True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b10011 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, GE, True, True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000111 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, GT', False, False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b010111 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, GT', False, True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000110 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, LE, False, False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b010110 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs, imm, LE, False, True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001100 ::  6 Word.word)))))))
   then
     Some (SYSCALL () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001101 ::  6 Word.word)))))))
   then
     Some (BREAK () )
   else if (((v__0 = ( 0x42000020 ::  32 Word.word)))) then Some (WAIT () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b110000 ::  6 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs, rt, GE))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b110001 ::  6 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs, rt, GEU))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b110010 ::  6 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs, rt, LT'))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b110011 ::  6 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs, rt, LTU))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b110100 ::  6 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs, rt, EQ'))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b110110 ::  6 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs, rt, NE))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b01100 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs, imm, EQ'))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b01110 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs, imm, NE))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b01000 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs, imm, GE))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b01001 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs, imm, GEU))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b01010 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs, imm, LT'))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = ( 0b01011 ::  5 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs, imm, LTU))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b100000 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (B, True, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b100100 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (B, False, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b100001 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (H, True, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b100101 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (H, False, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (W, True, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b100111 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (W, False, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110111 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (D, False, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110000 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (W, True, True, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110100 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (D, False, True, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b101000 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (B, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b101001 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (H, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b101011 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (W, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b111111 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (D, False, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b111000 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (W, True, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b111100 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (D, True, base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b100010 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (LWL (base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b100110 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (LWR (base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b101010 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (SWL (base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b101110 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (SWR (base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011010 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (LDL (base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011011 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (LDR (base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b101100 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (SDL (base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b101101 ::  6 Word.word))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (SDR (base, rt, offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b101111 ::  6 Word.word))))
   then
     (let (op1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (CACHE (base, op1, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 11 :: int)::ii)  ::  21 Word.word)) = ( 0b000000000000000000000 ::  21 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001111 ::  6 Word.word)))))))
   then
     Some (SYNC () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01000000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) = ( 0x00 ::  8 Word.word)))))))
   then
     (let (sel :: 3 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MFC0 (rt, rd, sel, False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01000000001 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) = ( 0x00 ::  8 Word.word)))))))
   then
     (let (sel :: 3 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MFC0 (rt, rd, sel, True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01000000100 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0xB800 ::  16 Word.word)))))))
   then
     Some (HCF () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01000000100 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0xD000 ::  16 Word.word)))))))
   then
     Some (HCF () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01000000100 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) = ( 0x00 ::  8 Word.word)))))))
   then
     (let (sel :: 3 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MTC0 (rt, rd, sel, False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01000000101 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) = ( 0x00 ::  8 Word.word)))))))
   then
     (let (sel :: 3 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MTC0 (rt, rd, sel, True)))))
   else if (((v__0 = ( 0x42000002 ::  32 Word.word)))) then Some (TLBWI () )
   else if (((v__0 = ( 0x42000006 ::  32 Word.word)))) then Some (TLBWR () )
   else if (((v__0 = ( 0x42000001 ::  32 Word.word)))) then Some (TLBR () )
   else if (((v__0 = ( 0x42000008 ::  32 Word.word)))) then Some (TLBP () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01111100000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000111011 ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (RDHWR (rt, rd))))
   else if (((v__0 = ( 0x42000018 ::  32 Word.word)))) then Some (ERET () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPerm (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000001 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetType (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000010 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetBase (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000011 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetLen (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000101 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetTag (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000110 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetSealed (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x0004 ::  16 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetCause rd))
   else if (((v__0 = ( 0x48C00000 ::  32 Word.word)))) then Some (CReturn () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001101 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000010 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetOffset (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 11 :: int)::ii)  ::  21 Word.word)) = ( 0b010010001000000000000 ::  21 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000100 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetCause rt))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000100 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CAndPerm (cd1, cb, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001100 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CToPtr (rd, cb, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001110 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, ct, CEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001110 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, ct, CNE)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001110 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000010 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, ct, CLT)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001110 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000011 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, ct, CLE)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001110 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000100 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, ct, CLTU)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001110 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000101 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, ct, CLEU)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001110 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000110 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, ct, CEXEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001110 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000111 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, ct, CNEXEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001101 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CIncOffset (cd1, cb, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001101 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetOffset (cd1, cb, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000001 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetBounds (cd1, cb, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000100 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000101 ::  11 Word.word))))))) then
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CClearTag (cd1, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000100 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000111 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CFromPtr (cd1, cb, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001011 ::  11 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))))) then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CCheckPerm (cs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001011 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000001 ::  11 Word.word))))))) then
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CCheckType (cs, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000010 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))
   then
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSeal (cd1, cs, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000011 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))
   then
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CUnseal (cd1, cs, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000111 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word))))))) then
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CJALR (cd1, cb, True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = ( 0x4900 ::  16 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000000000 ::  11 Word.word))))))) then
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CJALR (( 0b00000 ::  5 Word.word), cb, False)))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x0FFF ::  16 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetCause rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x17FF ::  16 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetCause rs))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x07FF ::  16 Word.word)))))))
   then
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPCC cd1))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x1FFF ::  16 Word.word)))))))
   then
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CJALR (( 0b00000 ::  5 Word.word), cb, False)))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x27FF ::  16 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetCID rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x2FFF ::  16 Word.word)))))))
   then
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetCID cb))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0xC7FF ::  16 Word.word)))))))
   then
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CClearTags cb))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b01000111111 ::  11 Word.word))))))) then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CCheckPerm (cs, rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b01001111111 ::  11 Word.word))))))) then
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CCheckType (cs, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b01011111111 ::  11 Word.word))))))) then
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CClearTag (cd1, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b01010111111 ::  11 Word.word))))))) then
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CMove (cd1, cs))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b01100111111 ::  11 Word.word))))))) then
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CJALR (cd1, cb, True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b11101111111 ::  11 Word.word))))))) then
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSealEntry (cd1, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b11110111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoadTags (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPerm (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00001111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetType (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00010111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetBase (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00011111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetLen (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00100111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetTag (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00101111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetSealed (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00110111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetOffset (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00111111111 ::  11 Word.word))))))) then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPCCSetOffset (cd1, rs))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b01101111111 ::  11 Word.word))))))) then
     (let (sel :: CapHwrEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CReadHwr (cd1, sel))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b01110111111 ::  11 Word.word))))))) then
     (let (sel :: CapHwrEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CWriteHwr (cb, sel))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b01111111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetAddr (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b10010111111 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetFlags (rd, cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b10011111111 ::  11 Word.word))))))) then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPCCIncOffset (cd1, rs))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b10100111111 ::  11 Word.word))))))) then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPCCSetAddr (cd1, rs))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b10000111111 ::  11 Word.word))))))) then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CRAP (rt, rs))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b10001111111 ::  11 Word.word))))))) then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CRAM (rt, rs))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001011 ::  6 Word.word)))))))
   then
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSeal (cd1, cs, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001100 ::  6 Word.word)))))))
   then
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CUnseal (cd1, cs, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001101 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CAndPerm (cd1, cs, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001111 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetOffset (cd1, cs, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001000 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetBounds (cd1, cs, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001001 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetBoundsExact (cd1, cs, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001110 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetFlags (cd1, cs, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b010001 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CIncOffset (cd1, cb, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b011101 ::  6 Word.word)))))))
   then
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CBuildCap (cd1, cb, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b011110 ::  6 Word.word)))))))
   then
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CCopyType (cd1, cb, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b011111 ::  6 Word.word)))))))
   then
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CCSeal (cd1, cs, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b010010 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CToPtr (rd, cb, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b010011 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CFromPtr (cd1, cb, rs)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b001010 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSub (rt, cb, cs)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b011011 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CMOVX (cd1, cs, rs, False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b011100 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CMOVX (cd1, cs, rs, True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b100010 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetAddr (cd1, cs, rs)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetAndAddr (rd, cs, rs)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b100100 ::  6 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CAndAddr (cd1, cs, rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b010100 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, cs, CEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b010101 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, cs, CNE)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b010110 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, cs, CLT)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b010111 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, cs, CLE)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b011000 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, cs, CLTU)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b011001 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, cs, CLEU)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b011010 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, cs, CEXEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b100001 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd, cb, cs, CNEXEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b100000 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: CapRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CTestSubset (rd, cb, ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b111000 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLCNT (cd1, cs, rs)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001001 ::  11 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CBX (cd1, imm, True))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001001010 ::  11 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CBX (cd1, imm, False))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010001 ::  11 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CBZ (cd1, imm, False))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010010 ::  11 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CBZ (cd1, imm, True))))
   else if (((v__0 = ( 0x48A007FF ::  32 Word.word)))) then Some (CReturn () )
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000101 ::  11 Word.word)))) then
     (let (selector :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CCall (cs, cb, selector)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = ( 0x49E0 ::  16 Word.word))))
   then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ClearRegs (GPLo, imm)))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = ( 0x49E1 ::  16 Word.word))))
   then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ClearRegs (GPHi, imm)))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = ( 0x49E2 ::  16 Word.word))))
   then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ClearRegs (CLo, imm)))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = ( 0x49E3 ::  16 Word.word))))
   then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ClearRegs (CHi, imm)))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010011 ::  11 Word.word)))) then
     (let (imm :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CIncOffsetImmediate (cd1, cb, imm)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010100 ::  11 Word.word)))) then
     (let (imm :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetBoundsImmediate (cd1, cb, imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd, cb, rt, offset, False, B))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd, cb, rt, offset, True, B))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd, cb, rt, offset, False, H))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd, cb, rt, offset, True, H))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd, cb, rt, offset, False, W))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b110 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd, cb, rt, offset, True, W))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd, cb, rt, offset, False, D))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001000 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoadLinked (rd, cb, False, B))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001100 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoadLinked (rd, cb, True, B))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001001 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoadLinked (rd, cb, False, H))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001101 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoadLinked (rd, cb, True, H))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001010 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoadLinked (rd, cb, False, W))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001110 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoadLinked (rd, cb, True, W))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001011 ::  11 Word.word))))))) then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoadLinked (rd, cb, False, D))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b111010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs, cb, rt, offset, B))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b111010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs, cb, rt, offset, H))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b111010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs, cb, rt, offset, W))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b111010 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs, cb, rt, offset, D))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CStoreConditional (rs, cb, rd, B)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000001 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CStoreConditional (rs, cb, rd, H)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000010 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CStoreConditional (rs, cb, rd, W)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000011 ::  6 Word.word)))))))
   then
     (let (rs :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CStoreConditional (rs, cb, rd, D)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b111110 ::  6 Word.word))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSC (cs, cb, rt, offset))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = ( 0b000111 ::  6 Word.word)))))))
   then
     (let (rd :: IntRegEnc) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSCC (cs, cb, rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b110110 ::  6 Word.word))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLC (cd1, cb, rt, offset))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001010000 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = ( 0b00000001111 ::  11 Word.word))))))) then
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLLC (cd1, cb))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b011101 ::  6 Word.word))))
   then
     (let (offset :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: CapRegEnc) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: CapRegOrDDCEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLCBI (cd1, cb, offset)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = ( 0b01001000100 ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ( 0x0006 ::  16 Word.word)))))))
   then
     (let (rt :: IntRegEnc) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (C2Dump rt))
   else Some (RI () ))\<close> 
  for  v__0  :: "(32)Word.word "


\<comment> \<open>\<open>val execute_XORI : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_XORI  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_XORI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   wGPR rt ((xor_vec w__0 ((mips_zero_extend (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_XOR : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_XOR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_XOR rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((xor_vec w__0 w__1  ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_WAIT : unit -> M unit\<close>\<close>

definition execute_WAIT  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_WAIT _ = (
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  write_reg NextPC_ref w__1)))))\<close>


\<comment> \<open>\<open>val execute_TRAPREG : mword ty5 -> mword ty5 -> Comparison -> M unit\<close>\<close>

definition execute_TRAPREG  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> Comparison \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_TRAPREG rs rt cmp = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   (let condition = (compare cmp rs_val rt_val) in
   if condition then SignalException Tr
   else return () ))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cmp  :: " Comparison "


\<comment> \<open>\<open>val execute_TRAPIMM : mword ty5 -> mword ty16 -> Comparison -> M unit\<close>\<close>

definition execute_TRAPIMM  :: \<open>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> Comparison \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_TRAPIMM rs imm cmp = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs_val . 
   (let (imm_val :: 64 bits) = ((mips_sign_extend (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   (let condition = (compare cmp rs_val imm_val) in
   if condition then SignalException Tr
   else return () )))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  cmp  :: " Comparison "


\<comment> \<open>\<open>val execute_TLBWR : unit -> M unit\<close>\<close>

definition execute_TLBWR  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_TLBWR _ = (
   (checkCP0Access ()  \<then>
   (read_reg TLBRandom_ref  :: ( 6 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  6 Word.word) .  TLBWriteEntry w__0)))\<close>


\<comment> \<open>\<open>val execute_TLBWI : unit -> M unit\<close>\<close>

definition execute_TLBWI  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_TLBWI _ = (
   (checkCP0Access ()  \<then>
   (read_reg TLBIndex_ref  :: ( 6 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  6 Word.word) .  TLBWriteEntry w__0)))\<close>


\<comment> \<open>\<open>val execute_TLBR : unit -> M unit\<close>\<close>

definition execute_TLBR  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_TLBR _ = (
   (checkCP0Access ()  \<then>
   (read_reg TLBIndex_ref  :: ( 6 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  6 Word.word) . 
   (let i = (Word.uint w__0) in
   read_reg ((access_list_dec TLBEntries i)) \<bind> ((\<lambda> entry . 
   (((((((((((((((((((((write_reg TLBPageMask_ref ((get_TLBEntry_pagemask entry  ::  16 Word.word)) \<then>
   set_TLBEntryHiReg_R TLBEntryHi_ref ((get_TLBEntry_r entry  ::  2 Word.word))) \<then>
   set_TLBEntryHiReg_CLGK TLBEntryHi_ref ((cast_unit_vec0 B0  ::  1 Word.word))) \<then>
   set_TLBEntryHiReg_CLGS TLBEntryHi_ref ((cast_unit_vec0 B0  ::  1 Word.word))) \<then>
   set_TLBEntryHiReg_CLGU TLBEntryHi_ref ((cast_unit_vec0 B0  ::  1 Word.word))) \<then>
   set_TLBEntryHiReg_VPN2 TLBEntryHi_ref ((get_TLBEntry_vpn2 entry  ::  27 Word.word))) \<then>
   set_TLBEntryHiReg_ASID TLBEntryHi_ref ((get_TLBEntry_asid entry  ::  8 Word.word))) \<then>
   set_TLBEntryLoReg_CapS TLBEntryLo0_ref ((get_TLBEntry_caps0 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_CapL TLBEntryLo0_ref ((get_TLBEntry_capl0 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_CapLG TLBEntryLo0_ref ((get_TLBEntry_caplg0 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_PFN TLBEntryLo0_ref ((get_TLBEntry_pfn0 entry  ::  24 Word.word))) \<then>
   set_TLBEntryLoReg_C TLBEntryLo0_ref ((get_TLBEntry_c0 entry  ::  3 Word.word))) \<then>
   set_TLBEntryLoReg_D TLBEntryLo0_ref ((get_TLBEntry_d0 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_V TLBEntryLo0_ref ((get_TLBEntry_v0 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_G TLBEntryLo0_ref ((get_TLBEntry_g entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_CapS TLBEntryLo1_ref ((get_TLBEntry_caps1 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_CapL TLBEntryLo1_ref ((get_TLBEntry_capl1 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_CapLG TLBEntryLo1_ref ((get_TLBEntry_caplg1 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_PFN TLBEntryLo1_ref ((get_TLBEntry_pfn1 entry  ::  24 Word.word))) \<then>
   set_TLBEntryLoReg_C TLBEntryLo1_ref ((get_TLBEntry_c1 entry  ::  3 Word.word))) \<then>
   set_TLBEntryLoReg_D TLBEntryLo1_ref ((get_TLBEntry_d1 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_V TLBEntryLo1_ref ((get_TLBEntry_v1 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_G TLBEntryLo1_ref ((get_TLBEntry_g entry  ::  1 Word.word))))))))\<close>


\<comment> \<open>\<open>val execute_TLBP : unit -> M unit\<close>\<close>

definition execute_TLBP  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_TLBP _ = (
   (checkCP0Access ()  \<then>
   read_reg TLBEntryHi_ref) \<bind> ((\<lambda> (w__0 :: TLBEntryHiReg) . 
   (tlbSearch ((get_TLBEntryHiReg_bits w__0  ::  64 Word.word))  :: ( ( 6 Word.word)option) M) \<bind> ((\<lambda> result . 
   (case  result of
     Some (idx) => write_reg TLBProbe_ref ( 0b0 ::  1 Word.word) \<then> write_reg TLBIndex_ref idx
   | None =>
      write_reg TLBProbe_ref ( 0b1 ::  1 Word.word) \<then> write_reg TLBIndex_ref ( 0b000000 ::  6 Word.word)
   ))))))\<close>


\<comment> \<open>\<open>val execute_Store : WordType -> bool -> mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_Store  :: \<open> WordType \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_Store width conditional base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapper ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word))
      StoreData width
     :: ( 64 Word.word) M) \<bind> ((\<lambda> (vAddr :: 64 bits) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   if ((\<not> ((isAddressAligned vAddr width)))) then SignalExceptionBadAddr AdES vAddr
   else
   (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
   if conditional then
     and_boolM
       ((read_reg CP0LLBit_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__1 ::  1 Word.word) . 
        return ((bit_to_bool ((access_vec_dec w__1 (( 0 :: int)::ii))))))))
       ((read_reg CP0LLAddr_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
        return (((w__2 = pAddr)))))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then
        (case  width of
          W =>
           MEMw_conditional_wrapper pAddr (( 4 :: int)::ii)
             ((subrange_vec_dec rt_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        | D => MEMw_conditional_wrapper pAddr (( 8 :: int)::ii) rt_val
        | _ => throw (Error_internal_error () )
        )
      else return False) \<bind> ((\<lambda> (success :: bool) . 
     wGPR rt ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits success  ::  1 Word.word))  ::  64 Word.word))))))
   else
     (case  width of
       B => MEMw_wrapper pAddr (( 1 :: int)::ii) ((subrange_vec_dec rt_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
     | H => MEMw_wrapper pAddr (( 2 :: int)::ii) ((subrange_vec_dec rt_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
     | W => MEMw_wrapper pAddr (( 4 :: int)::ii) ((subrange_vec_dec rt_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
     | D => MEMw_wrapper pAddr (( 8 :: int)::ii) rt_val
     ))))))))))\<close> 
  for  width  :: " WordType " 
  and  conditional  :: " bool " 
  and  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_SYSCALL : unit -> M unit\<close>\<close>

definition execute_SYSCALL  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SYSCALL _ = ( SignalException Sys )\<close>


\<comment> \<open>\<open>val execute_SYNC : unit -> M unit\<close>\<close>

definition execute_SYNC  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SYNC _ = ( MEM_sync ()  )\<close>


\<comment> \<open>\<open>val execute_SWR : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_SWR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SWR base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) StoreData WR
     :: (( 64 Word.word * ii)) M) \<bind> ((\<lambda> varstup .  (let (vAddr, size1) = varstup in
   (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> reg_val . 
   (let l__12 = size1 in
   if (((l__12 = (( 1 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
   else if (((l__12 = (( 2 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
   else if (((l__12 = (( 3 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
   else if (((l__12 = (( 4 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
   else assert_exp False (''../mips/mips_insts.sail 1404:26 - 1404:27'') \<then> exit0 () )))))))))))\<close> 
  for  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_SWL : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_SWL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SWL base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) StoreData WL
     :: (( 64 Word.word * ii)) M) \<bind> ((\<lambda> varstup .  (let (vAddr, size1) = varstup in
   (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> reg_val . 
   (let l__8 = size1 in
   if (((l__8 = (( 4 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
   else if (((l__8 = (( 3 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 8 :: int)::ii)  ::  24 Word.word))
   else if (((l__8 = (( 2 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
   else if (((l__8 = (( 1 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))
   else assert_exp False (''../mips/mips_insts.sail 1383:24 - 1383:25'') \<then> exit0 () )))))))))))\<close> 
  for  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_SUBU : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SUBU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SUBU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> opA . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> opB . 
   if (((((NotWordVal opA)) \<or> ((NotWordVal opB))))) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))
   else
     wGPR rd
       ((mips_sign_extend (( 64 :: int)::ii)
           ((sub_vec ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
               ((subrange_vec_dec opB (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
              ::  32 Word.word))
          ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SUB : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SUB  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SUB rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> opA . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> opB . 
   if (((((NotWordVal opA)) \<or> ((NotWordVal opB))))) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))
   else
     (let (temp33 :: 33 bits) =
       ((sub_vec
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word))
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opB (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word))
         ::  33 Word.word)) in
     if ((neq_bool ((bit_to_bool ((access_vec_dec temp33 (( 32 :: int)::ii)))))
            ((bit_to_bool ((access_vec_dec temp33 (( 31 :: int)::ii))))))) then
       SignalException Ov
     else
       wGPR rd
         ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec temp33 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  64 Word.word))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SRLV : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SRLV  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SRLV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
   if ((NotWordVal temp)) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1))
   else
     (let rt32 = ((subrange_vec_dec temp (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (shift_bits_right 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
     wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__2  ::  64 Word.word)))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SRL : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SRL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SRL rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   if ((NotWordVal temp)) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))
   else
     (let rt32 = ((subrange_vec_dec temp (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (shift_bits_right 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__1  ::  64 Word.word))))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SRAV : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SRAV  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SRAV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
   if ((NotWordVal temp)) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1))
   else
     (let rt32 = ((subrange_vec_dec temp (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
     wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__2  ::  64 Word.word)))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SRA : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SRA  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SRA rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   if ((NotWordVal temp)) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))
   else
     (let rt32 = ((subrange_vec_dec temp (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__1  ::  64 Word.word))))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SLTU : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SLTU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SLTU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   wGPR rd
     ((mips_zero_extend (( 64 :: int)::ii)
         (if ((zopz0zI_u rs_val rt_val)) then ( 0b1 ::  1 Word.word)
          else ( 0b0 ::  1 Word.word))
        ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SLTIU : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_SLTIU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SLTIU rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs_val . 
   (let (immext :: 64 bits) = ((mips_sign_extend (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   wGPR rt
     ((mips_zero_extend (( 64 :: int)::ii)
         (if ((zopz0zI_u rs_val immext)) then ( 0b1 ::  1 Word.word)
          else ( 0b0 ::  1 Word.word))
        ::  64 Word.word))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_SLTI : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_SLTI  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SLTI rs rt imm = (
   (let imm_val = (Word.sint imm) in
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rs_val = (Word.sint w__0) in
   wGPR rt
     ((mips_zero_extend (( 64 :: int)::ii)
         (if ((rs_val < imm_val)) then ( 0b1 ::  1 Word.word)
          else ( 0b0 ::  1 Word.word))
        ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_SLT : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SLT  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SLT rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd
     ((mips_zero_extend (( 64 :: int)::ii)
         (if ((zopz0zI_s w__0 w__1)) then ( 0b1 ::  1 Word.word)
          else ( 0b0 ::  1 Word.word))
        ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SLLV : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SLLV  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SLLV rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let rt32 = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__2  ::  64 Word.word)))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SLL : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_SLL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SLL rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rt32 = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__1  ::  64 Word.word))))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_SDR : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_SDR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SDR base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) StoreData DR
     :: (( 64 Word.word * ii)) M) \<bind> ((\<lambda> varstup .  (let (vAddr, size1) = varstup in
   (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> reg_val . 
   (let l__40 = size1 in
   if (((l__40 = (( 1 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
   else if (((l__40 = (( 2 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
   else if (((l__40 = (( 3 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
   else if (((l__40 = (( 4 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
   else if (((l__40 = (( 5 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 39 :: int)::ii) (( 0 :: int)::ii)  ::  40 Word.word))
   else if (((l__40 = (( 6 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
   else if (((l__40 = (( 7 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))
   else if (((l__40 = (( 8 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
   else assert_exp False (''../mips/mips_insts.sail 1509:24 - 1509:25'') \<then> exit0 () )))))))))))\<close> 
  for  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_SDL : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_SDL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_SDL base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) StoreData DL
     :: (( 64 Word.word * ii)) M) \<bind> ((\<lambda> varstup .  (let (vAddr, size1) = varstup in
   (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> reg_val . 
   (let l__32 = size1 in
   if (((l__32 = (( 8 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
   else if (((l__32 = (( 7 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 8 :: int)::ii)  ::  56 Word.word))
   else if (((l__32 = (( 6 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 16 :: int)::ii)  ::  48 Word.word))
   else if (((l__32 = (( 5 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 24 :: int)::ii)  ::  40 Word.word))
   else if (((l__32 = (( 4 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
   else if (((l__32 = (( 3 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 40 :: int)::ii)  ::  24 Word.word))
   else if (((l__32 = (( 2 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 48 :: int)::ii)  ::  16 Word.word))
   else if (((l__32 = (( 1 :: int)::ii)))) then
     MEMw_wrapper pAddr size1 ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))
   else assert_exp False (''../mips/mips_insts.sail 1482:24 - 1482:25'') \<then> exit0 () )))))))))))\<close> 
  for  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_RI : unit -> M unit\<close>\<close>

definition execute_RI  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_RI _ = ( skip ()  \<then> SignalException ResI )\<close>


\<comment> \<open>\<open>val execute_RDHWR : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_RDHWR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_RDHWR rt rd = (
   getAccessLevel ()  \<bind> ((\<lambda> accessLevel . 
   (let (haveAccessLevel :: bool) = (accessLevel = Kernel) in
   read_reg CP0Status_ref \<bind> ((\<lambda> (w__0 :: StatusReg) . 
   (let (haveCU0 :: bool) = (B1 = ((access_vec_dec ((get_StatusReg_CU w__0  ::  4 Word.word)) (( 0 :: int)::ii)))) in
   (let rdi = (Word.uint rd) in
   (read_reg CP0HWREna_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let (haveHWREna :: bool) = (B1 = ((access_vec_dec w__1 rdi))) in
   (if ((\<not> (((haveAccessLevel \<or> (((haveCU0 \<or> haveHWREna)))))))) then SignalException ResI
    else return () ) \<then>
   ((let b__102 = rd in
   (if (((b__102 = ( 0b00000 ::  5 Word.word)))) then
      return ((mips_zero_extend (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))
    else if (((b__102 = ( 0b00001 ::  5 Word.word)))) then
      return ((mips_zero_extend (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))
    else if (((b__102 = ( 0b00010 ::  5 Word.word)))) then
      (read_reg CP0Count_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((mips_zero_extend (( 64 :: int)::ii) w__2  ::  64 Word.word))))
    else if (((b__102 = ( 0b00011 ::  5 Word.word)))) then
      return ((mips_zero_extend (( 64 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  64 Word.word))
    else if (((b__102 = ( 0b11101 ::  5 Word.word)))) then
      (read_reg CP0UserLocal_ref  :: ( 64 Word.word) M)
    else (SignalException ResI  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (temp :: 64 bits) . 
   wGPR rt temp)))))))))))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_ORI : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_ORI  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_ORI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   wGPR rt ((or_vec w__0 ((mips_zero_extend (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_OR : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_OR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_OR rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((or_vec w__0 w__1  ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_NOR : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_NOR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_NOR rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((not_vec ((or_vec w__0 w__1  ::  64 Word.word))  ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MULTU : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_MULTU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MULTU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mult_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> ((\<lambda> (result :: 64 bits) . 
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MULT : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_MULT  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MULT rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mults_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> ((\<lambda> (result :: 64 bits) . 
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MUL : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_MUL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MUL rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rtVal . 
   (let (result :: 64 bits) =
     ((mips_sign_extend (( 64 :: int)::ii)
        ((mults_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word))
       ::  64 Word.word)) in
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd w__1))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MTLO : mword ty5 -> M unit\<close>\<close>

definition execute_MTLO  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MTLO rs = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  write_reg LO_ref w__0)))\<close> 
  for  rs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MTHI : mword ty5 -> M unit\<close>\<close>

definition execute_MTHI  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MTHI rs = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  write_reg HI_ref w__0)))\<close> 
  for  rs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MTC0 : mword ty5 -> mword ty5 -> mword ty3 -> bool -> M unit\<close>\<close>

definition execute_MTC0  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MTC0 rt rd sel double = (
   (checkCP0Access ()  \<then>
   (rGPR rt  :: ( 64 Word.word) M)) \<bind> ((\<lambda> reg_val . 
   (case  (rd, sel) of
     (b__64, b__65) =>
      if ((((((b__64 = ( 0b00000 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        write_reg TLBIndex_ref ((mask0 (( 6 :: int)::ii) reg_val  ::  6 Word.word))
      else if ((((((b__64 = ( 0b00001 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        return () 
      else if ((((((b__64 = ( 0b00010 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        set_TLBEntryLoReg_bits TLBEntryLo0_ref reg_val
      else if ((((((b__64 = ( 0b00011 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        set_TLBEntryLoReg_bits TLBEntryLo1_ref reg_val
      else if ((((((b__64 = ( 0b00100 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        set_ContextReg_PTEBase TLBContext_ref
          ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 23 :: int)::ii)  ::  41 Word.word))
      else if ((((((b__64 = ( 0b00100 ::  5 Word.word)))) \<and> (((b__65 = ( 0b010 ::  3 Word.word)))))))
      then
        write_reg CP0UserLocal_ref reg_val
      else if ((((((b__64 = ( 0b00101 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        write_reg TLBPageMask_ref ((subrange_vec_dec reg_val (( 28 :: int)::ii) (( 13 :: int)::ii)  ::  16 Word.word))
      else if ((((((b__64 = ( 0b00110 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        write_reg TLBWired_ref ((mask0 (( 6 :: int)::ii) reg_val  ::  6 Word.word)) \<then>
        write_reg TLBRandom_ref TLBIndexMax
      else if ((((((b__64 = ( 0b00111 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        write_reg
          CP0HWREna_ref
          ((concat_vec ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 29 :: int)::ii)  ::  3 Word.word))
              ((concat_vec ( 0b0000000000000000000000000 ::  25 Word.word)
                  ((subrange_vec_dec reg_val (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
                 ::  29 Word.word))
             ::  32 Word.word))
      else if ((((((b__64 = ( 0b01000 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        return () 
      else if ((((((b__64 = ( 0b01001 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        write_reg CP0Count_ref ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
      else if ((((((b__64 = ( 0b01010 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        ((((set_TLBEntryHiReg_R TLBEntryHi_ref
          ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word)) \<then>
        set_TLBEntryHiReg_CLGK TLBEntryHi_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 61 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_TLBEntryHiReg_CLGS TLBEntryHi_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 60 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_TLBEntryHiReg_CLGU TLBEntryHi_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 59 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_TLBEntryHiReg_VPN2 TLBEntryHi_ref
          ((subrange_vec_dec reg_val (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word))) \<then>
        set_TLBEntryHiReg_ASID TLBEntryHi_ref
          ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
      else if ((((((b__64 = ( 0b01011 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        (write_reg CP0Compare_ref ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
        read_reg CP0Cause_ref) \<bind> ((\<lambda> (w__0 :: CauseReg) . 
        set_CauseReg_IP CP0Cause_ref
          ((and_vec ((get_CauseReg_IP w__0  ::  8 Word.word)) ( 0x7F ::  8 Word.word)  ::  8 Word.word))))
      else if ((((((b__64 = ( 0b01100 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        ((((((((set_StatusReg_CU CP0Status_ref
          ((and_vec ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word))
              ((concat_vec ( 0b0 ::  1 Word.word)
                  ((concat_vec ((bool_to_bits have_cp2  ::  1 Word.word)) ( 0b01 ::  2 Word.word)
                     ::  3 Word.word))
                 ::  4 Word.word))
             ::  4 Word.word)) \<then>
        set_StatusReg_BEV CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 22 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_IM CP0Status_ref ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))) \<then>
        set_StatusReg_KX CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 7 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_SX CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 6 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_UX CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 5 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_KSU CP0Status_ref ((subrange_vec_dec reg_val (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word))) \<then>
        set_StatusReg_ERL CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 2 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_EXL CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 1 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_IE CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 0 :: int)::ii)))  ::  1 Word.word))
      else if ((((((b__64 = ( 0b01101 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        (set_CauseReg_IV CP0Cause_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 23 :: int)::ii)))  ::  1 Word.word)) \<then>
        read_reg CP0Cause_ref) \<bind> ((\<lambda> (w__1 :: CauseReg) . 
        (let ip = ((get_CauseReg_IP w__1  ::  8 Word.word)) in
        set_CauseReg_IP CP0Cause_ref
          ((concat_vec ((subrange_vec_dec ip (( 7 :: int)::ii) (( 2 :: int)::ii)  ::  6 Word.word))
              ((subrange_vec_dec reg_val (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))
             ::  8 Word.word)))))
      else if ((((((b__64 = ( 0b01110 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        set_CP0EPC reg_val
      else if ((((((b__64 = ( 0b10000 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        write_reg CP0ConfigK0_ref ((subrange_vec_dec reg_val (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))
      else if ((((((b__64 = ( 0b10100 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        set_XContextReg_XPTEBase TLBXContext_ref
          ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 33 :: int)::ii)  ::  31 Word.word))
      else if ((((((b__64 = ( 0b11110 ::  5 Word.word)))) \<and> (((b__65 = ( 0b000 ::  3 Word.word)))))))
      then
        set_CP0ErrorEPC reg_val
      else SignalException ResI
   ))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sel  :: "(3)Word.word " 
  and  double  :: " bool "


\<comment> \<open>\<open>val execute_MSUBU : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_MSUBU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MSUBU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mult_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> ((\<lambda> (mul_result :: 64 bits) . 
   (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (let result =
     ((sub_vec
        ((concat_vec ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word)) mul_result
       ::  64 Word.word)) in
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word))))))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MSUB : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_MSUB  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MSUB rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mults_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> ((\<lambda> (mul_result :: 64 bits) . 
   (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (let result =
     ((sub_vec
        ((concat_vec ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word)) mul_result
       ::  64 Word.word)) in
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word))))))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MOVZ : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_MOVZ  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MOVZ rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   if (((w__0 = ( 0x0000000000000000 ::  64 Word.word)))) then
     (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1))
   else return () )))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MOVN : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_MOVN  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MOVN rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   if (((w__0 \<noteq> ( 0x0000000000000000 ::  64 Word.word)))) then
     (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1))
   else return () )))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MFLO : mword ty5 -> M unit\<close>\<close>

definition execute_MFLO  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MFLO rd = (
   (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)))\<close> 
  for  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MFHI : mword ty5 -> M unit\<close>\<close>

definition execute_MFHI  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MFHI rd = (
   (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)))\<close> 
  for  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MFC0 : mword ty5 -> mword ty5 -> mword ty3 -> bool -> M unit\<close>\<close>

definition execute_MFC0  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MFC0 rt rd sel double = (
   (checkCP0Access ()  \<then>
   (case  (rd, sel) of
     (b__0, b__1) =>
      if ((((((b__0 = ( 0b00000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word))))))) then
        (read_reg TLBIndex_ref  :: ( 6 Word.word) M) \<bind> ((\<lambda> (w__0 ::  6 Word.word) . 
        (let (idx :: 31 bits) = ((mips_zero_extend (( 31 :: int)::ii) w__0  ::  31 Word.word)) in
        (read_reg TLBProbe_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__1 ::  1 Word.word) . 
        return ((concat_vec ( 0x00000000 ::  32 Word.word) ((concat_vec w__1 idx  ::  32 Word.word))
                  ::  64 Word.word)))))))
      else if ((((((b__0 = ( 0b00001 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (read_reg TLBRandom_ref  :: ( 6 Word.word) M) \<bind> ((\<lambda> (w__2 ::  6 Word.word) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__2  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b00010 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        read_reg TLBEntryLo0_ref \<bind> ((\<lambda> (w__3 :: TLBEntryLoReg) . 
        return ((get_TLBEntryLoReg_bits w__3  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b00011 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        read_reg TLBEntryLo1_ref \<bind> ((\<lambda> (w__4 :: TLBEntryLoReg) . 
        return ((get_TLBEntryLoReg_bits w__4  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b00100 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        read_reg TLBContext_ref \<bind> ((\<lambda> (w__5 :: ContextReg) . 
        return ((get_ContextReg_bits w__5  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b00100 ::  5 Word.word)))) \<and> (((b__1 = ( 0b010 ::  3 Word.word)))))))
      then
        (read_reg CP0UserLocal_ref  :: ( 64 Word.word) M)
      else if ((((((b__0 = ( 0b00101 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (read_reg TLBPageMask_ref  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
        return ((place_slice (( 64 :: int)::ii) w__7 (( 0 :: int)::ii) (( 16 :: int)::ii) (( 12 :: int)::ii)  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b00110 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (read_reg TLBWired_ref  :: ( 6 Word.word) M) \<bind> ((\<lambda> (w__8 ::  6 Word.word) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__8  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b00111 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (read_reg CP0HWREna_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__9  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b01000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (read_reg CP0BadVAddr_ref  :: ( 64 Word.word) M)
      else if ((((((b__0 = ( 0b01000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b001 ::  3 Word.word)))))))
      then
        (read_reg CP0BadInstr_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__11  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b01000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b010 ::  3 Word.word)))))))
      then
        (read_reg CP0BadInstrP_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__12  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b01001 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (read_reg CP0Count_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__13  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b01010 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        read_reg TLBEntryHi_ref \<bind> ((\<lambda> (w__14 :: TLBEntryHiReg) . 
        return ((get_TLBEntryHiReg_bits w__14  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b01011 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (read_reg CP0Compare_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__15  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b01100 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        read_reg CP0Status_ref \<bind> ((\<lambda> (w__16 :: StatusReg) . 
        return ((mips_zero_extend (( 64 :: int)::ii) ((get_StatusReg_bits w__16  ::  32 Word.word))  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b01101 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        read_reg CP0Cause_ref \<bind> ((\<lambda> (w__17 :: CauseReg) . 
        return ((mips_zero_extend (( 64 :: int)::ii) ((get_CauseReg_bits w__17  ::  32 Word.word))  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b01110 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (get_CP0EPC ()   :: ( 64 Word.word) M)
      else if ((((((b__0 = ( 0b01111 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        return ((mips_zero_extend (( 64 :: int)::ii) ( 0x00000405 ::  32 Word.word)  ::  64 Word.word))
      else if ((((((b__0 = ( 0b01111 ::  5 Word.word)))) \<and> (((b__1 = ( 0b110 ::  3 Word.word)))))))
      then
        return ((mips_zero_extend (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))
      else if ((((((b__0 = ( 0b01111 ::  5 Word.word)))) \<and> (((b__1 = ( 0b111 ::  3 Word.word)))))))
      then
        return ((mips_zero_extend (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))
      else if ((((((b__0 = ( 0b10000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (read_reg CP0ConfigK0_ref  :: ( 3 Word.word) M) \<bind> ((\<lambda> (w__19 ::  3 Word.word) . 
        return ((mips_zero_extend (( 64 :: int)::ii)
                   ((concat_vec ( 0b1 ::  1 Word.word)
                       ((concat_vec ( 0b000000000000000 ::  15 Word.word)
                           ((concat_vec ( 0b1 ::  1 Word.word)
                               ((concat_vec ( 0b10 ::  2 Word.word)
                                   ((concat_vec ( 0b000 ::  3 Word.word)
                                       ((concat_vec ( 0b001 ::  3 Word.word)
                                           ((concat_vec ( 0x0 ::  4 Word.word) w__19  ::  7 Word.word))
                                          ::  10 Word.word))
                                      ::  13 Word.word))
                                  ::  15 Word.word))
                              ::  16 Word.word))
                          ::  31 Word.word))
                      ::  32 Word.word))
                  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b10000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b001 ::  3 Word.word)))))))
      then
        return ((mips_zero_extend (( 64 :: int)::ii)
                   ((concat_vec ( 0b1 ::  1 Word.word)
                       ((concat_vec TLBIndexMax
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec ( 0b000 ::  3 Word.word)
                                   ((concat_vec ( 0b000 ::  3 Word.word)
                                       ((concat_vec ( 0b000 ::  3 Word.word)
                                           ((concat_vec ( 0b000 ::  3 Word.word)
                                               ((concat_vec ( 0b000 ::  3 Word.word)
                                                   ((concat_vec
                                                       ((bool_to_bits have_cp2  ::  1 Word.word))
                                                       ((concat_vec ( 0b0 ::  1 Word.word)
                                                           ((concat_vec ( 0b0 ::  1 Word.word)
                                                               ((concat_vec ( 0b0 ::  1 Word.word)
                                                                   ((concat_vec ( 0b0 ::  1 Word.word)
                                                                       ((concat_vec
                                                                           ( 0b0 ::  1 Word.word)
                                                                           ( 0b0 ::  1 Word.word)
                                                                          ::  2 Word.word))
                                                                      ::  3 Word.word))
                                                                  ::  4 Word.word))
                                                              ::  5 Word.word))
                                                          ::  6 Word.word))
                                                      ::  7 Word.word))
                                                  ::  10 Word.word))
                                              ::  13 Word.word))
                                          ::  16 Word.word))
                                      ::  19 Word.word))
                                  ::  22 Word.word))
                              ::  25 Word.word))
                          ::  31 Word.word))
                      ::  32 Word.word))
                  ::  64 Word.word))
      else if ((((((b__0 = ( 0b10000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b010 ::  3 Word.word)))))))
      then
        return ((mips_zero_extend (( 64 :: int)::ii)
                   ((concat_vec ( 0b1 ::  1 Word.word)
                       ((concat_vec ( 0b000 ::  3 Word.word)
                           ((concat_vec ( 0x0 ::  4 Word.word)
                               ((concat_vec ( 0x0 ::  4 Word.word)
                                   ((concat_vec ( 0x0 ::  4 Word.word)
                                       ((concat_vec ( 0x0 ::  4 Word.word)
                                           ((concat_vec ( 0x0 ::  4 Word.word)
                                               ((concat_vec ( 0x0 ::  4 Word.word) ( 0x0 ::  4 Word.word)
                                                  ::  8 Word.word))
                                              ::  12 Word.word))
                                          ::  16 Word.word))
                                      ::  20 Word.word))
                                  ::  24 Word.word))
                              ::  28 Word.word))
                          ::  31 Word.word))
                      ::  32 Word.word))
                  ::  64 Word.word))
      else if ((((((b__0 = ( 0b10000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b011 ::  3 Word.word)))))))
      then
        return ( 0x000000000C002000 ::  64 Word.word)
      else if ((((((b__0 = ( 0b10000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b101 ::  3 Word.word)))))))
      then
        return ( 0x0000000000000000 ::  64 Word.word)
      else if ((((((b__0 = ( 0b10000 ::  5 Word.word)))) \<and> (((b__1 = ( 0b110 ::  3 Word.word)))))))
      then
        return ( 0x0000000000000000 ::  64 Word.word)
      else if ((((((b__0 = ( 0b10001 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (read_reg CP0LLAddr_ref  :: ( 64 Word.word) M)
      else if ((((((b__0 = ( 0b10010 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        return ((mips_zero_extend (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))
      else if ((((((b__0 = ( 0b10011 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        return ((mips_zero_extend (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))
      else if ((((((b__0 = ( 0b10100 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        read_reg TLBXContext_ref \<bind> ((\<lambda> (w__21 :: XContextReg) . 
        return ((get_XContextReg_bits w__21  ::  64 Word.word))))
      else if ((((((b__0 = ( 0b11110 ::  5 Word.word)))) \<and> (((b__1 = ( 0b000 ::  3 Word.word)))))))
      then
        (get_CP0ErrorEPC ()   :: ( 64 Word.word) M)
      else (SignalException ResI  :: ( 64 Word.word) M)
   )) \<bind> ((\<lambda> (result :: 64 bits) . 
   wGPR rt
     (if double then result
      else
        (mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  64 Word.word)))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sel  :: "(3)Word.word " 
  and  double  :: " bool "


\<comment> \<open>\<open>val execute_MADDU : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_MADDU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MADDU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mult_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> ((\<lambda> (mul_result :: 64 bits) . 
   (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (let result =
     ((add_vec mul_result
        ((concat_vec ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word))
       ::  64 Word.word)) in
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word))))))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MADD : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_MADD  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_MADD rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mults_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> ((\<lambda> (mul_result :: 64 bits) . 
   (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (let result =
     ((add_vec mul_result
        ((concat_vec ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word))
       ::  64 Word.word)) in
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word))))))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_Load : WordType -> bool -> bool -> mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_Load  :: \<open> WordType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_Load width sign linked base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapper ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word))
      LoadData width
     :: ( 64 Word.word) M) \<bind> ((\<lambda> (vAddr :: 64 bits) . 
   if ((\<not> ((isAddressAligned vAddr width)))) then SignalExceptionBadAddr AdEL vAddr
   else
     (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
     (if linked then
        (write_reg CP0LLBit_ref ( 0b1 ::  1 Word.word) \<then>
        write_reg CP0LLAddr_ref pAddr) \<then>
        (case  width of
          W =>
           (MEMr_reserve_wrapper pAddr (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
           return ((extendLoad w__1 sign  ::  64 Word.word))))
        | D =>
           (MEMr_reserve_wrapper pAddr (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           return ((extendLoad w__2 sign  ::  64 Word.word))))
        | _ => throw (Error_internal_error () )
        )
      else
        (case  width of
          B =>
           (MEMr_wrapper pAddr (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
           return ((extendLoad w__5 sign  ::  64 Word.word))))
        | H =>
           (MEMr_wrapper pAddr (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__6 ::  16 Word.word) . 
           return ((extendLoad w__6 sign  ::  64 Word.word))))
        | W =>
           (MEMr_wrapper pAddr (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
           return ((extendLoad w__7 sign  ::  64 Word.word))))
        | D =>
           (MEMr_wrapper pAddr (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
           return ((extendLoad w__8 sign  ::  64 Word.word))))
        )) \<bind> ((\<lambda> (memResult :: 64 bits) . 
     wGPR rt memResult)))))))))\<close> 
  for  width  :: " WordType " 
  and  sign  :: " bool " 
  and  linked  :: " bool " 
  and  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_LWR : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_LWR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_LWR base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) LoadData WR
     :: (( 64 Word.word * ii)) M) \<bind> ((\<lambda> varstup .  (let (vAddr, size1) = varstup in
   (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> reg_val . 
   (let l__4 = size1 in
   (if (((l__4 = (( 1 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 8 :: int)::ii)  ::  24 Word.word)) w__1
                ::  32 Word.word))))
    else if (((l__4 = (( 2 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) w__2
                ::  32 Word.word))))
    else if (((l__4 = (( 3 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 24 Word.word) M) \<bind> ((\<lambda> (w__3 ::  24 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) w__3
                ::  32 Word.word))))
    else if (((l__4 = (( 4 :: int)::ii)))) then (MEMr_wrapper pAddr size1  :: ( 32 Word.word) M)
    else assert_exp False (''../mips/mips_insts.sail 1360:21 - 1360:22'') \<then> exit0 () ) \<bind> ((\<lambda> (result :: 32
     bits) . 
   wGPR rt ((mips_sign_extend (( 64 :: int)::ii) result  ::  64 Word.word)))))))))))))))\<close> 
  for  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_LWL : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_LWL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_LWL base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) LoadData WL
     :: (( 64 Word.word * ii)) M) \<bind> ((\<lambda> varstup .  (let (vAddr, size1) = varstup in
   (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> reg_val . 
   (let l__0 = size1 in
   (if (((l__0 = (( 4 :: int)::ii)))) then (MEMr_wrapper pAddr size1  :: ( 32 Word.word) M)
    else if (((l__0 = (( 3 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 24 Word.word) M) \<bind> ((\<lambda> (w__2 ::  24 Word.word) . 
      return ((concat_vec w__2 ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))  ::  32 Word.word))))
    else if (((l__0 = (( 2 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
      return ((concat_vec w__3 ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
                ::  32 Word.word))))
    else if (((l__0 = (( 1 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__4 ::  8 Word.word) . 
      return ((concat_vec w__4 ((subrange_vec_dec reg_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
                ::  32 Word.word))))
    else assert_exp False (''../mips/mips_insts.sail 1339:21 - 1339:22'') \<then> exit0 () ) \<bind> ((\<lambda> (result :: 32
     bits) . 
   wGPR rt ((mips_sign_extend (( 64 :: int)::ii) result  ::  64 Word.word)))))))))))))))\<close> 
  for  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_LUI : mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_LUI  :: \<open>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_LUI rt imm = (
   wGPR rt
     ((mips_sign_extend (( 64 :: int)::ii) ((concat_vec imm ( 0x0000 ::  16 Word.word)  ::  32 Word.word))  ::  64 Word.word)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_LDR : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_LDR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_LDR base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) LoadData DR
     :: (( 64 Word.word * ii)) M) \<bind> ((\<lambda> varstup .  (let (vAddr, size1) = varstup in
   (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> reg_val . 
   (let l__24 = size1 in
   (if (((l__24 = (( 1 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 8 :: int)::ii)  ::  56 Word.word)) w__1
                ::  64 Word.word))))
    else if (((l__24 = (( 2 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 16 :: int)::ii)  ::  48 Word.word)) w__2
                ::  64 Word.word))))
    else if (((l__24 = (( 3 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 24 Word.word) M) \<bind> ((\<lambda> (w__3 ::  24 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 24 :: int)::ii)  ::  40 Word.word)) w__3
                ::  64 Word.word))))
    else if (((l__24 = (( 4 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) w__4
                ::  64 Word.word))))
    else if (((l__24 = (( 5 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 40 Word.word) M) \<bind> ((\<lambda> (w__5 ::  40 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 40 :: int)::ii)  ::  24 Word.word)) w__5
                ::  64 Word.word))))
    else if (((l__24 = (( 6 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 48 Word.word) M) \<bind> ((\<lambda> (w__6 ::  48 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 48 :: int)::ii)  ::  16 Word.word)) w__6
                ::  64 Word.word))))
    else if (((l__24 = (( 7 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 56 Word.word) M) \<bind> ((\<lambda> (w__7 ::  56 Word.word) . 
      return ((concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word)) w__7
                ::  64 Word.word))))
    else if (((l__24 = (( 8 :: int)::ii)))) then (MEMr_wrapper pAddr size1  :: ( 64 Word.word) M)
    else assert_exp False (''../mips/mips_insts.sail 1456:21 - 1456:22'') \<then> exit0 () ) \<bind> ((\<lambda> (w__16 ::
      64 Word.word) . 
   wGPR rt w__16)))))))))))))\<close> 
  for  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_LDL : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_LDL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_LDL base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) LoadData DL
     :: (( 64 Word.word * ii)) M) \<bind> ((\<lambda> varstup .  (let (vAddr, size1) = varstup in
   (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> reg_val . 
   (let l__16 = size1 in
   (if (((l__16 = (( 8 :: int)::ii)))) then (MEMr_wrapper pAddr size1  :: ( 64 Word.word) M)
    else if (((l__16 = (( 7 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 56 Word.word) M) \<bind> ((\<lambda> (w__2 ::  56 Word.word) . 
      return ((concat_vec w__2 ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))  ::  64 Word.word))))
    else if (((l__16 = (( 6 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 48 Word.word) M) \<bind> ((\<lambda> (w__3 ::  48 Word.word) . 
      return ((concat_vec w__3 ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
                ::  64 Word.word))))
    else if (((l__16 = (( 5 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 40 Word.word) M) \<bind> ((\<lambda> (w__4 ::  40 Word.word) . 
      return ((concat_vec w__4 ((subrange_vec_dec reg_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
                ::  64 Word.word))))
    else if (((l__16 = (( 4 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      return ((concat_vec w__5 ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))))
    else if (((l__16 = (( 3 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 24 Word.word) M) \<bind> ((\<lambda> (w__6 ::  24 Word.word) . 
      return ((concat_vec w__6 ((subrange_vec_dec reg_val (( 39 :: int)::ii) (( 0 :: int)::ii)  ::  40 Word.word))
                ::  64 Word.word))))
    else if (((l__16 = (( 2 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
      return ((concat_vec w__7 ((subrange_vec_dec reg_val (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
                ::  64 Word.word))))
    else if (((l__16 = (( 1 :: int)::ii)))) then
      (MEMr_wrapper pAddr size1  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__8 ::  8 Word.word) . 
      return ((concat_vec w__8 ((subrange_vec_dec reg_val (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))
                ::  64 Word.word))))
    else assert_exp False (''../mips/mips_insts.sail 1430:21 - 1430:22'') \<then> exit0 () ) \<bind> ((\<lambda> (w__16 ::
      64 Word.word) . 
   wGPR rt w__16)))))))))))))\<close> 
  for  base  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_JR : mword ty5 -> M unit\<close>\<close>

definition execute_JR  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_JR rs = (
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   (rGPR rs  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  execute_branch w__1)))))\<close> 
  for  rs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_JALR : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_JALR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_JALR rs rd = (
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   (rGPR rs  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (execute_branch w__1 \<then>
   (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   wGPR rd ((add_vec_int w__2 (( 8 :: int)::ii)  ::  64 Word.word)))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_JAL : mword ty26 -> M unit\<close>\<close>

definition execute_JAL  :: \<open>(26)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_JAL offset = (
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (execute_branch
     ((concat_vec
         ((subrange_vec_dec ((add_vec_int w__1 (( 4 :: int)::ii)  ::  64 Word.word)) (( 63 :: int)::ii) (( 28 :: int)::ii)  ::  36 Word.word))
         ((concat_vec offset ( 0b00 ::  2 Word.word)  ::  28 Word.word))
        ::  64 Word.word)) \<then>
   (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   wGPR ( 0b11111 ::  5 Word.word) ((add_vec_int w__2 (( 8 :: int)::ii)  ::  64 Word.word)))))))))\<close> 
  for  offset  :: "(26)Word.word "


\<comment> \<open>\<open>val execute_J : mword ty26 -> M unit\<close>\<close>

definition execute_J  :: \<open>(26)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_J offset = (
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   execute_branch
     ((concat_vec
         ((subrange_vec_dec ((add_vec_int w__1 (( 4 :: int)::ii)  ::  64 Word.word)) (( 63 :: int)::ii) (( 28 :: int)::ii)  ::  36 Word.word))
         ((concat_vec offset ( 0b00 ::  2 Word.word)  ::  28 Word.word))
        ::  64 Word.word)))))))\<close> 
  for  offset  :: "(26)Word.word "


\<comment> \<open>\<open>val execute_HCF : unit -> unit\<close>\<close>

definition execute_HCF  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_HCF _ = ( ()  )\<close>


\<comment> \<open>\<open>val execute_ERET : unit -> M unit\<close>\<close>

definition execute_ERET  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_ERET _ = (
   (((checkCP0Access ()  \<then>
   ERETHook () ) \<then>
   write_reg CP0LLBit_ref ( 0b0 ::  1 Word.word)) \<then>
   read_reg CP0Status_ref) \<bind> ((\<lambda> (w__0 :: StatusReg) . 
   if (((((bits_to_bool ((get_StatusReg_ERL w__0  ::  1 Word.word)))) = ((bit_to_bool B1))))) then
     (get_CP0ErrorEPC ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     write_reg NextPC_ref w__1 \<then> set_StatusReg_ERL CP0Status_ref ( 0b0 ::  1 Word.word)))
   else
     (get_CP0EPC ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     write_reg NextPC_ref w__2 \<then> set_StatusReg_EXL CP0Status_ref ( 0b0 ::  1 Word.word))))))\<close>


\<comment> \<open>\<open>val execute_DSUBU : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSUBU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSUBU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((sub_vec w__0 w__1  ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSUB : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSUB  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSUB rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let (temp65 :: 65 bits) =
     ((sub_vec ((mips_sign_extend (( 65 :: int)::ii) w__0  ::  65 Word.word))
        ((mips_sign_extend (( 65 :: int)::ii) w__1  ::  65 Word.word))
       ::  65 Word.word)) in
   if ((neq_bool ((bit_to_bool ((access_vec_dec temp65 (( 64 :: int)::ii)))))
          ((bit_to_bool ((access_vec_dec temp65 (( 63 :: int)::ii))))))) then
     SignalException Ov
   else wGPR rd ((subrange_vec_dec temp65 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSRLV : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSRLV  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSRLV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) in
   (shift_bits_right instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSRL32 : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSRL32  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSRL32 rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   (let sa32 = ((concat_vec ( 0b1 ::  1 Word.word) sa  ::  6 Word.word)) in
   (shift_bits_right instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa32  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSRL : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSRL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSRL rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   (shift_bits_right instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSRAV : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSRAV  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSRAV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) in
   (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSRA32 : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSRA32  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSRA32 rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   (let sa32 = ((concat_vec ( 0b1 ::  1 Word.word) sa  ::  6 Word.word)) in
   (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa32  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSRA : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSRA  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSRA rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> temp . 
   (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSLLV : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSLLV  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSLLV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict w__0 ((subrange_vec_dec w__1 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::
      64 Word.word) . 
   wGPR rd w__2)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSLL32 : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSLL32  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSLL32 rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict w__0 ((concat_vec ( 0b1 ::  1 Word.word) sa  ::  6 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::
      64 Word.word) . 
   wGPR rd w__1)))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DSLL : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DSLL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DSLL rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict w__0 sa  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1)))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DMULTU : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DMULTU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DMULTU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let result = ((mult_vec w__0 w__1  ::  128 Word.word)) in
   write_reg HI_ref ((subrange_vec_dec result (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) \<then>
   write_reg LO_ref ((subrange_vec_dec result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DMULT : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DMULT  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DMULT rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let result = ((mults_vec w__0 w__1  ::  128 Word.word)) in
   write_reg HI_ref ((subrange_vec_dec result (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) \<then>
   write_reg LO_ref ((subrange_vec_dec result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DIVU : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DIVU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DIVU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> (((((NotWordVal rtVal)) \<or> (((rtVal = ( 0x0000000000000000 ::  64 Word.word))))))))))
    then
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return (w__0, w__1)))))
    else
      (let si = (Word.uint ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
      (let ti = (Word.uint ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
      (let qi = (hardware_quot si ti) in
      (let ri = (hardware_mod si ti) in
      return ((to_bits (( 32 :: int)::ii) qi  ::  32 Word.word), (to_bits (( 32 :: int)::ii) ri  ::  32 Word.word))))))) \<bind> ((\<lambda> varstup .  (let (q, r) = varstup in
   write_reg HI_ref ((mips_sign_extend (( 64 :: int)::ii) r  ::  64 Word.word)) \<then>
   write_reg LO_ref ((mips_sign_extend (( 64 :: int)::ii) q  ::  64 Word.word))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DIV : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DIV  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DIV rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> (((((NotWordVal rtVal)) \<or> (((rtVal = ( 0x0000000000000000 ::  64 Word.word))))))))))
    then
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return (w__0, w__1)))))
    else
      (let si = (Word.sint ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
      (let ti = (Word.sint ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
      (let qi = (hardware_quot si ti) in
      (let ri = (si - ((ti * qi))) in
      return ((to_bits (( 32 :: int)::ii) qi  ::  32 Word.word), (to_bits (( 32 :: int)::ii) ri  ::  32 Word.word))))))) \<bind> ((\<lambda> varstup .  (let (q, r) = varstup in
   write_reg HI_ref ((mips_sign_extend (( 64 :: int)::ii) r  ::  64 Word.word)) \<then>
   write_reg LO_ref ((mips_sign_extend (( 64 :: int)::ii) q  ::  64 Word.word))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DDIVU : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DDIVU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DDIVU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rsVal = (Word.uint w__0) in
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let rtVal = (Word.uint w__1) in
   (if (((rtVal = (( 0 :: int)::ii)))) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
      return (w__2, w__3)))))
    else
      (let qi = (hardware_quot rsVal rtVal) in
      (let ri = (hardware_mod rsVal rtVal) in
      return ((to_bits (( 64 :: int)::ii) qi  ::  64 Word.word), (to_bits (( 64 :: int)::ii) ri  ::  64 Word.word))))) \<bind> ((\<lambda> varstup .  (let (q, r) = varstup in
   write_reg LO_ref q \<then> write_reg HI_ref r))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DDIV : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DDIV  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DDIV rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rsVal = (Word.sint w__0) in
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let rtVal = (Word.sint w__1) in
   (if (((rtVal = (( 0 :: int)::ii)))) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
      return (w__2, w__3)))))
    else
      (let qi = (hardware_quot rsVal rtVal) in
      (let ri = (rsVal - ((qi * rtVal))) in
      return ((to_bits (( 64 :: int)::ii) qi  ::  64 Word.word), (to_bits (( 64 :: int)::ii) ri  ::  64 Word.word))))) \<bind> ((\<lambda> varstup .  (let (q, r) = varstup in
   write_reg LO_ref q \<then> write_reg HI_ref r))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DADDU : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DADDU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DADDU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((add_vec w__0 w__1  ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_DADDIU : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_DADDIU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DADDIU rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   wGPR rt ((add_vec w__0 ((mips_sign_extend (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_DADDI : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_DADDI  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DADDI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let (sum65 :: 65 bits) =
     ((add_vec ((mips_sign_extend (( 65 :: int)::ii) w__0  ::  65 Word.word))
        ((mips_sign_extend (( 65 :: int)::ii) imm  ::  65 Word.word))
       ::  65 Word.word)) in
   if ((neq_bool ((bit_to_bool ((access_vec_dec sum65 (( 64 :: int)::ii)))))
          ((bit_to_bool ((access_vec_dec sum65 (( 63 :: int)::ii))))))) then
     SignalException Ov
   else wGPR rt ((subrange_vec_dec sum65 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_DADD : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_DADD  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_DADD rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let (sum65 :: 65 bits) =
     ((add_vec ((mips_sign_extend (( 65 :: int)::ii) w__0  ::  65 Word.word))
        ((mips_sign_extend (( 65 :: int)::ii) w__1  ::  65 Word.word))
       ::  65 Word.word)) in
   if ((neq_bool ((bit_to_bool ((access_vec_dec sum65 (( 64 :: int)::ii)))))
          ((bit_to_bool ((access_vec_dec sum65 (( 63 :: int)::ii))))))) then
     SignalException Ov
   else wGPR rd ((subrange_vec_dec sum65 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_ClearRegs : ClearRegSet -> mword ty16 -> M unit\<close>\<close>

definition execute_ClearRegs  :: \<open> ClearRegSet \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_ClearRegs regset m = (
   (if ((((((regset = CLo))) \<or> (((regset = CHi)))))) then checkCP2usable () 
    else return () ) \<then>
   ((let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 15 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) () 
     ((\<lambda> i unit_var . 
       if ((bit_to_bool ((access_vec_dec m i)))) then
         (case  regset of
           GPLo =>
            wGPR ((to_bits (( 5 :: int)::ii) i  ::  5 Word.word)) ((zeros_implicit (( 64 :: int)::ii) ()   ::  64 Word.word))
         | GPHi =>
            wGPR ((to_bits (( 5 :: int)::ii) ((i + (( 16 :: int)::ii)))  ::  5 Word.word))
              ((zeros_implicit (( 64 :: int)::ii) ()   ::  64 Word.word))
         | CLo =>
            if (((i = (( 0 :: int)::ii)))) then write_reg DDC_ref null_cap
            else writeCapReg ((to_bits (( 5 :: int)::ii) i  ::  5 Word.word)) null_cap
         | CHi => writeCapReg ((to_bits (( 5 :: int)::ii) ((i + (( 16 :: int)::ii)))  ::  5 Word.word)) null_cap
         )
       else return () )))))))\<close> 
  for  regset  :: " ClearRegSet " 
  and  m  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_CWriteHwr : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CWriteHwr  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CWriteHwr cb sel = (
   checkCP2usable ()  \<then>
   ((let l__75 = (Word.uint sel) in
   (if (((l__75 = (( 0 :: int)::ii)))) then return (False, False)
    else if (((l__75 = (( 1 :: int)::ii)))) then return (False, False)
    else if (((l__75 = (( 8 :: int)::ii)))) then return (False, True)
    else if (((l__75 = (( 22 :: int)::ii)))) then return (True, True)
    else if (((l__75 = (( 23 :: int)::ii)))) then return (True, True)
    else if (((l__75 = (( 28 :: int)::ii)))) then return (True, True)
    else if (((l__75 = (( 29 :: int)::ii)))) then return (True, True)
    else if (((l__75 = (( 30 :: int)::ii)))) then return (True, True)
    else if (((l__75 = (( 31 :: int)::ii)))) then return (True, True)
    else SignalException ResI) \<bind> ((\<lambda> varstup .  (let ((needSup :: bool), (needAccessSys :: bool)) = varstup in
   and_boolM (return needAccessSys)
     (pcc_access_system_regs ()  \<bind> ((\<lambda> (w__9 :: bool) .  return ((\<not> w__9))))) \<bind> ((\<lambda> w__10 . 
   if w__10 then raise_c2_exception CapEx_AccessSystemRegsViolation sel
   else
   and_boolM (return needSup)
     (getAccessLevel ()  \<bind> ((\<lambda> (w__11 :: AccessLevel) . 
      return ((\<not> ((grantsAccess w__11 Supervisor))))))) \<bind> ((\<lambda> w__12 . 
   if w__12 then raise_c2_exception CapEx_AccessSystemRegsViolation sel
   else
     readCapReg cb \<bind> ((\<lambda> capVal . 
     (let l__66 = (Word.uint sel) in
     if (((l__66 = (( 0 :: int)::ii)))) then write_reg DDC_ref capVal
     else if (((l__66 = (( 1 :: int)::ii)))) then write_reg CULR_ref capVal
     else if (((l__66 = (( 8 :: int)::ii)))) then write_reg CPLR_ref capVal
     else if (((l__66 = (( 22 :: int)::ii)))) then write_reg KR1C_ref capVal
     else if (((l__66 = (( 23 :: int)::ii)))) then write_reg KR2C_ref capVal
     else if (((l__66 = (( 28 :: int)::ii)))) then write_reg ErrorEPCC_ref capVal
     else if (((l__66 = (( 29 :: int)::ii)))) then write_reg KCC_ref capVal
     else if (((l__66 = (( 30 :: int)::ii)))) then write_reg KDC_ref capVal
     else if (((l__66 = (( 31 :: int)::ii)))) then write_reg EPCC_ref capVal
     else assert_exp False (''CWriteHwr: should be unreachable code'') \<then> exit0 () )))))))))))))\<close> 
  for  cb  :: "(5)Word.word " 
  and  sel  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CUnseal : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CUnseal  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CUnseal cd1 cs ct = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> ((\<lambda> cs_val . 
   (let cs_otype = (Word.uint(Capability_otype   cs_val)) in
   readCapReg ct \<bind> ((\<lambda> ct_val . 
   (let ct_cursor = (getCapCursor ct_val) in
   if ((\<not>(Capability_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
   else if ((\<not>(Capability_tag   ct_val))) then raise_c2_exception CapEx_TagViolation ct
   else if ((\<not>(Capability_sealed   cs_val))) then raise_c2_exception CapEx_SealViolation cs
   else if(Capability_sealed   ct_val) then raise_c2_exception CapEx_SealViolation ct
   else if ((hasReservedOType cs_val)) then raise_c2_exception CapEx_TypeViolation cs
   else if (((ct_cursor \<noteq> cs_otype))) then raise_c2_exception CapEx_TypeViolation ct
   else if ((\<not>(Capability_permit_unseal   ct_val))) then
     raise_c2_exception CapEx_PermitUnsealViolation ct
   else if ((ct_cursor < ((getCapBase ct_val)))) then raise_c2_exception CapEx_LengthViolation ct
   else if ((ct_cursor \<ge> ((getCapTop ct_val)))) then raise_c2_exception CapEx_LengthViolation ct
   else
     writeCapReg cd1
       ( ((unsealCap cs_val)) (|
         Capability_global := ((((Capability_global   cs_val) \<and>(Capability_global   ct_val)))) |)))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CToPtr : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CToPtr  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CToPtr rd cb ct = (
   (checkCP2usable ()  \<then>
   readCapRegDDC ct) \<bind> ((\<lambda> ct_val . 
   readCapReg cb \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   ct_val))) then raise_c2_exception CapEx_TagViolation ct
   else if ((((Capability_tag   cb_val) \<and>(Capability_sealed   cb_val)))) then
     raise_c2_exception CapEx_SealViolation cb
   else
     (let ctBase = (getCapBase ct_val) in
     wGPR rd
       (if ((\<not>(Capability_tag   cb_val))) then (zeros_implicit (( 64 :: int)::ii) ()   ::  64 Word.word)
        else (to_bits (( 64 :: int)::ii) ((((getCapCursor cb_val)) - ctBase))  ::  64 Word.word))))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CTestSubset : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CTestSubset  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CTestSubset rd cb ct = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   readCapReg ct \<bind> ((\<lambda> ct_val . 
   (let ct_top = (getCapTop ct_val) in
   (let ct_base = (getCapBase ct_val) in
   (let ct_perms = ((getCapPerms ct_val  ::  31 Word.word)) in
   (let cb_top = (getCapTop cb_val) in
   (let cb_base = (getCapBase cb_val) in
   (let cb_perms = ((getCapPerms cb_val  ::  31 Word.word)) in
   (let result =
     (if ((neq_bool(Capability_tag   cb_val)(Capability_tag   ct_val))) then ( 0b0 ::  1 Word.word)
     else if ((ct_base < cb_base)) then ( 0b0 ::  1 Word.word)
     else if ((ct_top > cb_top)) then ( 0b0 ::  1 Word.word)
     else if (((((and_vec ct_perms cb_perms  ::  31 Word.word)) \<noteq> ct_perms))) then ( 0b0 ::  1 Word.word)
     else ( 0b1 ::  1 Word.word)) in
   wGPR rd ((mips_zero_extend (( 64 :: int)::ii) result  ::  64 Word.word))))))))))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSub : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CSub  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSub rd cb ct = (
   (checkCP2usable ()  \<then>
   readCapReg ct) \<bind> ((\<lambda> ct_val . 
   readCapReg cb \<bind> ((\<lambda> cb_val . 
   wGPR rd
     ((to_bits (( 64 :: int)::ii) ((((getCapCursor cb_val)) - ((getCapCursor ct_val))))
        ::  64 Word.word)))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CStoreConditional : mword ty5 -> mword ty5 -> mword ty5 -> WordType -> M unit\<close>\<close>

definition execute_CStoreConditional  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> WordType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CStoreConditional rs cb rd width = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_store   cb_val))) then
     raise_c2_exception CapEx_PermitStoreViolation cb
   else
     (let size1 = (wordWidthBytes width) in
     (let vAddr = (getCapCursor cb_val) in
     (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
     if ((((vAddr + size1)) > ((getCapTop cb_val)))) then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if ((\<not> ((isAddressAligned vAddr64 width)))) then SignalExceptionBadAddr AdES vAddr64
     else
       (TLBTranslate vAddr64 StoreData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
       (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs_val . 
       (read_reg CP0LLBit_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
       (if ((bit_to_bool ((access_vec_dec w__0 (( 0 :: int)::ii))))) then
          (case  width of
            B =>
             MEMw_conditional_wrapper pAddr (( 1 :: int)::ii)
               ((subrange_vec_dec rs_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          | H =>
             MEMw_conditional_wrapper pAddr (( 2 :: int)::ii)
               ((subrange_vec_dec rs_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          | W =>
             MEMw_conditional_wrapper pAddr (( 4 :: int)::ii)
               ((subrange_vec_dec rs_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          | D => MEMw_conditional_wrapper pAddr (( 8 :: int)::ii) rs_val
          )
        else return False) \<bind> ((\<lambda> (success :: bool) . 
       wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits success  ::  1 Word.word))  ::  64 Word.word))))))))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  width  :: " WordType "


\<comment> \<open>\<open>val execute_CStore : mword ty5 -> mword ty5 -> mword ty5 -> mword ty8 -> WordType -> M unit\<close>\<close>

definition execute_CStore  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(8)Word.word \<Rightarrow> WordType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CStore rs cb rt offset width = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_store   cb_val))) then
     raise_c2_exception CapEx_PermitStoreViolation cb
   else
     (let size1 = (wordWidthBytes width) in
     (let cursor = (getCapCursor cb_val) in
     (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (let vAddr =
       (((((cursor + ((Word.uint w__0)))) + ((size1 * ((Word.sint offset))))))
         mod
         ((pow2 (( 64 :: int)::ii)))) in
     (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
     if ((((vAddr + size1)) > ((getCapTop cb_val)))) then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if ((\<not> ((isAddressAligned vAddr64 width)))) then SignalExceptionBadAddr AdES vAddr64
     else
       (TLBTranslate vAddr64 StoreData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
       (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs_val . 
       (case  width of
         B => MEMw_wrapper pAddr (( 1 :: int)::ii) ((subrange_vec_dec rs_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
       | H => MEMw_wrapper pAddr (( 2 :: int)::ii) ((subrange_vec_dec rs_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
       | W => MEMw_wrapper pAddr (( 4 :: int)::ii) ((subrange_vec_dec rs_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
       | D => MEMw_wrapper pAddr (( 8 :: int)::ii) rs_val
       ))))))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(8)Word.word " 
  and  width  :: " WordType "


\<comment> \<open>\<open>val execute_CSetOffset : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CSetOffset  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSetOffset cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   if ((((Capability_tag   cb_val) \<and>(Capability_sealed   cb_val)))) then
     raise_c2_exception CapEx_SealViolation cb
   else
     (let (success, newCap) = (setCapOffset cb_val rt_val) in
     if success then writeCapReg cd1 newCap
     else writeCapReg cd1 ((unrepCap newCap))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSetFlags : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CSetFlags  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSetFlags cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   if ((((Capability_tag   cb_val) \<and>(Capability_sealed   cb_val)))) then
     raise_c2_exception CapEx_SealViolation cb
   else
     (let newCap = (setCapFlags cb_val ((vector_truncate rt_val num_flags  ::  1 Word.word))) in
     writeCapReg cd1 newCap))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSetCause : mword ty5 -> M unit\<close>\<close>

definition execute_CSetCause  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSetCause rt = (
   (checkCP2usable ()  \<then>
   pcc_access_system_regs () ) \<bind> ((\<lambda> (w__0 :: bool) . 
   if ((\<not> w__0)) then raise_c2_exception_noreg CapEx_AccessSystemRegsViolation
   else
     (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
     set_CapCauseReg_ExcCode CapCause_ref ((subrange_vec_dec rt_val (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)) \<then>
     set_CapCauseReg_RegNum CapCause_ref ((subrange_vec_dec rt_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))))))\<close> 
  for  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSetCID : mword ty5 -> M unit\<close>\<close>

definition execute_CSetCID  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSetCID cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_set_CID   cb_val))) then
     raise_c2_exception CapEx_PermitSetCIDViolation cb
   else
     (let addr = (getCapCursor cb_val) in
     if ((addr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if ((addr \<ge> ((getCapTop cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else write_reg CID_ref ((to_bits (( 64 :: int)::ii) addr  ::  64 Word.word))))))\<close> 
  for  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSetBoundsImmediate : mword ty5 -> mword ty5 -> mword ty11 -> M unit\<close>\<close>

definition execute_CSetBoundsImmediate  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSetBoundsImmediate cd1 cb imm = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (let immU = (Word.uint imm) in
   (let cursor = (getCapCursor cb_val) in
   (let base = (getCapBase cb_val) in
   (let top1 = (getCapTop cb_val) in
   (let newTop = (cursor + immU) in
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((cursor < base)) then raise_c2_exception CapEx_LengthViolation cb
   else if ((newTop > top1)) then raise_c2_exception CapEx_LengthViolation cb
   else
     (let (_, newCap) =
       (setCapBounds cb_val ((to_bits (( 64 :: int)::ii) cursor  ::  64 Word.word))
         ((to_bits (( 65 :: int)::ii) newTop  ::  65 Word.word))) in
     writeCapReg cd1 newCap)))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  imm  :: "(11)Word.word "


\<comment> \<open>\<open>val execute_CSetBoundsExact : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CSetBoundsExact  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSetBoundsExact cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rt_val = (Word.uint w__0) in
   (let cursor = (getCapCursor cb_val) in
   (let base = (getCapBase cb_val) in
   (let top1 = (getCapTop cb_val) in
   (let newTop = (cursor + rt_val) in
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((cursor < base)) then raise_c2_exception CapEx_LengthViolation cb
   else if ((newTop > top1)) then raise_c2_exception CapEx_LengthViolation cb
   else
     (let (exact, newCap) =
       (setCapBounds cb_val ((to_bits (( 64 :: int)::ii) cursor  ::  64 Word.word))
         ((to_bits (( 65 :: int)::ii) newTop  ::  65 Word.word))) in
     if ((\<not> exact)) then raise_c2_exception CapEx_InexactBounds cb
     else writeCapReg cd1 newCap)))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSetBounds : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CSetBounds  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSetBounds cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rt_val = (Word.uint w__0) in
   (let cursor = (getCapCursor cb_val) in
   (let base = (getCapBase cb_val) in
   (let top1 = (getCapTop cb_val) in
   (let newTop = (cursor + rt_val) in
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((cursor < base)) then raise_c2_exception CapEx_LengthViolation cb
   else if ((newTop > top1)) then raise_c2_exception CapEx_LengthViolation cb
   else
     (let (_, newCap) =
       (setCapBounds cb_val ((to_bits (( 64 :: int)::ii) cursor  ::  64 Word.word))
         ((to_bits (( 65 :: int)::ii) newTop  ::  65 Word.word))) in
     writeCapReg cd1 newCap)))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSetAddr : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CSetAddr  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSetAddr cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   if ((((Capability_tag   cb_val) \<and>(Capability_sealed   cb_val)))) then
     raise_c2_exception CapEx_SealViolation cb
   else
     (let (representable, newCap) = (setCapAddr cb_val rt_val) in
     if representable then writeCapReg cd1 newCap
     else writeCapReg cd1 ((unrepCap newCap))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSealEntry : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CSealEntry  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSealEntry cd1 cs = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> ((\<lambda> cs_val . 
   (let cs_cursor = (getCapCursor cs_val) in
   (let cs_top = (getCapTop cs_val) in
   (let cs_base = (getCapBase cs_val) in
   if ((\<not>(Capability_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
   else if(Capability_sealed   cs_val) then raise_c2_exception CapEx_SealViolation cs
   else if ((\<not>(Capability_permit_execute   cs_val))) then
     raise_c2_exception CapEx_PermitExecuteViolation cs
   else
     (let (success, newCap) = (sealCap cs_val ((to_bits (( 24 :: int)::ii) otype_sentry  ::  24 Word.word))) in
     if ((\<not> success)) then raise_c2_exception CapEx_InexactBounds cs
     else writeCapReg cd1 newCap)))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSeal : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CSeal  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSeal cd1 cs ct = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> ((\<lambda> cs_val . 
   readCapReg ct \<bind> ((\<lambda> ct_val . 
   (let ct_cursor = (getCapCursor ct_val) in
   (let ct_top = (getCapTop ct_val) in
   (let ct_base = (getCapBase ct_val) in
   if ((\<not>(Capability_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
   else if ((\<not>(Capability_tag   ct_val))) then raise_c2_exception CapEx_TagViolation ct
   else if(Capability_sealed   cs_val) then raise_c2_exception CapEx_SealViolation cs
   else if(Capability_sealed   ct_val) then raise_c2_exception CapEx_SealViolation ct
   else if ((\<not>(Capability_permit_seal   ct_val))) then
     raise_c2_exception CapEx_PermitSealViolation ct
   else if ((ct_cursor < ct_base)) then raise_c2_exception CapEx_LengthViolation ct
   else if ((ct_cursor \<ge> ct_top)) then raise_c2_exception CapEx_LengthViolation ct
   else if ((ct_cursor > max_otype)) then raise_c2_exception CapEx_LengthViolation ct
   else
     (let (success, newCap) = (sealCap cs_val ((to_bits (( 24 :: int)::ii) ct_cursor  ::  24 Word.word))) in
     if ((\<not> success)) then raise_c2_exception CapEx_InexactBounds cs
     else writeCapReg cd1 newCap)))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSCC : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CSCC  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSCC cs cb rd = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> ((\<lambda> cs_val . 
   readCapRegDDC cb \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_store   cb_val))) then
     raise_c2_exception CapEx_PermitStoreViolation cb
   else if (((((\<not>(Capability_permit_store_cap   cb_val))) \<and>(Capability_tag   cs_val)))) then
     raise_c2_exception CapEx_PermitStoreCapViolation cb
   else if (((((\<not>(Capability_permit_store_local_cap   cb_val))) \<and> ((((Capability_tag   cs_val) \<and> ((\<not>(Capability_global   cs_val))))))))) then
     raise_c2_exception CapEx_PermitStoreLocalCapViolation cb
   else
     (let vAddr = (getCapCursor cb_val) in
     (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
     if ((((vAddr + cap_size)) > ((getCapTop cb_val)))) then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if (((((vAddr mod cap_size)) \<noteq> (( 0 :: int)::ii)))) then SignalExceptionBadAddr AdES vAddr64
     else
       (TLBTranslateC vAddr64 StoreData  :: (( 64 Word.word * MemAccessCapRestriction)) M) \<bind> ((\<lambda> varstup .  (let (pAddr, macr) = varstup in
       (case  (if (((((bool_to_bit(Capability_tag   cs_val))) = ((bool_to_bit False))))) then
                Unrestricted
              else macr) of
         Trap => raise_c2_exception_badaddr CapEx_TLBNoStoreCap cs vAddr64
       | Clear => return False
       | Unrestricted => return(Capability_tag   cs_val)
       ) \<bind> ((\<lambda> (mtag :: bool) . 
       (read_reg CP0LLBit_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__1 ::  1 Word.word) . 
       (if ((bit_to_bool ((access_vec_dec w__1 (( 0 :: int)::ii))))) then
          MEMw_tagged_conditional pAddr cap_size mtag ((capToMemBits cs_val  ::  128 Word.word))
        else return False) \<bind> ((\<lambda> success . 
       wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits success  ::  1 Word.word))  ::  64 Word.word))))))))))))))))))\<close> 
  for  cs  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSC : mword ty5 -> mword ty5 -> mword ty5 -> mword ty11 -> M unit\<close>\<close>

definition execute_CSC  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CSC cs cb rt offset = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> ((\<lambda> cs_val . 
   readCapRegDDC cb \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_store   cb_val))) then
     raise_c2_exception CapEx_PermitStoreViolation cb
   else if (((((\<not>(Capability_permit_store_cap   cb_val))) \<and>(Capability_tag   cs_val)))) then
     raise_c2_exception CapEx_PermitStoreCapViolation cb
   else if (((((\<not>(Capability_permit_store_local_cap   cb_val))) \<and> ((((Capability_tag   cs_val) \<and> ((\<not>(Capability_global   cs_val))))))))) then
     raise_c2_exception CapEx_PermitStoreLocalCapViolation cb
   else
     (let cursor = (getCapCursor cb_val) in
     (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (let vAddr =
       (((((cursor + ((Word.uint w__0)))) + (((( 16 :: int)::ii) * ((Word.sint offset))))))
         mod
         ((pow2 (( 64 :: int)::ii)))) in
     (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
     if ((((vAddr + cap_size)) > ((getCapTop cb_val)))) then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if (((((vAddr mod cap_size)) \<noteq> (( 0 :: int)::ii)))) then SignalExceptionBadAddr AdES vAddr64
     else
       (TLBTranslateC vAddr64 StoreData  :: (( 64 Word.word * MemAccessCapRestriction)) M) \<bind> ((\<lambda> varstup .  (let (pAddr, macr) = varstup in
       (case  (if (((((bool_to_bit(Capability_tag   cs_val))) = ((bool_to_bit False))))) then
                Unrestricted
              else macr) of
         Unrestricted => return(Capability_tag   cs_val)
       | Clear => return False
       | Trap => raise_c2_exception_badaddr CapEx_TLBNoStoreCap cs vAddr64
       ) \<bind> ((\<lambda> (mtag :: bool) . 
       MEMw_tagged pAddr cap_size mtag ((capToMemBits cs_val  ::  128 Word.word)))))))))))))))))\<close> 
  for  cs  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(11)Word.word "


\<comment> \<open>\<open>val execute_CReturn : unit -> M unit\<close>\<close>

definition execute_CReturn  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CReturn _ = ( checkCP2usable ()  \<then> raise_c2_exception_noreg CapEx_ReturnTrap )\<close>


\<comment> \<open>\<open>val execute_CReadHwr : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CReadHwr  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CReadHwr cd1 sel = (
   checkCP2usable ()  \<then>
   ((let l__57 = (Word.uint sel) in
   (if (((l__57 = (( 0 :: int)::ii)))) then return (False, False)
    else if (((l__57 = (( 1 :: int)::ii)))) then return (False, False)
    else if (((l__57 = (( 8 :: int)::ii)))) then return (False, True)
    else if (((l__57 = (( 22 :: int)::ii)))) then return (True, True)
    else if (((l__57 = (( 23 :: int)::ii)))) then return (True, True)
    else if (((l__57 = (( 28 :: int)::ii)))) then return (True, True)
    else if (((l__57 = (( 29 :: int)::ii)))) then return (True, True)
    else if (((l__57 = (( 30 :: int)::ii)))) then return (True, True)
    else if (((l__57 = (( 31 :: int)::ii)))) then return (True, True)
    else SignalException ResI) \<bind> ((\<lambda> varstup .  (let ((needSup :: bool), (needAccessSys :: bool)) = varstup in
   and_boolM (return needAccessSys)
     (pcc_access_system_regs ()  \<bind> ((\<lambda> (w__9 :: bool) .  return ((\<not> w__9))))) \<bind> ((\<lambda> w__10 . 
   if w__10 then raise_c2_exception CapEx_AccessSystemRegsViolation sel
   else
   and_boolM (return needSup)
     (getAccessLevel ()  \<bind> ((\<lambda> (w__11 :: AccessLevel) . 
      return ((\<not> ((grantsAccess w__11 Supervisor))))))) \<bind> ((\<lambda> w__12 . 
   if w__12 then raise_c2_exception CapEx_AccessSystemRegsViolation sel
   else
     (let l__48 = (Word.uint sel) in
     (if (((l__48 = (( 0 :: int)::ii)))) then read_reg DDC_ref
      else if (((l__48 = (( 1 :: int)::ii)))) then read_reg CULR_ref
      else if (((l__48 = (( 8 :: int)::ii)))) then read_reg CPLR_ref
      else if (((l__48 = (( 22 :: int)::ii)))) then read_reg KR1C_ref
      else if (((l__48 = (( 23 :: int)::ii)))) then read_reg KR2C_ref
      else if (((l__48 = (( 28 :: int)::ii)))) then read_reg ErrorEPCC_ref
      else if (((l__48 = (( 29 :: int)::ii)))) then read_reg KCC_ref
      else if (((l__48 = (( 30 :: int)::ii)))) then read_reg KDC_ref
      else if (((l__48 = (( 31 :: int)::ii)))) then read_reg EPCC_ref
      else assert_exp False (''CReadHwr: should be unreachable code'') \<then> exit0 () ) \<bind> ((\<lambda> (capVal ::
       Capability) . 
     writeCapReg cd1 capVal)))))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  sel  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CRAP : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CRAP  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CRAP rt rs = (
   (checkCP2usable ()  \<then>
   (rGPR rs  :: ( 64 Word.word) M)) \<bind> ((\<lambda> len .  wGPR rt ((getRepresentableLength len  ::  64 Word.word)))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CRAM : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CRAM  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CRAM rt rs = (
   (checkCP2usable ()  \<then>
   (rGPR rs  :: ( 64 Word.word) M)) \<bind> ((\<lambda> len . 
   wGPR rt ((getRepresentableAlignmentMask len  ::  64 Word.word)))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CPtrCmp : mword ty5 -> mword ty5 -> mword ty5 -> CPtrCmpOp -> M unit\<close>\<close>

definition execute_CPtrCmp  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> CPtrCmpOp \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CPtrCmp rd cb ct op1 = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   readCapReg ct \<bind> ((\<lambda> ct_val . 
   (let (equal :: bool) = ((Capability_address   cb_val) =(Capability_address   ct_val)) in
   (let (ltu :: bool) = (zopz0zI_u(Capability_address   cb_val)(Capability_address   ct_val)) in
   (let (lts :: bool) = (zopz0zI_s(Capability_address   cb_val)(Capability_address   ct_val)) in
   (let (cmp :: bool) =
     ((case  op1 of
       CEQ => equal
     | CNE => \<not> equal
     | CLT => lts
     | CLE => (lts \<or> equal)
     | CLTU => ltu
     | CLEU => (ltu \<or> equal)
     | CEXEQ => (cb_val = ct_val)
     | CNEXEQ => (cb_val \<noteq> ct_val)
     )) in
   wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits cmp  ::  1 Word.word))  ::  64 Word.word)))))))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  op1  :: " CPtrCmpOp "


\<comment> \<open>\<open>val execute_CMove : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CMove  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CMove cd1 cb = (
   (checkCP2usable ()  \<then> readCapReg cb) \<bind> ((\<lambda> (w__0 :: Capability) .  writeCapReg cd1 w__0)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CMOVX : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit\<close>\<close>

definition execute_CMOVX  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CMOVX cd1 cb rt ismovn = (
   (checkCP2usable ()  \<then>
   (rGPR rt  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   if ((bits_to_bool
          ((xor_vec
              ((bool_to_bits (((w__0 = ((zeros_implicit (( 64 :: int)::ii) ()   ::  64 Word.word)))))
                 ::  1 Word.word)) ((bool_to_bits ismovn  ::  1 Word.word))
             ::  1 Word.word)))) then
     readCapReg cb \<bind> ((\<lambda> (w__1 :: Capability) .  writeCapReg cd1 w__1))
   else return () )))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  ismovn  :: " bool "


\<comment> \<open>\<open>val execute_CLoadTags : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CLoadTags  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CLoadTags rd cb = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_load   cb_val))) then
     raise_c2_exception CapEx_PermitLoadViolation cb
   else if ((\<not>(Capability_permit_load_cap   cb_val))) then
     raise_c2_exception CapEx_PermitLoadCapViolation cb
   else
     (let vAddr = (getCapCursor cb_val) in
     (let vAddr64 = ((to_bits (( 64 :: int)::ii) ((getCapCursor cb_val))  ::  64 Word.word)) in
     if ((((vAddr + ((caps_per_cacheline * cap_size)))) > ((getCapTop cb_val))))
     then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if ((\<not> (((((vAddr mod ((cap_size * caps_per_cacheline)))) = (( 0 :: int)::ii))))))
     then
       SignalExceptionBadAddr AdEL vAddr64
     else
       (TLBTranslateC vAddr64 LoadData  :: (( 64 Word.word * MemAccessCapRestriction)) M) \<bind> ((\<lambda> varstup .  (let (pAddr, macr) = varstup in
       (case  macr of
         Clear => raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64
       | Trap => raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64
       | Unrestricted =>
          (let (x :: 64 bits) = ((zeros_implicit (( 64 :: int)::ii) ()   ::  64 Word.word)) in
          (let loop_i_lower = ((( 0 :: int)::ii)) in
          (let loop_i_upper = (caps_per_cacheline - (( 1 :: int)::ii)) in
          (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) x
            ((\<lambda> i x . 
              (MEMr_tagged ((add_vec_int pAddr ((i * cap_size))  ::  64 Word.word)) cap_size
                 True
                :: ((bool *  128 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (tag, _) = varstup in
              (let (x :: 64 bits) = ((update_vec_dec x i ((bool_to_bit tag))  ::  64 Word.word)) in
              return x))))))) \<bind> ((\<lambda> (x ::  64 Word.word) . 
          wGPR rd x)))))
       )))))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CLoadLinked : mword ty5 -> mword ty5 -> bool -> WordType -> M unit\<close>\<close>

definition execute_CLoadLinked  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> WordType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CLoadLinked arg0 arg1 arg2 arg3 = (
   (let merge_var = (arg0, arg1, arg2, arg3) in
   (case  merge_var of
     (rd, cb, signext, B) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
      if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(Capability_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let vAddr = (getCapCursor cb_val) in
        (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 1 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 B)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
          (MEMr_reserve_wrapper pAddr (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__0 ::  8 Word.word) . 
          (let (memResult :: 64 bits) = ((extendLoad w__0 signext  ::  64 Word.word)) in
          (write_reg CP0LLBit_ref ( 0b1 ::  1 Word.word) \<then>
          write_reg CP0LLAddr_ref pAddr) \<then> wGPR rd memResult)))))))))
   | (rd, cb, signext, D) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
      if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(Capability_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let vAddr = (getCapCursor cb_val) in
        (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 8 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 D)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
          (MEMr_reserve_wrapper pAddr (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
          (let (memResult :: 64 bits) = ((extendLoad w__0 signext  ::  64 Word.word)) in
          (write_reg CP0LLBit_ref ( 0b1 ::  1 Word.word) \<then>
          write_reg CP0LLAddr_ref pAddr) \<then> wGPR rd memResult)))))))))
   | (rd, cb, signext, H) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
      if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(Capability_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let vAddr = (getCapCursor cb_val) in
        (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 2 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 H)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
          (MEMr_reserve_wrapper pAddr (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__0 ::  16 Word.word) . 
          (let (memResult :: 64 bits) = ((extendLoad w__0 signext  ::  64 Word.word)) in
          (write_reg CP0LLBit_ref ( 0b1 ::  1 Word.word) \<then>
          write_reg CP0LLAddr_ref pAddr) \<then> wGPR rd memResult)))))))))
   | (rd, cb, signext, W) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
      if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(Capability_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let vAddr = (getCapCursor cb_val) in
        (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 4 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 W)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
          (MEMr_reserve_wrapper pAddr (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
          (let (memResult :: 64 bits) = ((extendLoad w__0 signext  ::  64 Word.word)) in
          (write_reg CP0LLBit_ref ( 0b1 ::  1 Word.word) \<then>
          write_reg CP0LLAddr_ref pAddr) \<then> wGPR rd memResult)))))))))
   )))\<close> 
  for  arg0  :: "(5)Word.word " 
  and  arg1  :: "(5)Word.word " 
  and  arg2  :: " bool " 
  and  arg3  :: " WordType "


\<comment> \<open>\<open>val execute_CLoad : mword ty5 -> mword ty5 -> mword ty5 -> mword ty8 -> bool -> WordType -> M unit\<close>\<close>

definition execute_CLoad  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(8)Word.word \<Rightarrow> bool \<Rightarrow> WordType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CLoad arg0 arg1 arg2 arg3 arg4 arg5 = (
   (let merge_var = (arg0, arg1, arg2, arg3, arg4, arg5) in
   (case  merge_var of
     (rd, cb, rt, offset, signext, B) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
      if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(Capability_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let cursor = (getCapCursor cb_val) in
        (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
        (let vAddr =
          (((((cursor + ((Word.uint w__0)))) + (((( 1 :: int)::ii) * ((Word.sint offset))))))
            mod
            (( 18446744073709551616 :: int)::ii)) in
        (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 1 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 B)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
          (MEMr_wrapper pAddr (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
          (let (memResult :: 64 bits) = ((extendLoad w__1 signext  ::  64 Word.word)) in
          wGPR rd memResult))))))))))))
   | (rd, cb, rt, offset, signext, D) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
      if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(Capability_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let cursor = (getCapCursor cb_val) in
        (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
        (let vAddr =
          (((((cursor + ((Word.uint w__0)))) + (((( 8 :: int)::ii) * ((Word.sint offset))))))
            mod
            (( 18446744073709551616 :: int)::ii)) in
        (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 8 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 D)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
          (MEMr_wrapper pAddr (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
          (let (memResult :: 64 bits) = ((extendLoad w__1 signext  ::  64 Word.word)) in
          wGPR rd memResult))))))))))))
   | (rd, cb, rt, offset, signext, H) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
      if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(Capability_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let cursor = (getCapCursor cb_val) in
        (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
        (let vAddr =
          (((((cursor + ((Word.uint w__0)))) + (((( 2 :: int)::ii) * ((Word.sint offset))))))
            mod
            (( 18446744073709551616 :: int)::ii)) in
        (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 2 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 H)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
          (MEMr_wrapper pAddr (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
          (let (memResult :: 64 bits) = ((extendLoad w__1 signext  ::  64 Word.word)) in
          wGPR rd memResult))))))))))))
   | (rd, cb, rt, offset, signext, W) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
      if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(Capability_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let cursor = (getCapCursor cb_val) in
        (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
        (let vAddr =
          (((((cursor + ((Word.uint w__0)))) + (((( 4 :: int)::ii) * ((Word.sint offset))))))
            mod
            (( 18446744073709551616 :: int)::ii)) in
        (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 4 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 W)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
          (MEMr_wrapper pAddr (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          (let (memResult :: 64 bits) = ((extendLoad w__1 signext  ::  64 Word.word)) in
          wGPR rd memResult))))))))))))
   )))\<close> 
  for  arg0  :: "(5)Word.word " 
  and  arg1  :: "(5)Word.word " 
  and  arg2  :: "(5)Word.word " 
  and  arg3  :: "(8)Word.word " 
  and  arg4  :: " bool " 
  and  arg5  :: " WordType "


\<comment> \<open>\<open>val execute_CLLC : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CLLC  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CLLC cd1 cb = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_load   cb_val))) then
     raise_c2_exception CapEx_PermitLoadViolation cb
   else
     (let vAddr = (getCapCursor cb_val) in
     (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
     if ((((vAddr + cap_size)) > ((getCapTop cb_val)))) then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if (((((vAddr mod cap_size)) \<noteq> (( 0 :: int)::ii)))) then SignalExceptionBadAddr AdEL vAddr64
     else
       (TLBTranslateC vAddr64 LoadData  :: (( 64 Word.word * MemAccessCapRestriction)) M) \<bind> ((\<lambda> varstup .  (let (pAddr, macr) = varstup in
       (MEMr_tagged_reserve pAddr cap_size
          ((((Capability_permit_load_cap   cb_val) \<and> ((\<not> (((macr = Clear))))))))
         :: ((bool *  128 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (tag, mem) = varstup in
       if (((tag \<and> (((macr = Trap)))))) then
         raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64
       else
         (let cap = (memBitsToCapability tag mem) in
         (writeCapReg cd1 cap \<then>
         write_reg CP0LLBit_ref ( 0b1 ::  1 Word.word)) \<then> write_reg CP0LLAddr_ref pAddr))))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CLCBI : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_CLCBI  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CLCBI cd1 cb offset = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_load   cb_val))) then
     raise_c2_exception CapEx_PermitLoadViolation cb
   else
     (let cursor = (getCapCursor cb_val) in
     (let vAddr =
       (((cursor + (((( 16 :: int)::ii) * ((Word.sint offset)))))) mod ((pow2 (( 64 :: int)::ii)))) in
     (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
     if ((((vAddr + cap_size)) > ((getCapTop cb_val)))) then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if (((((vAddr mod cap_size)) \<noteq> (( 0 :: int)::ii)))) then SignalExceptionBadAddr AdEL vAddr64
     else
       (TLBTranslateC vAddr64 LoadData  :: (( 64 Word.word * MemAccessCapRestriction)) M) \<bind> ((\<lambda> varstup .  (let (pAddr, macr) = varstup in
       (MEMr_tagged pAddr cap_size
          ((((Capability_permit_load_cap   cb_val) \<and> ((\<not> (((macr = Clear))))))))
         :: ((bool *  128 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (tag, mem) = varstup in
       if (((tag \<and> (((macr = Trap)))))) then
         raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64
       else
         (let cap = (memBitsToCapability tag mem) in
         writeCapReg cd1 cap)))))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_CLC : mword ty5 -> mword ty5 -> mword ty5 -> mword ty11 -> M unit\<close>\<close>

definition execute_CLC  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CLC cd1 cb rt offset = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_load   cb_val))) then
     raise_c2_exception CapEx_PermitLoadViolation cb
   else
     (let cursor = (getCapCursor cb_val) in
     (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (let vAddr =
       (((((cursor + ((Word.uint w__0)))) + (((( 16 :: int)::ii) * ((Word.sint offset))))))
         mod
         ((pow2 (( 64 :: int)::ii)))) in
     (let vAddr64 = ((to_bits (( 64 :: int)::ii) vAddr  ::  64 Word.word)) in
     if ((((vAddr + cap_size)) > ((getCapTop cb_val)))) then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if (((((vAddr mod cap_size)) \<noteq> (( 0 :: int)::ii)))) then SignalExceptionBadAddr AdEL vAddr64
     else
       (TLBTranslateC vAddr64 LoadData  :: (( 64 Word.word * MemAccessCapRestriction)) M) \<bind> ((\<lambda> varstup .  (let (pAddr, macr) = varstup in
       (MEMr_tagged pAddr cap_size
          ((((Capability_permit_load_cap   cb_val) \<and> ((\<not> (((macr = Clear))))))))
         :: ((bool *  128 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (tag, mem) = varstup in
       if (((tag \<and> (((macr = Trap)))))) then
         raise_c2_exception_badaddr CapEx_TLBLoadCap cb vAddr64
       else
         (let cap = (memBitsToCapability tag mem) in
         writeCapReg cd1 cap)))))))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(11)Word.word "


\<comment> \<open>\<open>val execute_CJALR : mword ty5 -> mword ty5 -> bool -> M unit\<close>\<close>

definition execute_CJALR  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CJALR cd1 cb link = (
   (checkCP2usable ()  \<then>
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (let cb_ptr = (getCapCursor cb_val) in
   (let cb_top = (getCapTop cb_val) in
   (let cb_base = (getCapBase cb_val) in
   (let sentry = (isSentryCap cb_val) in
   (if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
    else if ((((Capability_sealed   cb_val) \<and> ((\<not> sentry))))) then
      raise_c2_exception CapEx_SealViolation cb
    else if ((\<not>(Capability_permit_execute   cb_val))) then
      raise_c2_exception CapEx_PermitExecuteViolation cb
    else if ((cb_ptr < cb_base)) then raise_c2_exception CapEx_LengthViolation cb
    else if ((((cb_ptr + (( 4 :: int)::ii))) > cb_top)) then
      raise_c2_exception CapEx_LengthViolation cb
    else if (((((cb_ptr mod (( 4 :: int)::ii))) \<noteq> (( 0 :: int)::ii)))) then SignalException AdEL
    else
      (let (cb_val :: Capability) = (if sentry then unsealCap cb_val else cb_val) in
      (if link then
         read_reg PCC_ref \<bind> ((\<lambda> (w__1 :: Capability) . 
         (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
         (let (success, linkCap) = (setCapOffset w__1 ((add_vec_int w__2 (( 8 :: int)::ii)  ::  64 Word.word))) in
         assert_exp success (''Link cap should always be representable.'') \<then>
         ((let (success2, sealedLink) = (sealCap linkCap ((to_bits (( 24 :: int)::ii) otype_sentry  ::  24 Word.word))) in
         assert_exp success2 (''Sealing should always be possible with current format.'') \<then>
         writeCapReg cd1 sealedLink)))))))
       else return () ) \<then>
      execute_branch_pcc cb_val)) \<then>
   write_reg NextInBranchDelay_ref ( 0b1 ::  1 Word.word))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  link  :: " bool "


\<comment> \<open>\<open>val execute_CIncOffsetImmediate : mword ty5 -> mword ty5 -> mword ty11 -> M unit\<close>\<close>

definition execute_CIncOffsetImmediate  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CIncOffsetImmediate cd1 cb imm = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (let (imm64 :: 64 bits) = ((mips_sign_extend (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   if ((((Capability_tag   cb_val) \<and>(Capability_sealed   cb_val)))) then
     raise_c2_exception CapEx_SealViolation cb
   else
     (let (success, newCap) = (incCapOffset cb_val imm64) in
     if success then writeCapReg cd1 newCap
     else writeCapReg cd1 ((unrepCap newCap)))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  imm  :: "(11)Word.word "


\<comment> \<open>\<open>val execute_CIncOffset : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CIncOffset  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CIncOffset cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   if ((((Capability_tag   cb_val) \<and>(Capability_sealed   cb_val)))) then
     raise_c2_exception CapEx_SealViolation cb
   else
     (let (success, newCap) = (incCapOffset cb_val rt_val) in
     if success then writeCapReg cd1 newCap
     else writeCapReg cd1 ((unrepCap newCap))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetType : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetType  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetType rd cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> capVal . 
   wGPR rd
     (if ((hasReservedOType capVal)) then
        (mips_sign_extend (( 64 :: int)::ii)(Capability_otype   capVal)  ::  64 Word.word)
      else (mips_zero_extend (( 64 :: int)::ii)(Capability_otype   capVal)  ::  64 Word.word)))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetTag : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetTag  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetTag rd cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> capVal . 
   wGPR rd
     ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits(Capability_tag   capVal)  ::  1 Word.word))  ::  64 Word.word)))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetSealed : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetSealed  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetSealed rd cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> capVal . 
   wGPR rd
     ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits(Capability_sealed   capVal)  ::  1 Word.word))  ::  64 Word.word)))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetPerm : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetPerm  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetPerm rd cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> capVal . 
   wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((getCapPerms capVal  ::  31 Word.word))  ::  64 Word.word)))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetPCCSetOffset : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetPCCSetOffset  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetPCCSetOffset cd1 rs = (
   (checkCP2usable ()  \<then>
   (rGPR rs  :: ( 64 Word.word) M)) \<bind> ((\<lambda> rs_val . 
   read_reg PCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   (let (success, newPCC) = (setCapOffset w__0 rs_val) in
   if success then writeCapReg cd1 newPCC
   else writeCapReg cd1 ((unrepCap newPCC))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetPCCSetAddr : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetPCCSetAddr  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetPCCSetAddr cd1 rs = (
   (checkCP2usable ()  \<then>
   (rGPR rs  :: ( 64 Word.word) M)) \<bind> ((\<lambda> rs_val . 
   read_reg PCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   (let (success, newCap) = (setCapAddr w__0 rs_val) in
   if success then writeCapReg cd1 newCap
   else writeCapReg cd1 ((unrepCap newCap))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetPCCIncOffset : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetPCCIncOffset  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetPCCIncOffset cd1 rs = (
   (checkCP2usable ()  \<then>
   (rGPR rs  :: ( 64 Word.word) M)) \<bind> ((\<lambda> rs_val . 
   read_reg PCC_ref \<bind> ((\<lambda> (w__0 :: Capability) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let (success, newCap) = (setCapOffset w__0 ((add_vec w__1 rs_val  ::  64 Word.word))) in
   if success then writeCapReg cd1 newCap
   else writeCapReg cd1 ((unrepCap newCap))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetPCC : mword ty5 -> M unit\<close>\<close>

definition execute_CGetPCC  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetPCC cd1 = (
   (checkCP2usable ()  \<then>
   read_reg PCC_ref) \<bind> ((\<lambda> (w__0 :: Capability) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let (success, pcc) = (setCapOffset w__0 w__1) in
   assert_exp success (''PCC with offset PC should always be representable'') \<then> writeCapReg cd1 pcc))))))\<close> 
  for  cd1  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetOffset : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetOffset  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetOffset rd cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> capVal .  wGPR rd ((to_bits (( 64 :: int)::ii) ((getCapOffset capVal))  ::  64 Word.word)))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetLen : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetLen  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetLen rd cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> capVal . 
   getCapLength capVal \<bind> ((\<lambda> len65 . 
   wGPR rd ((to_bits (( 64 :: int)::ii) (if ((len65 > MAX_U64)) then MAX_U64 else len65)  ::  64 Word.word)))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetFlags : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetFlags  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetFlags rd cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> capVal . 
   wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((getCapFlags capVal  ::  1 Word.word))  ::  64 Word.word)))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetCause : mword ty5 -> M unit\<close>\<close>

definition execute_CGetCause  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetCause rd = (
   (checkCP2usable ()  \<then>
   pcc_access_system_regs () ) \<bind> ((\<lambda> (w__0 :: bool) . 
   if ((\<not> w__0)) then raise_c2_exception_noreg CapEx_AccessSystemRegsViolation
   else
     read_reg CapCause_ref \<bind> ((\<lambda> (w__1 :: CapCauseReg) . 
     wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((get_CapCauseReg_bits w__1  ::  16 Word.word))  ::  64 Word.word)))))))\<close> 
  for  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetCID : mword ty5 -> M unit\<close>\<close>

definition execute_CGetCID  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetCID rd = (
   (checkCP2usable ()  \<then>
   (read_reg CID_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)))\<close> 
  for  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetBase : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetBase  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetBase rd cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> capVal .  wGPR rd ((to_bits (( 64 :: int)::ii) ((getCapBase capVal))  ::  64 Word.word)))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetAndAddr : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetAndAddr  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetAndAddr rd cb rs = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> capVal . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs_val . 
   wGPR rd ((and_vec(Capability_address   capVal) rs_val  ::  64 Word.word)))))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CGetAddr : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CGetAddr  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CGetAddr rd cb = (
   (checkCP2usable ()  \<then> readCapReg cb) \<bind> ((\<lambda> capVal .  wGPR rd(Capability_address   capVal))))\<close> 
  for  rd  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CFromPtr : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CFromPtr  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CFromPtr cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   if (((rt_val = ( 0x0000000000000000 ::  64 Word.word)))) then writeCapReg cd1 null_cap
   else if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else
     (let (success, newCap) = (setCapOffset cb_val rt_val) in
     if success then writeCapReg cd1 newCap
     else writeCapReg cd1 ((unrepCap newCap))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CCopyType : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CCopyType  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CCopyType cd1 cb ct = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   readCapReg ct \<bind> ((\<lambda> ct_val . 
   (let cb_base = (getCapBase cb_val) in
   (let cb_top = (getCapTop cb_val) in
   (let ct_otype = (Word.uint(Capability_otype   ct_val)) in
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if (((((\<not>(Capability_sealed   ct_val))) \<or> ((hasReservedOType ct_val))))) then
     writeCapReg cd1
       ( null_cap (|
         Capability_address := ((mips_sign_extend (( 64 :: int)::ii)(Capability_otype   ct_val)  ::  64 Word.word)) |))
   else if ((ct_otype < cb_base)) then raise_c2_exception CapEx_LengthViolation cb
   else if ((ct_otype \<ge> cb_top)) then raise_c2_exception CapEx_LengthViolation cb
   else
     (let (success, cap) =
       (setCapOffset cb_val ((to_bits (( 64 :: int)::ii) ((ct_otype - cb_base))  ::  64 Word.word))) in
     assert_exp success (''CopyType: offset is in bounds so should be representable'') \<then>
     writeCapReg cd1 cap)))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CClearTags : mword ty5 -> M unit\<close>\<close>

definition execute_CClearTags  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CClearTags cb = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(Capability_permit_store   cb_val))) then
     raise_c2_exception CapEx_PermitStoreViolation cb
   else
     (let vAddr = (getCapCursor cb_val) in
     (let vAddr64 = ((to_bits (( 64 :: int)::ii) ((getCapCursor cb_val))  ::  64 Word.word)) in
     if ((((vAddr + ((caps_per_cacheline * cap_size)))) > ((getCapTop cb_val))))
     then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if ((\<not> (((((vAddr mod ((cap_size * caps_per_cacheline)))) = (( 0 :: int)::ii))))))
     then
       SignalExceptionBadAddr AdEL vAddr64
     else
       (TLBTranslate vAddr64 StoreData  :: ( 64 Word.word) M) \<bind> ((\<lambda> pAddr . 
       (let loop_i_lower = ((( 0 :: int)::ii)) in
       (let loop_i_upper = (caps_per_cacheline - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) () 
         ((\<lambda> i unit_var . 
           (MEMr_tagged ((add_vec_int pAddr ((i * cap_size))  ::  64 Word.word)) cap_size
              False
             :: ((bool *  128 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (_, mem) = varstup in
           MEMw_tagged ((add_vec_int pAddr ((i * cap_size))  ::  64 Word.word)) cap_size False
             mem)))))))))))))))\<close> 
  for  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CClearTag : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CClearTag  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CClearTag cd1 cb = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val .  writeCapReg cd1 ( cb_val (| Capability_tag := False |)))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CCheckType : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CCheckType  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CCheckType cs cb = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> ((\<lambda> cs_val . 
   readCapReg cb \<bind> ((\<lambda> cb_val . 
   if ((\<not>(Capability_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
   else if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if (((((\<not>(Capability_sealed   cs_val))) \<or> ((hasReservedOType cs_val))))) then
     raise_c2_exception CapEx_SealViolation cs
   else if (((((\<not>(Capability_sealed   cb_val))) \<or> ((hasReservedOType cb_val))))) then
     raise_c2_exception CapEx_SealViolation cb
   else if ((((Capability_otype   cs_val) \<noteq>(Capability_otype   cb_val)))) then
     raise_c2_exception CapEx_TypeViolation cs
   else return () )))))\<close> 
  for  cs  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CCheckTag : mword ty5 -> M unit\<close>\<close>

definition execute_CCheckTag  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CCheckTag cs = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> ((\<lambda> cs_val . 
   if ((\<not>(Capability_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
   else return () )))\<close> 
  for  cs  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CCheckPerm : mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CCheckPerm  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CCheckPerm cs rt = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> ((\<lambda> cs_val . 
   (let (cs_perms :: 64 bits) =
     ((mips_zero_extend (( 64 :: int)::ii) ((getCapPerms cs_val  ::  31 Word.word))  ::  64 Word.word)) in
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_perms . 
   if ((\<not>(Capability_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
   else if (((((and_vec cs_perms rt_perms  ::  64 Word.word)) \<noteq> rt_perms))) then
     raise_c2_exception CapEx_UserDefViolation cs
   else return () ))))))\<close> 
  for  cs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CCall : mword ty5 -> mword ty5 -> mword ty11 -> M unit\<close>\<close>

definition execute_CCall  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CCall cs cb b__107 = (
   if (((b__107 = ( 0b00000000000 ::  11 Word.word)))) then
     (checkCP2usable ()  \<then>
     (read_reg InBranchDelay_ref  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
     ((if ((bits_to_bool w__0)) then SignalException ResI
      else return () ) \<then>
     readCapReg cs) \<bind> ((\<lambda> cs_val . 
     readCapReg cb \<bind> ((\<lambda> cb_val . 
     (let cs_cursor = (getCapCursor cs_val) in
     if ((\<not>(Capability_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
     else if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if (((((\<not>(Capability_sealed   cs_val))) \<or> ((hasReservedOType cs_val))))) then
       raise_c2_exception CapEx_SealViolation cs
     else if (((((\<not>(Capability_sealed   cb_val))) \<or> ((hasReservedOType cb_val))))) then
       raise_c2_exception CapEx_SealViolation cb
     else if ((((Capability_otype   cs_val) \<noteq>(Capability_otype   cb_val)))) then
       raise_c2_exception CapEx_TypeViolation cs
     else if ((\<not>(Capability_permit_execute   cs_val))) then
       raise_c2_exception CapEx_PermitExecuteViolation cs
     else if(Capability_permit_execute   cb_val) then
       raise_c2_exception CapEx_PermitExecuteViolation cb
     else if ((cs_cursor < ((getCapBase cs_val)))) then raise_c2_exception CapEx_LengthViolation cs
     else if ((cs_cursor \<ge> ((getCapTop cs_val)))) then
       raise_c2_exception CapEx_LengthViolation cs
     else raise_c2_exception CapEx_CallTrap cs)))))))
   else if (((b__107 = ( 0b00000000001 ::  11 Word.word)))) then
     (checkCP2usable ()  \<then>
     (read_reg InBranchDelay_ref  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  1 Word.word) . 
     ((if ((bits_to_bool w__1)) then SignalException ResI
      else return () ) \<then>
     readCapReg cs) \<bind> ((\<lambda> cs_val . 
     readCapReg cb \<bind> ((\<lambda> cb_val . 
     (let cs_cursor = (getCapCursor cs_val) in
     if ((\<not>(Capability_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
     else if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if ((hasReservedOType cs_val)) then raise_c2_exception CapEx_SealViolation cs
     else if ((hasReservedOType cb_val)) then raise_c2_exception CapEx_SealViolation cb
     else if ((((Capability_otype   cs_val) \<noteq>(Capability_otype   cb_val)))) then
       raise_c2_exception CapEx_TypeViolation cs
     else if ((\<not>(Capability_permit_ccall   cs_val))) then
       raise_c2_exception CapEx_PermitCCallViolation cs
     else if ((\<not>(Capability_permit_ccall   cb_val))) then
       raise_c2_exception CapEx_PermitCCallViolation cb
     else if ((\<not>(Capability_permit_execute   cs_val))) then
       raise_c2_exception CapEx_PermitExecuteViolation cs
     else if(Capability_permit_execute   cb_val) then
       raise_c2_exception CapEx_PermitExecuteViolation cb
     else if ((cs_cursor < ((getCapBase cs_val)))) then raise_c2_exception CapEx_LengthViolation cs
     else if ((cs_cursor \<ge> ((getCapTop cs_val)))) then
       raise_c2_exception CapEx_LengthViolation cs
     else
       (set_next_pcc ((unsealCap cs_val)) \<then>
       write_reg C26_ref ((unsealCap cb_val))) \<then>
       write_reg NextPC_ref ((to_bits (( 64 :: int)::ii) ((getCapOffset cs_val))  ::  64 Word.word)))))))))
   else assert_exp False (''Pattern match failure at ../mips/mips_ri.sail 41:16 - 45:1'') \<then> exit0 ()  )\<close> 
  for  cs  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  b__107  :: "(11)Word.word "


\<comment> \<open>\<open>val execute_CCSeal : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CCSeal  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CCSeal cd1 cs ct = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> ((\<lambda> cs_val . 
   readCapReg ct \<bind> ((\<lambda> ct_val . 
   (let ct_cursor = (getCapCursor ct_val) in
   (let ct_top = (getCapTop ct_val) in
   (let ct_base = (getCapBase ct_val) in
   if ((\<not>(Capability_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
   else if ((((Capability_address   ct_val) = otype_sentry_bits))) then
     if(Capability_sealed   cs_val) then raise_c2_exception CapEx_SealViolation cs
     else if ((\<not>(Capability_permit_execute   cs_val))) then
       raise_c2_exception CapEx_PermitExecuteViolation cs
     else
       (let (success, newCap) = (sealCap cs_val ((to_bits (( 24 :: int)::ii) otype_sentry  ::  24 Word.word))) in
       if ((\<not> success)) then raise_c2_exception CapEx_InexactBounds cs
       else writeCapReg cd1 newCap)
   else if (((((\<not>(Capability_tag   ct_val))) \<or> ((((Capability_address   ct_val) = otype_unsealed_bits)))))) then
     writeCapReg cd1 cs_val
   else if(Capability_sealed   cs_val) then raise_c2_exception CapEx_SealViolation cs
   else if(Capability_sealed   ct_val) then raise_c2_exception CapEx_SealViolation ct
   else if ((\<not>(Capability_permit_seal   ct_val))) then
     raise_c2_exception CapEx_PermitSealViolation ct
   else if ((ct_cursor < ct_base)) then raise_c2_exception CapEx_LengthViolation ct
   else if ((ct_cursor \<ge> ct_top)) then raise_c2_exception CapEx_LengthViolation ct
   else if ((ct_cursor > max_otype)) then raise_c2_exception CapEx_TypeViolation ct
   else
     (let (success, newCap) = (sealCap cs_val ((to_bits (( 24 :: int)::ii) ct_cursor  ::  24 Word.word))) in
     if ((\<not> success)) then raise_c2_exception CapEx_InexactBounds cs
     else writeCapReg cd1 newCap)))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CBuildCap : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CBuildCap  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CBuildCap cd1 cb ct = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> ((\<lambda> cb_val . 
   readCapReg ct \<bind> ((\<lambda> ct_val . 
   (let cb_base = (getCapBase cb_val) in
   (let ct_base = (getCapBase ct_val) in
   (let cb_top = (getCapTop cb_val) in
   (let ct_top = (getCapTop ct_val) in
   (let cb_perms = ((getCapPerms cb_val  ::  31 Word.word)) in
   (let ct_perms = ((getCapPerms ct_val  ::  31 Word.word)) in
   (let ct_offset = (getCapOffset ct_val) in
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((ct_base < cb_base)) then raise_c2_exception CapEx_LengthViolation cb
   else if ((ct_top > cb_top)) then raise_c2_exception CapEx_LengthViolation cb
   else if ((ct_base > ct_top)) then raise_c2_exception CapEx_LengthViolation ct
   else if (((((and_vec ct_perms cb_perms  ::  31 Word.word)) \<noteq> ct_perms))) then
     raise_c2_exception CapEx_UserDefViolation cb
   else
     (let (exact, cd11) =
       (setCapBounds cb_val ((to_bits (( 64 :: int)::ii) ct_base  ::  64 Word.word))
         ((to_bits (( 65 :: int)::ii) ct_top  ::  65 Word.word))) in
     (let (representable, cd2) = (setCapOffset cd11 ((to_bits (( 64 :: int)::ii) ct_offset  ::  64 Word.word))) in
     (let cd3 = (setCapPerms cd2 ct_perms) in
     (assert_exp exact (''CBuildCap: setCapBounds was not exact'') \<then>
     assert_exp representable (''CBuildCap: offset was not representable'')) \<then> writeCapReg cd1 cd3)))))))))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CBZ : mword ty5 -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_CBZ  :: \<open>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CBZ cb imm notzero = (
   (checkCP2usable ()  \<then>
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (if ((bits_to_bool
           ((xor_vec
               ((bool_to_bits
                   ((((Capability_address   cb_val) = ((zeros_implicit (( 64 :: int)::ii) ()   ::  64 Word.word)))))
                  ::  1 Word.word)) ((bool_to_bits notzero  ::  1 Word.word))
              ::  1 Word.word)))) then
      (let (offset :: 64 bits) =
        ((add_vec_int
           ((mips_sign_extend (( 64 :: int)::ii) ((concat_vec imm ( 0b00 ::  2 Word.word)  ::  18 Word.word))
              ::  64 Word.word)) (( 4 :: int)::ii)
          ::  64 Word.word)) in
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      execute_branch ((add_vec w__1 offset  ::  64 Word.word)))))
    else return () ) \<then>
   write_reg NextInBranchDelay_ref ( 0b1 ::  1 Word.word))))))\<close> 
  for  cb  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  notzero  :: " bool "


\<comment> \<open>\<open>val execute_CBX : mword ty5 -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_CBX  :: \<open>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CBX cb imm notset = (
   (checkCP2usable ()  \<then>
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (if ((bits_to_bool
           ((xor_vec ((bool_to_bits(Capability_tag   cb_val)  ::  1 Word.word))
               ((bool_to_bits notset  ::  1 Word.word))
              ::  1 Word.word)))) then
      (let (offset :: 64 bits) =
        ((add_vec_int
           ((mips_sign_extend (( 64 :: int)::ii) ((concat_vec imm ( 0b00 ::  2 Word.word)  ::  18 Word.word))
              ::  64 Word.word)) (( 4 :: int)::ii)
          ::  64 Word.word)) in
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      execute_branch ((add_vec w__1 offset  ::  64 Word.word)))))
    else return () ) \<then>
   write_reg NextInBranchDelay_ref ( 0b1 ::  1 Word.word))))))\<close> 
  for  cb  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  notset  :: " bool "


\<comment> \<open>\<open>val execute_CAndPerm : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CAndPerm  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CAndPerm cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   if ((\<not>(Capability_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(Capability_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else
     (let perms = ((getCapPerms cb_val  ::  31 Word.word)) in
     (let newCap =
       (setCapPerms cb_val
         ((and_vec perms ((subrange_vec_dec rt_val (( 30 :: int)::ii) (( 0 :: int)::ii)  ::  31 Word.word))  ::  31 Word.word))) in
     writeCapReg cd1 newCap)))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CAndAddr : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_CAndAddr  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CAndAddr cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> ((\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> rt_val . 
   if ((((Capability_tag   cb_val) \<and>(Capability_sealed   cb_val)))) then
     raise_c2_exception CapEx_SealViolation cb
   else
     (let newAddr = ((and_vec(Capability_address   cb_val) rt_val  ::  64 Word.word)) in
     (let (representable, newCap) = (setCapAddr cb_val newAddr) in
     if representable then writeCapReg cd1 newCap
     else writeCapReg cd1 ((unrepCap newCap)))))))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CACHE : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_CACHE  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_CACHE base op1 imm = ( checkCP0Access ()  )\<close> 
  for  base  :: "(5)Word.word " 
  and  op1  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_C2Dump : mword ty5 -> unit\<close>\<close>

definition execute_C2Dump  :: \<open>(5)Word.word \<Rightarrow> unit \<close>  where 
     \<open> execute_C2Dump rt = ( ()  )\<close> 
  for  rt  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_BREAK : unit -> M unit\<close>\<close>

definition execute_BREAK  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_BREAK _ = ( SignalException Bp )\<close>


\<comment> \<open>\<open>val execute_BEQ : mword ty5 -> mword ty5 -> mword ty16 -> bool -> bool -> M unit\<close>\<close>

definition execute_BEQ  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_BEQ rs rd imm ne likely = (
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   (rGPR rs  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (rGPR rd  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   if ((bits_to_bool
          ((xor_vec ((bool_to_bits (((w__1 = w__2)))  ::  1 Word.word))
              ((bool_to_bits ne  ::  1 Word.word))
             ::  1 Word.word)))) then
     (let (offset :: 64 bits) =
       ((add_vec_int
          ((mips_sign_extend (( 64 :: int)::ii) ((concat_vec imm ( 0b00 ::  2 Word.word)  ::  18 Word.word))
             ::  64 Word.word)) (( 4 :: int)::ii)
         ::  64 Word.word)) in
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
     execute_branch ((add_vec w__3 offset  ::  64 Word.word)))))
   else if likely then
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
     write_reg NextPC_ref ((add_vec_int w__4 (( 8 :: int)::ii)  ::  64 Word.word))))
   else write_reg NextInBranchDelay_ref ( 0b1 ::  1 Word.word))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  ne  :: " bool " 
  and  likely  :: " bool "


\<comment> \<open>\<open>val execute_BCMPZ : mword ty5 -> mword ty16 -> Comparison -> bool -> bool -> M unit\<close>\<close>

definition execute_BCMPZ  :: \<open>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> Comparison \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_BCMPZ rs imm cmp link likely = (
   (read_reg InBranchDelay_ref  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__0 ::  1 Word.word) . 
   ((if ((bits_to_bool w__0)) then SignalException ResI
    else return () ) \<then>
   (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let linkVal = ((add_vec_int w__1 (( 8 :: int)::ii)  ::  64 Word.word)) in
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> regVal . 
   (let condition = (compare cmp regVal ((mips_zero_extend (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) in
   (if condition then
      (let (offset :: 64 bits) =
        ((add_vec_int
           ((mips_sign_extend (( 64 :: int)::ii) ((concat_vec imm ( 0b00 ::  2 Word.word)  ::  18 Word.word))
              ::  64 Word.word)) (( 4 :: int)::ii)
          ::  64 Word.word)) in
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
      execute_branch ((add_vec w__2 offset  ::  64 Word.word)))))
    else if likely then
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
      write_reg NextPC_ref ((add_vec_int w__3 (( 8 :: int)::ii)  ::  64 Word.word))))
    else write_reg NextInBranchDelay_ref ( 0b1 ::  1 Word.word)) \<then>
   (if link then wGPR ( 0b11111 ::  5 Word.word) linkVal
   else return () ))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  cmp  :: " Comparison " 
  and  link  :: " bool " 
  and  likely  :: " bool "


\<comment> \<open>\<open>val execute_ANDI : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_ANDI  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_ANDI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   wGPR rt ((and_vec w__0 ((mips_zero_extend (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_AND : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_AND  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_AND rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((and_vec w__0 w__1  ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_ADDU : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_ADDU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_ADDU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> opA . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> opB . 
   if (((((NotWordVal opA)) \<or> ((NotWordVal opB))))) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))
   else
     wGPR rd
       ((mips_sign_extend (( 64 :: int)::ii)
           ((add_vec ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
               ((subrange_vec_dec opB (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
              ::  32 Word.word))
          ::  64 Word.word)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_ADDIU : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_ADDIU  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_ADDIU rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> opA . 
   if ((NotWordVal opA)) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rt w__0))
   else
     wGPR rt
       ((mips_sign_extend (( 64 :: int)::ii)
           ((add_vec ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
               ((mips_sign_extend (((((( 31 :: int)::ii) - (( 0 :: int)::ii))) + (( 1 :: int)::ii))) imm
                  ::  32 Word.word))
              ::  32 Word.word))
          ::  64 Word.word)))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_ADDI : mword ty5 -> mword ty5 -> mword ty16 -> M unit\<close>\<close>

definition execute_ADDI  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_ADDI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> opA . 
   if ((NotWordVal opA)) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rt w__0))
   else
     (let (sum33 :: 33 bits) =
       ((add_vec
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word)) ((mips_sign_extend (( 33 :: int)::ii) imm  ::  33 Word.word))
         ::  33 Word.word)) in
     if ((neq_bool ((bit_to_bool ((access_vec_dec sum33 (( 32 :: int)::ii)))))
            ((bit_to_bool ((access_vec_dec sum33 (( 31 :: int)::ii))))))) then
       SignalException Ov
     else
       wGPR rt
         ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec sum33 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  64 Word.word))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_ADD : mword ty5 -> mword ty5 -> mword ty5 -> M unit\<close>\<close>

definition execute_ADD  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_ADD rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> ((\<lambda> (opA :: 64 bits) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> ((\<lambda> (opB :: 64 bits) . 
   if (((((NotWordVal opA)) \<or> ((NotWordVal opB))))) then
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))
   else
     (let (sum33 :: 33 bits) =
       ((add_vec
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word))
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opB (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word))
         ::  33 Word.word)) in
     if ((neq_bool ((bit_to_bool ((access_vec_dec sum33 (( 32 :: int)::ii)))))
            ((bit_to_bool ((access_vec_dec sum33 (( 31 :: int)::ii))))))) then
       SignalException Ov
     else
       wGPR rd
         ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec sum33 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  64 Word.word))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


function (sequential,domintros)  execute  :: \<open> ast \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute (CLCNT ((cd1, cb, rt))) = ( execute (CLC (cd1, cb, rt, (to_bits (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word))))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (DADDIU ((rs, rt, imm))) = ( execute_DADDIU rs rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (DADDU ((rs, rt, rd))) = ( execute_DADDU rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (DADDI ((rs, rt, imm))) = ( execute_DADDI rs rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (DADD ((rs, rt, rd))) = ( execute_DADD rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (ADD ((rs, rt, rd))) = ( execute_ADD rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (ADDI ((rs, rt, imm))) = ( execute_ADDI rs rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (ADDU ((rs, rt, rd))) = ( execute_ADDU rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (ADDIU ((rs, rt, imm))) = ( execute_ADDIU rs rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (DSUBU ((rs, rt, rd))) = ( execute_DSUBU rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (DSUB ((rs, rt, rd))) = ( execute_DSUB rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SUB ((rs, rt, rd))) = ( execute_SUB rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SUBU ((rs, rt, rd))) = ( execute_SUBU rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (AND0 ((rs, rt, rd))) = ( execute_AND rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (ANDI ((rs, rt, imm))) = ( execute_ANDI rs rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (OR0 ((rs, rt, rd))) = ( execute_OR rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (ORI ((rs, rt, imm))) = ( execute_ORI rs rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (NOR ((rs, rt, rd))) = ( execute_NOR rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (XOR0 ((rs, rt, rd))) = ( execute_XOR rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (XORI ((rs, rt, imm))) = ( execute_XORI rs rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (LUI ((rt, imm))) = ( execute_LUI rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (DSLL ((rt, rd, sa))) = ( execute_DSLL rt rd sa )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> execute (DSLL32 ((rt, rd, sa))) = ( execute_DSLL32 rt rd sa )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> execute (DSLLV ((rs, rt, rd))) = ( execute_DSLLV rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (DSRA ((rt, rd, sa))) = ( execute_DSRA rt rd sa )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> execute (DSRA32 ((rt, rd, sa))) = ( execute_DSRA32 rt rd sa )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> execute (DSRAV ((rs, rt, rd))) = ( execute_DSRAV rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (DSRL ((rt, rd, sa))) = ( execute_DSRL rt rd sa )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> execute (DSRL32 ((rt, rd, sa))) = ( execute_DSRL32 rt rd sa )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> execute (DSRLV ((rs, rt, rd))) = ( execute_DSRLV rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SLL ((rt, rd, sa))) = ( execute_SLL rt rd sa )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> execute (SLLV ((rs, rt, rd))) = ( execute_SLLV rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SRA ((rt, rd, sa))) = ( execute_SRA rt rd sa )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> execute (SRAV ((rs, rt, rd))) = ( execute_SRAV rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SRL ((rt, rd, sa))) = ( execute_SRL rt rd sa )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> execute (SRLV ((rs, rt, rd))) = ( execute_SRLV rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SLT ((rs, rt, rd))) = ( execute_SLT rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SLTI ((rs, rt, imm))) = ( execute_SLTI rs rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (SLTU ((rs, rt, rd))) = ( execute_SLTU rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SLTIU ((rs, rt, imm))) = ( execute_SLTIU rs rt imm )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (MOVN ((rs, rt, rd))) = ( execute_MOVN rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (MOVZ ((rs, rt, rd))) = ( execute_MOVZ rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (MFHI (rd)) = ( execute_MFHI rd )\<close> 
  for  rd  :: "(5)Word.word "
|\<open> execute (MFLO (rd)) = ( execute_MFLO rd )\<close> 
  for  rd  :: "(5)Word.word "
|\<open> execute (MTHI (rs)) = ( execute_MTHI rs )\<close> 
  for  rs  :: "(5)Word.word "
|\<open> execute (MTLO (rs)) = ( execute_MTLO rs )\<close> 
  for  rs  :: "(5)Word.word "
|\<open> execute (MUL ((rs, rt, rd))) = ( execute_MUL rs rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (MULT ((rs, rt))) = ( execute_MULT rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (MULTU ((rs, rt))) = ( execute_MULTU rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (DMULT ((rs, rt))) = ( execute_DMULT rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (DMULTU ((rs, rt))) = ( execute_DMULTU rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (MADD ((rs, rt))) = ( execute_MADD rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (MADDU ((rs, rt))) = ( execute_MADDU rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (MSUB ((rs, rt))) = ( execute_MSUB rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (MSUBU ((rs, rt))) = ( execute_MSUBU rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (DIV ((rs, rt))) = ( execute_DIV rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (DIVU ((rs, rt))) = ( execute_DIVU rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (DDIV ((rs, rt))) = ( execute_DDIV rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (DDIVU ((rs, rt))) = ( execute_DDIVU rs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (J (offset)) = ( execute_J offset )\<close> 
  for  offset  :: "(26)Word.word "
|\<open> execute (JAL (offset)) = ( execute_JAL offset )\<close> 
  for  offset  :: "(26)Word.word "
|\<open> execute (JR (rs)) = ( execute_JR rs )\<close> 
  for  rs  :: "(5)Word.word "
|\<open> execute (JALR ((rs, rd))) = ( execute_JALR rs rd )\<close> 
  for  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (BEQ ((rs, rd, imm, ne, likely))) = ( execute_BEQ rs rd imm ne likely )\<close> 
  for  ne  :: " bool " 
  and  likely  :: " bool " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (BCMPZ ((rs, imm, cmp, link, likely))) = ( execute_BCMPZ rs imm cmp link likely )\<close> 
  for  likely  :: " bool " 
  and  link  :: " bool " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  cmp  :: " Comparison "
|\<open> execute (SYSCALL (arg0)) = ( execute_SYSCALL arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (BREAK (arg0)) = ( execute_BREAK arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (WAIT (arg0)) = ( execute_WAIT arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (TRAPREG ((rs, rt, cmp))) = ( execute_TRAPREG rs rt cmp )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  cmp  :: " Comparison "
|\<open> execute (TRAPIMM ((rs, imm, cmp))) = ( execute_TRAPIMM rs imm cmp )\<close> 
  for  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  cmp  :: " Comparison "
|\<open> execute (Load ((width, sign, linked, base, rt, offset))) = ( execute_Load width sign linked base rt offset )\<close> 
  for  linked  :: " bool " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word " 
  and  width  :: " WordType " 
  and  sign  :: " bool "
|\<open> execute (Store ((width, conditional, base, rt, offset))) = (
      execute_Store width conditional base rt offset )\<close> 
  for  conditional  :: " bool " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word " 
  and  width  :: " WordType "
|\<open> execute (LWL ((base, rt, offset))) = ( execute_LWL base rt offset )\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> execute (LWR ((base, rt, offset))) = ( execute_LWR base rt offset )\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> execute (SWL ((base, rt, offset))) = ( execute_SWL base rt offset )\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> execute (SWR ((base, rt, offset))) = ( execute_SWR base rt offset )\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> execute (LDL ((base, rt, offset))) = ( execute_LDL base rt offset )\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> execute (LDR ((base, rt, offset))) = ( execute_LDR base rt offset )\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> execute (SDL ((base, rt, offset))) = ( execute_SDL base rt offset )\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> execute (SDR ((base, rt, offset))) = ( execute_SDR base rt offset )\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> execute (CACHE ((base, op1, imm))) = ( execute_CACHE base op1 imm )\<close> 
  for  op1  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> execute (SYNC (arg0)) = ( execute_SYNC arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (MFC0 ((rt, rd, sel, double))) = ( execute_MFC0 rt rd sel double )\<close> 
  for  sel  :: "(3)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  double  :: " bool "
|\<open> execute (HCF (arg0)) = ( return ((execute_HCF arg0)))\<close> 
  for  arg0  :: " unit "
|\<open> execute (MTC0 ((rt, rd, sel, double))) = ( execute_MTC0 rt rd sel double )\<close> 
  for  sel  :: "(3)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  double  :: " bool "
|\<open> execute (TLBWI (arg0)) = ( execute_TLBWI arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (TLBWR (arg0)) = ( execute_TLBWR arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (TLBR (arg0)) = ( execute_TLBR arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (TLBP (arg0)) = ( execute_TLBP arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (RDHWR ((rt, rd))) = ( execute_RDHWR rt rd )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (ERET (arg0)) = ( execute_ERET arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (CGetPerm ((rd, cb))) = ( execute_CGetPerm rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetFlags ((rd, cb))) = ( execute_CGetFlags rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetType ((rd, cb))) = ( execute_CGetType rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetBase ((rd, cb))) = ( execute_CGetBase rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetOffset ((rd, cb))) = ( execute_CGetOffset rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetLen ((rd, cb))) = ( execute_CGetLen rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetTag ((rd, cb))) = ( execute_CGetTag rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetSealed ((rd, cb))) = ( execute_CGetSealed rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetAddr ((rd, cb))) = ( execute_CGetAddr rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetAndAddr ((rd, cb, rs))) = ( execute_CGetAndAddr rd cb rs )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CGetPCC (cd1)) = ( execute_CGetPCC cd1 )\<close> 
  for  cd1  :: "(5)Word.word "
|\<open> execute (CGetPCCSetOffset ((cd1, rs))) = ( execute_CGetPCCSetOffset cd1 rs )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (CGetPCCIncOffset ((cd1, rs))) = ( execute_CGetPCCIncOffset cd1 rs )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (CGetPCCSetAddr ((cd1, rs))) = ( execute_CGetPCCSetAddr cd1 rs )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (CGetCause (rd)) = ( execute_CGetCause rd )\<close> 
  for  rd  :: "(5)Word.word "
|\<open> execute (CSetCause (rt)) = ( execute_CSetCause rt )\<close> 
  for  rt  :: "(5)Word.word "
|\<open> execute (CGetCID (rd)) = ( execute_CGetCID rd )\<close> 
  for  rd  :: "(5)Word.word "
|\<open> execute (CSetCID (cb)) = ( execute_CSetCID cb )\<close> 
  for  cb  :: "(5)Word.word "
|\<open> execute (CRAP ((rt, rs))) = ( execute_CRAP rt rs )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (CRAM ((rt, rs))) = ( execute_CRAM rt rs )\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> execute (CReadHwr ((cd1, sel))) = ( execute_CReadHwr cd1 sel )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  sel  :: "(5)Word.word "
|\<open> execute (CWriteHwr ((cb, sel))) = ( execute_CWriteHwr cb sel )\<close> 
  for  cb  :: "(5)Word.word " 
  and  sel  :: "(5)Word.word "
|\<open> execute (CAndPerm ((cd1, cb, rt))) = ( execute_CAndPerm cd1 cb rt )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CSetFlags ((cd1, cb, rt))) = ( execute_CSetFlags cd1 cb rt )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CToPtr ((rd, cb, ct))) = ( execute_CToPtr rd cb ct )\<close> 
  for  ct  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CSub ((rd, cb, ct))) = ( execute_CSub rd cb ct )\<close> 
  for  ct  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CPtrCmp ((rd, cb, ct, op1))) = ( execute_CPtrCmp rd cb ct op1 )\<close> 
  for  op1  :: " CPtrCmpOp " 
  and  ct  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CIncOffset ((cd1, cb, rt))) = ( execute_CIncOffset cd1 cb rt )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CIncOffsetImmediate ((cd1, cb, imm))) = ( execute_CIncOffsetImmediate cd1 cb imm )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  imm  :: "(11)Word.word "
|\<open> execute (CSetOffset ((cd1, cb, rt))) = ( execute_CSetOffset cd1 cb rt )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CSetAddr ((cd1, cb, rt))) = ( execute_CSetAddr cd1 cb rt )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CAndAddr ((cd1, cb, rt))) = ( execute_CAndAddr cd1 cb rt )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CSetBounds ((cd1, cb, rt))) = ( execute_CSetBounds cd1 cb rt )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CSetBoundsImmediate ((cd1, cb, imm))) = ( execute_CSetBoundsImmediate cd1 cb imm )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  imm  :: "(11)Word.word "
|\<open> execute (CSetBoundsExact ((cd1, cb, rt))) = ( execute_CSetBoundsExact cd1 cb rt )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CClearTag ((cd1, cb))) = ( execute_CClearTag cd1 cb )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "
|\<open> execute (CMOVX ((cd1, cb, rt, ismovn))) = ( execute_CMOVX cd1 cb rt ismovn )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ismovn  :: " bool " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CMove ((cd1, cb))) = ( execute_CMove cd1 cb )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "
|\<open> execute (ClearRegs ((regset, m))) = ( execute_ClearRegs regset m )\<close> 
  for  regset  :: " ClearRegSet " 
  and  m  :: "(16)Word.word "
|\<open> execute (CFromPtr ((cd1, cb, rt))) = ( execute_CFromPtr cd1 cb rt )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word "
|\<open> execute (CBuildCap ((cd1, cb, ct))) = ( execute_CBuildCap cd1 cb ct )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "
|\<open> execute (CCopyType ((cd1, cb, ct))) = ( execute_CCopyType cd1 cb ct )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "
|\<open> execute (CCheckPerm ((cs, rt))) = ( execute_CCheckPerm cs rt )\<close> 
  for  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> execute (CCheckType ((cs, cb))) = ( execute_CCheckType cs cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> execute (CCheckTag (cs)) = ( execute_CCheckTag cs )\<close> 
  for  cs  :: "(5)Word.word "
|\<open> execute (CTestSubset ((rd, cb, ct))) = ( execute_CTestSubset rd cb ct )\<close> 
  for  ct  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CSeal ((cd1, cs, ct))) = ( execute_CSeal cd1 cs ct )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> execute (CCSeal ((cd1, cs, ct))) = ( execute_CCSeal cd1 cs ct )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> execute (CSealEntry ((cd1, cs))) = ( execute_CSealEntry cd1 cs )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> execute (CUnseal ((cd1, cs, ct))) = ( execute_CUnseal cd1 cs ct )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> execute (CCall ((cs, cb, b__107))) = ( execute_CCall cs cb b__107 )\<close> 
  for  b__107  :: "(11)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> execute (CReturn (arg0)) = ( execute_CReturn arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (CBX ((cb, imm, notset))) = ( execute_CBX cb imm notset )\<close> 
  for  notset  :: " bool " 
  and  cb  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (CBZ ((cb, imm, notzero))) = ( execute_CBZ cb imm notzero )\<close> 
  for  notzero  :: " bool " 
  and  cb  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> execute (CJALR ((cd1, cb, link))) = ( execute_CJALR cd1 cb link )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  link  :: " bool " 
  and  cb  :: "(5)Word.word "
|\<open> execute (CLoad ((rd, cb, rt, offset, signext, arg5))) = ( execute_CLoad rd cb rt offset signext arg5 )\<close> 
  for  arg5  :: " WordType " 
  and  signext  :: " bool " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  offset  :: "(8)Word.word "
|\<open> execute (CLoadLinked ((rd, cb, signext, arg3))) = ( execute_CLoadLinked rd cb signext arg3 )\<close> 
  for  signext  :: " bool " 
  and  arg3  :: " WordType " 
  and  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CLoadTags ((rd, cb))) = ( execute_CLoadTags rd cb )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (CStore ((rs, cb, rt, offset, width))) = ( execute_CStore rs cb rt offset width )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  offset  :: "(8)Word.word " 
  and  width  :: " WordType "
|\<open> execute (CStoreConditional ((rs, cb, rd, width))) = ( execute_CStoreConditional rs cb rd width )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  width  :: " WordType "
|\<open> execute (CSC ((cs, cb, rt, offset))) = ( execute_CSC cs cb rt offset )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(11)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> execute (CSCC ((cs, cb, rd))) = ( execute_CSCC cs cb rd )\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> execute (CLC ((cd1, cb, rt, offset))) = ( execute_CLC cd1 cb rt offset )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(11)Word.word "
|\<open> execute (CLCBI ((cd1, cb, offset))) = ( execute_CLCBI cd1 cb offset )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word "
|\<open> execute (CLLC ((cd1, cb))) = ( execute_CLLC cd1 cb )\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "
|\<open> execute (CClearTags (cb)) = ( execute_CClearTags cb )\<close> 
  for  cb  :: "(5)Word.word "
|\<open> execute (C2Dump (rt)) = ( return ((execute_C2Dump rt)))\<close> 
  for  rt  :: "(5)Word.word "
|\<open> execute (RI (arg0)) = ( execute_RI arg0 )\<close> 
  for  arg0  :: " unit " 
by pat_completeness auto


fun assembly  :: \<open> ast \<Rightarrow> string \<close>  where 
     \<open> assembly (DADDIU ((rs, rt, imm))) = ( (@) (''daddiu '') ((strRRIArgs rs rt imm)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> assembly (DADDU ((rs, rt, rd))) = ( (@) (''daddu '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (DADDI ((rs, rt, imm))) = ( (@) (''daddi '') ((strRRIArgs rs rt imm)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> assembly (DADD ((rs, rt, rd))) = ( (@) (''dadd '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (ADD ((rs, rt, rd))) = ( (@) (''add '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (ADDI ((rs, rt, imm))) = ( (@) (''addi '') ((strRRIArgs rs rt imm)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> assembly (ADDU ((rs, rt, rd))) = ( (@) (''addu '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (ADDIU ((rs, rt, imm))) = ( (@) (''addiu '') ((strRRIArgs rs rt imm)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> assembly (DSUBU ((rs, rt, rd))) = ( (@) (''dsubu '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (DSUB ((rs, rt, rd))) = ( (@) (''dsub '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (SUB ((rs, rt, rd))) = ( (@) (''sub '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (SUBU ((rs, rt, rd))) = ( (@) (''subu '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (AND0 ((rs, rt, rd))) = ( (@) (''and '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (ANDI ((rs, rt, imm))) = ( (@) (''andi '') ((strRRIUArgs rs rt imm)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> assembly (OR0 ((rs, rt, rd))) = ( (@) (''or '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (ORI ((rs, rt, imm))) = ( (@) (''ori '') ((strRRIUArgs rs rt imm)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> assembly (NOR ((rs, rt, rd))) = ( (@) (''nor '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (XOR0 ((rs, rt, rd))) = ( (@) (''xor '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (XORI ((rs, rt, imm))) = ( (@) (''xori '') ((strRRIUArgs rs rt imm)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> assembly (LUI ((rt, imm))) = ( (@) (''lui '') ((strRIArgs rt imm)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> assembly (DSLL ((rs, rd, sa))) = ( (@) (''dsll '') ((strRRIUArgs rs rd sa)))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> assembly (DSLL32 ((rs, rd, sa))) = ( (@) (''dsll32 '') ((strRRIUArgs rs rd sa)))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> assembly (DSLLV ((rs, rt, rd))) = ( (@) (''dsllv '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (DSRA ((rt, rd, sa))) = ( (@) (''dsra '') ((strRRIUArgs rt rd sa)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> assembly (DSRA32 ((rt, rd, sa))) = ( (@) (''dsra32 '') ((strRRIUArgs rt rd sa)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> assembly (DSRAV ((rs, rt, rd))) = ( (@) (''dsrav '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (DSRL ((rt, rd, sa))) = ( (@) (''dsrl '') ((strRRIUArgs rt rd sa)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> assembly (DSRL32 ((rt, rd, sa))) = ( (@) (''dsrl32 '') ((strRRIUArgs rt rd sa)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> assembly (DSRLV ((rs, rt, rd))) = ( (@) (''dsrlv '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (SLL ((rt, rd, sa))) = ( (@) (''sll '') ((strRRIUArgs rt rd sa)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> assembly (SLLV ((rs, rt, rd))) = ( (@) (''sllv '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (SRA ((rt, rd, sa))) = ( (@) (''sra '') ((strRRIUArgs rt rd sa)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> assembly (SRAV ((rs, rt, rd))) = ( (@) (''srav '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (SRL ((rt, rd, sa))) = ( (@) (''srl '') ((strRRIUArgs rt rd sa)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  sa  :: "(5)Word.word "
|\<open> assembly (SRLV ((rs, rt, rd))) = ( (@) (''srlv '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (SLT ((rs, rt, rd))) = ( (@) (''slt '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (SLTI ((rs, rd, imm))) = ( (@) (''slti '') ((strRRIArgs rs rd imm)))\<close> 
  for  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (SLTU ((rs, rt, rd))) = ( (@) (''sltu '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (SLTIU ((rs, rd, imm))) = ( (@) (''sltiu '') ((strRRIUArgs rs rd imm)))\<close> 
  for  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (MOVN ((rs, rt, rd))) = ( (@) (''movn '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (MOVZ ((rs, rt, rd))) = ( (@) (''movz '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (MFHI (rd)) = ( (@) (''mfhi '') ((strReg rd)))\<close> 
  for  rd  :: "(5)Word.word "
|\<open> assembly (MFLO (rd)) = ( (@) (''mflo '') ((strReg rd)))\<close> 
  for  rd  :: "(5)Word.word "
|\<open> assembly (MTHI (rs)) = ( (@) (''mthi '') ((strReg rs)))\<close> 
  for  rs  :: "(5)Word.word "
|\<open> assembly (MTLO (rs)) = ( (@) (''mtlo '') ((strReg rs)))\<close> 
  for  rs  :: "(5)Word.word "
|\<open> assembly (MUL ((rs, rt, rd))) = ( (@) (''mul '') ((strRRRArgs rs rt rd)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (MULT ((rs, rt))) = (
      (@) (''mult '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (MULTU ((rs, rt))) = (
      (@) (''multu '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (DMULT ((rs, rt))) = (
      (@) (''dmult '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (DMULTU ((rs, rt))) = (
      (@) (''dmultu '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (MADD ((rs, rt))) = (
      (@) (''madd '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (MADDU ((rs, rt))) = (
      (@) (''maddu '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (MSUB ((rs, rt))) = (
      (@) (''msub '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (MSUBU ((rs, rt))) = (
      (@) (''msubu '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (DIV ((rs, rt))) = (
      (@) (''div '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (DIVU ((rs, rt))) = (
      (@) (''divu '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (DDIV ((rs, rt))) = (
      (@) (''ddiv '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (DDIVU ((rs, rt))) = (
      (@) (''ddivu '') (((@) ((strReg rs)) (((@) ('', '') ((strReg rt)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (J (offset)) = ( (@) (''j '') ((hex_str ((Word.uint offset)))))\<close> 
  for  offset  :: "(26)Word.word "
|\<open> assembly (JAL (offset)) = ( (@) (''jal '') ((hex_str ((Word.uint offset)))))\<close> 
  for  offset  :: "(26)Word.word "
|\<open> assembly (JR (rs)) = ( (@) (''jr '') ((strReg rs)))\<close> 
  for  rs  :: "(5)Word.word "
|\<open> assembly (JALR ((rs, rd))) = (
      (@) (''jalr '') (((@) ((strReg rd)) (((@) ('', '') ((strReg rs)))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (BEQ ((rs, rt, imm, ne, likely))) = (
      (let op1 = (if ne then (''bne'') else (''beq'')) in
      (let l = (if likely then (''l '') else ('' '')) in
      (@) op1
        (((@) l
            (((@) ((strReg rs))
                (((@) ('', '')
                    (((@) ((strReg rt)) (((@) ('', '') ((hex_str ((Word.sint imm)))))))))))))))))\<close> 
  for  ne  :: " bool " 
  and  likely  :: " bool " 
  and  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word "
|\<open> assembly (BCMPZ ((rs, imm, cmp, link, likely))) = (
      (let op1 = ((@) (''b'') (((@) ((strCmp cmp)) (''z'')))) in
      (let al = (if link then (''al'') else ('''')) in
      (let l = (if likely then (''l '') else ('' '')) in
      (@) op1
        (((@) al
            (((@) l
                (((@) ((strReg rs)) (((@) ('', '') ((hex_str ((Word.sint imm))))))))))))))))\<close> 
  for  likely  :: " bool " 
  and  link  :: " bool " 
  and  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  cmp  :: " Comparison "
|\<open> assembly (SYSCALL (_)) = ( (''syscall''))\<close>
|\<open> assembly (BREAK (_)) = ( (''break''))\<close>
|\<open> assembly (WAIT (_)) = ( (''wait''))\<close>
|\<open> assembly (TRAPREG ((rs, rt, cmp))) = (
      (let op1 = ((@) (''t'') (((@) ((strCmp cmp)) ('' '')))) in
      (@) op1 (((@) ((strReg rs)) (((@) ('', '') ((strReg rt))))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  cmp  :: " Comparison "
|\<open> assembly (TRAPIMM ((rs, imm, cmp))) = (
      (let op1 = ((@) (''t'') (((@) ((strCmp cmp)) (''i '')))) in
      (@) op1 (((@) ((strReg rs)) (((@) ('', '') ((hex_str ((Word.uint imm))))))))))\<close> 
  for  rs  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  cmp  :: " Comparison "
|\<open> assembly (Load ((width, sign, linked, base, rt, offset))) = (
      (let (op1 :: string) =
        ((case  (width, sign, linked) of
          (B, True, False) => (''lb '')
        | (B, False, False) => (''lbu '')
        | (H, True, False) => (''lh '')
        | (H, False, False) => (''lhu '')
        | (W, True, False) => (''lw '')
        | (W, False, False) => (''lwu '')
        | (D, False, False) => (''ld '')
        | (W, True, True) => (''ll '')
        | (D, False, True) => (''lld '')
        | _ => (''invalid load'')
        )) in
      (@) op1 ((strMemArgs base rt offset))))\<close> 
  for  linked  :: " bool " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word " 
  and  width  :: " WordType " 
  and  sign  :: " bool "
|\<open> assembly (Store ((width, conditional, base, rt, offset))) = (
      (let (op1 :: string) =
        (if conditional then (case  width of   W => (''sc'') | D => (''scd'') | _ => (''invalid sc'') )
        else (@) (''s'') ((strWordType width))) in
      (@) op1 (((@) ('' '') ((strMemArgs base rt offset))))))\<close> 
  for  conditional  :: " bool " 
  and  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word " 
  and  width  :: " WordType "
|\<open> assembly (LWL ((base, rt, offset))) = ( (@) (''lwl '') ((strMemArgs base rt offset)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> assembly (LWR ((base, rt, offset))) = ( (@) (''lwr '') ((strMemArgs base rt offset)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> assembly (SWL ((base, rt, offset))) = ( (@) (''swl '') ((strMemArgs base rt offset)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> assembly (SWR ((base, rt, offset))) = ( (@) (''swr '') ((strMemArgs base rt offset)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> assembly (LDL ((base, rt, offset))) = ( (@) (''ldl '') ((strMemArgs base rt offset)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> assembly (LDR ((base, rt, offset))) = ( (@) (''ldr '') ((strMemArgs base rt offset)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> assembly (SDL ((base, rt, offset))) = ( (@) (''sdl '') ((strMemArgs base rt offset)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> assembly (SDR ((base, rt, offset))) = ( (@) (''sdr '') ((strMemArgs base rt offset)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  offset  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> assembly (CACHE ((base, op1, imm))) = ( (@) (''cache '') ((strMemArgs base op1 imm)))\<close> 
  for  op1  :: "(5)Word.word " 
  and  imm  :: "(16)Word.word " 
  and  base  :: "(5)Word.word "
|\<open> assembly (SYNC (_)) = ( (''sync''))\<close>
|\<open> assembly (MFC0 ((rt, rd, sel, double))) = (
      (let op1 = (if double then (''dmfc0 '') else (''mfc0 '')) in
      (@) op1
        (((@) ((strReg rt))
            (((@) ('', '')
                (((@) ((strReg rd)) (((@) ('', $'') ((dec_str ((Word.uint sel))))))))))))))\<close> 
  for  sel  :: "(3)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  double  :: " bool "
|\<open> assembly (MTC0 ((rt, rd, sel, double))) = (
      (let op1 = (if double then (''dmtc0 '') else (''mtc0 '')) in
      (@) op1
        (((@) ((strReg rt))
            (((@) ('', '')
                (((@) ((strReg rd)) (((@) ('', $'') ((dec_str ((Word.uint sel))))))))))))))\<close> 
  for  sel  :: "(3)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  double  :: " bool "
|\<open> assembly (TLBWI (_)) = ( (''tlbwi''))\<close>
|\<open> assembly (TLBWR (_)) = ( (''tlbwr''))\<close>
|\<open> assembly (TLBR (_)) = ( (''tlbr''))\<close>
|\<open> assembly (TLBP (_)) = ( (''tlbp''))\<close>
|\<open> assembly (RDHWR ((rt, rd))) = (
      (@) (''rdhwr'') (((@) ((strReg rt)) (((@) ('', '') ((strReg rd)))))))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (ERET (_)) = ( (''eret''))\<close>
|\<open> assembly (CGetCause (rd)) = ( (@) (''cgetcause '') ((strReg rd)))\<close> 
  for  rd  :: "(5)Word.word "
|\<open> assembly (CSetCause (rs)) = ( (@) (''csetcause '') ((strReg rs)))\<close> 
  for  rs  :: "(5)Word.word "
|\<open> assembly (CGetPCC (cd1)) = ( (@) (''cgetpcc '') ((strCReg cd1)))\<close> 
  for  cd1  :: "(5)Word.word "
|\<open> assembly (CJALR ((b__0, cb, False))) = (
      if (((b__0 = ( 0b00000 ::  5 Word.word)))) then (@) (''cjr '') ((strCReg cb))
      else (''assembly unimplemented''))\<close> 
  for  cb  :: "(5)Word.word " 
  and  b__0  :: "(5)Word.word "
|\<open> assembly (CGetCID (rd)) = ( (@) (''cgetcid '') ((strReg rd)))\<close> 
  for  rd  :: "(5)Word.word "
|\<open> assembly (CSetCID (cb)) = ( (@) (''csetcid '') ((strCReg cb)))\<close> 
  for  cb  :: "(5)Word.word "
|\<open> assembly (CClearTags (cb)) = ( (@) (''ccleartags '') ((strCReg cb)))\<close> 
  for  cb  :: "(5)Word.word "
|\<open> assembly (CCheckPerm ((cs, rt))) = ( (@) (''ccheckperm '') ((strCRArgs cs rt)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CCheckType ((cs, cb))) = ( (@) (''cchecktype '') ((strCCArgs cs cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CClearTag ((cd1, cb))) = ( (@) (''ccleartag '') ((strCCArgs cd1 cb)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "
|\<open> assembly (CMove ((cd1, cs))) = ( (@) (''cmove '') ((strCCArgs cd1 cs)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CJALR ((cd1, cb, True))) = ( (@) (''cjalr '') ((strCCArgs cd1 cb)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "
|\<open> assembly (CSealEntry ((cd1, cb))) = ( (@) (''csealentry '') ((strCCArgs cd1 cb)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word "
|\<open> assembly (CLoadTags ((rd, cb))) = ( (@) (''cloadtags '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetPerm ((rd, cb))) = ( (@) (''cgetperm '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetType ((rd, cb))) = ( (@) (''cgettype '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetBase ((rd, cb))) = ( (@) (''cgetbase '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetLen ((rd, cb))) = ( (@) (''cgetlen '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetTag ((rd, cb))) = ( (@) (''cgettag '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetSealed ((rd, cb))) = ( (@) (''cgetsealed '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetOffset ((rd, cb))) = ( (@) (''cgetoffset '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetPCCSetOffset ((cd1, rs))) = ( (@) (''cgetpccsetoffset '') ((strCRArgs cd1 rs)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (CReadHwr ((cd1, sel))) = ( (@) (''creadhwr '') ((strCRArgs cd1 sel)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  sel  :: "(5)Word.word "
|\<open> assembly (CWriteHwr ((cb, sel))) = ( (@) (''cwritehwr '') ((strCRArgs cb sel)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  sel  :: "(5)Word.word "
|\<open> assembly (CGetAddr ((rd, cb))) = ( (@) (''cgetaddr '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetFlags ((rd, cb))) = ( (@) (''cgetflags '') ((strRCArgs rd cb)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CGetPCCIncOffset ((cd1, rs))) = ( (@) (''cgetpccincoffset '') ((strCRArgs cd1 rs)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (CRAP ((rt, rs))) = ( (@) (''crrl '') ((strRRArgs rt rs)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (CRAM ((rt, rs))) = ( (@) (''cram '') ((strRRArgs rt rs)))\<close> 
  for  rt  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (CSeal ((cd1, cs, ct))) = ( (@) (''cseal '') ((strCCCArgs cd1 cs ct)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CUnseal ((cd1, cs, ct))) = ( (@) (''cunseal '') ((strCCCArgs cd1 cs ct)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CAndPerm ((cd1, cs, rt))) = ( (@) (''candperm '') ((strCCRArgs cd1 cs rt)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CSetOffset ((cd1, cs, rt))) = ( (@) (''csetoffset '') ((strCCRArgs cd1 cs rt)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CSetBounds ((cd1, cs, rt))) = ( (@) (''csetbounds '') ((strCCRArgs cd1 cs rt)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CSetBoundsExact ((cd1, cs, rt))) = ( (@) (''csetboundsexact '') ((strCCRArgs cd1 cs rt)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CSetFlags ((cd1, cs, rt))) = ( (@) (''csetflags '') ((strCCRArgs cd1 cs rt)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CIncOffset ((cd1, cs, rt))) = ( (@) (''cincoffset '') ((strCCRArgs cd1 cs rt)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CBuildCap ((cd1, cs, ct))) = ( (@) (''cbuildcap '') ((strCCCArgs cd1 cs ct)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CCopyType ((cd1, cs, ct))) = ( (@) (''ccopytype '') ((strCCCArgs cd1 cs ct)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CCSeal ((cd1, cs, ct))) = ( (@) (''ccseal '') ((strCCCArgs cd1 cs ct)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  ct  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CToPtr ((rd, cb, ct))) = ( (@) (''ctoptr '') ((strRCRArgs rd cb ct)))\<close> 
  for  ct  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> assembly (CFromPtr ((cd1, cb, rs))) = ( (@) (''cfromptr '') ((strCCRArgs cd1 cb rs)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word "
|\<open> assembly (CSub ((rt, cb, cs))) = ( (@) (''csub '') ((strRCCArgs rt cb cs)))\<close> 
  for  cb  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CMOVX ((cd1, cs, rs, False))) = ( (@) (''cmovz '') ((strCCRArgs cd1 cs rs)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CMOVX ((cd1, cs, rs, True))) = ( (@) (''cmovn '') ((strCCRArgs cd1 cs rs)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CSetAddr ((cd1, cs, rt))) = ( (@) (''csetaddr '') ((strCCRArgs cd1 cs rt)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CGetAndAddr ((rd, cs, rs))) = ( (@) (''cgetandaddr '') ((strRCRArgs rd cs rs)))\<close> 
  for  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CAndAddr ((cd1, cs, rt))) = ( (@) (''candaddr '') ((strCCRArgs cd1 cs rt)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  rt  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CReturn (_)) = ( (''creturn''))\<close>
|\<open> assembly (CCall ((cs, cb, selector))) = ( (@) (''ccall '') ((strCCIUArgs cs cb selector)))\<close> 
  for  selector  :: "(11)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  cs  :: "(5)Word.word "
|\<open> assembly (CIncOffsetImmediate ((cd1, cb, imm))) = ( (@) (''cincoffsetimm '') ((strCCIArgs cd1 cb imm)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  imm  :: "(11)Word.word "
|\<open> assembly (CSetBoundsImmediate ((cd1, cb, imm))) = ( (@) (''csetboundsimm '') ((strCCIUArgs cd1 cb imm)))\<close> 
  for  cd1  :: "(5)Word.word " 
  and  cb  :: "(5)Word.word " 
  and  imm  :: "(11)Word.word "
|\<open> assembly (RI (_)) = ( (''reserved instruction''))\<close>
|\<open> assembly _ = ( (''assembly unimplemented''))\<close>


\<comment> \<open>\<open>val supported_instructions : ast -> maybe ast\<close>\<close>

definition supported_instructions  :: \<open> ast \<Rightarrow>(ast)option \<close>  where 
     \<open> supported_instructions instr = ( Some instr )\<close> 
  for  instr  :: " ast "


\<comment> \<open>\<open>val initialize_registers : unit -> M unit\<close>\<close>

definition initialize_registers  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> initialize_registers _ = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (write_reg PC_ref w__0 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (write_reg NextPC_ref w__1 \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  1 Word.word) . 
   (write_reg TLBProbe_ref w__2 \<then>
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M)) \<bind> ((\<lambda> (w__3 ::  6 Word.word) . 
   (write_reg TLBIndex_ref w__3 \<then>
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M)) \<bind> ((\<lambda> (w__4 ::  6 Word.word) . 
   (write_reg TLBRandom_ref w__4 \<then>
   undefined_TLBEntryLoReg () ) \<bind> ((\<lambda> (w__5 :: TLBEntryLoReg) . 
   (write_reg TLBEntryLo0_ref w__5 \<then>
   undefined_TLBEntryLoReg () ) \<bind> ((\<lambda> (w__6 :: TLBEntryLoReg) . 
   (write_reg TLBEntryLo1_ref w__6 \<then>
   undefined_ContextReg () ) \<bind> ((\<lambda> (w__7 :: ContextReg) . 
   (write_reg TLBContext_ref w__7 \<then>
   (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> ((\<lambda> (w__8 ::  16 Word.word) . 
   (write_reg TLBPageMask_ref w__8 \<then>
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  6 Word.word) . 
   (write_reg TLBWired_ref w__9 \<then>
   undefined_TLBEntryHiReg () ) \<bind> ((\<lambda> (w__10 :: TLBEntryHiReg) . 
   (write_reg TLBEntryHi_ref w__10 \<then>
   undefined_XContextReg () ) \<bind> ((\<lambda> (w__11 :: XContextReg) . 
   (write_reg TLBXContext_ref w__11 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__12 :: TLBEntry) . 
   (write_reg TLBEntry00_ref w__12 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__13 :: TLBEntry) . 
   (write_reg TLBEntry01_ref w__13 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__14 :: TLBEntry) . 
   (write_reg TLBEntry02_ref w__14 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__15 :: TLBEntry) . 
   (write_reg TLBEntry03_ref w__15 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__16 :: TLBEntry) . 
   (write_reg TLBEntry04_ref w__16 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__17 :: TLBEntry) . 
   (write_reg TLBEntry05_ref w__17 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__18 :: TLBEntry) . 
   (write_reg TLBEntry06_ref w__18 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__19 :: TLBEntry) . 
   (write_reg TLBEntry07_ref w__19 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__20 :: TLBEntry) . 
   (write_reg TLBEntry08_ref w__20 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__21 :: TLBEntry) . 
   (write_reg TLBEntry09_ref w__21 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__22 :: TLBEntry) . 
   (write_reg TLBEntry10_ref w__22 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__23 :: TLBEntry) . 
   (write_reg TLBEntry11_ref w__23 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__24 :: TLBEntry) . 
   (write_reg TLBEntry12_ref w__24 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__25 :: TLBEntry) . 
   (write_reg TLBEntry13_ref w__25 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__26 :: TLBEntry) . 
   (write_reg TLBEntry14_ref w__26 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__27 :: TLBEntry) . 
   (write_reg TLBEntry15_ref w__27 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__28 :: TLBEntry) . 
   (write_reg TLBEntry16_ref w__28 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__29 :: TLBEntry) . 
   (write_reg TLBEntry17_ref w__29 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__30 :: TLBEntry) . 
   (write_reg TLBEntry18_ref w__30 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__31 :: TLBEntry) . 
   (write_reg TLBEntry19_ref w__31 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__32 :: TLBEntry) . 
   (write_reg TLBEntry20_ref w__32 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__33 :: TLBEntry) . 
   (write_reg TLBEntry21_ref w__33 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__34 :: TLBEntry) . 
   (write_reg TLBEntry22_ref w__34 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__35 :: TLBEntry) . 
   (write_reg TLBEntry23_ref w__35 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__36 :: TLBEntry) . 
   (write_reg TLBEntry24_ref w__36 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__37 :: TLBEntry) . 
   (write_reg TLBEntry25_ref w__37 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__38 :: TLBEntry) . 
   (write_reg TLBEntry26_ref w__38 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__39 :: TLBEntry) . 
   (write_reg TLBEntry27_ref w__39 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__40 :: TLBEntry) . 
   (write_reg TLBEntry28_ref w__40 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__41 :: TLBEntry) . 
   (write_reg TLBEntry29_ref w__41 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__42 :: TLBEntry) . 
   (write_reg TLBEntry30_ref w__42 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__43 :: TLBEntry) . 
   (write_reg TLBEntry31_ref w__43 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__44 :: TLBEntry) . 
   (write_reg TLBEntry32_ref w__44 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__45 :: TLBEntry) . 
   (write_reg TLBEntry33_ref w__45 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__46 :: TLBEntry) . 
   (write_reg TLBEntry34_ref w__46 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__47 :: TLBEntry) . 
   (write_reg TLBEntry35_ref w__47 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__48 :: TLBEntry) . 
   (write_reg TLBEntry36_ref w__48 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__49 :: TLBEntry) . 
   (write_reg TLBEntry37_ref w__49 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__50 :: TLBEntry) . 
   (write_reg TLBEntry38_ref w__50 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__51 :: TLBEntry) . 
   (write_reg TLBEntry39_ref w__51 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__52 :: TLBEntry) . 
   (write_reg TLBEntry40_ref w__52 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__53 :: TLBEntry) . 
   (write_reg TLBEntry41_ref w__53 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__54 :: TLBEntry) . 
   (write_reg TLBEntry42_ref w__54 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__55 :: TLBEntry) . 
   (write_reg TLBEntry43_ref w__55 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__56 :: TLBEntry) . 
   (write_reg TLBEntry44_ref w__56 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__57 :: TLBEntry) . 
   (write_reg TLBEntry45_ref w__57 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__58 :: TLBEntry) . 
   (write_reg TLBEntry46_ref w__58 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__59 :: TLBEntry) . 
   (write_reg TLBEntry47_ref w__59 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__60 :: TLBEntry) . 
   (write_reg TLBEntry48_ref w__60 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__61 :: TLBEntry) . 
   (write_reg TLBEntry49_ref w__61 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__62 :: TLBEntry) . 
   (write_reg TLBEntry50_ref w__62 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__63 :: TLBEntry) . 
   (write_reg TLBEntry51_ref w__63 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__64 :: TLBEntry) . 
   (write_reg TLBEntry52_ref w__64 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__65 :: TLBEntry) . 
   (write_reg TLBEntry53_ref w__65 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__66 :: TLBEntry) . 
   (write_reg TLBEntry54_ref w__66 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__67 :: TLBEntry) . 
   (write_reg TLBEntry55_ref w__67 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__68 :: TLBEntry) . 
   (write_reg TLBEntry56_ref w__68 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__69 :: TLBEntry) . 
   (write_reg TLBEntry57_ref w__69 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__70 :: TLBEntry) . 
   (write_reg TLBEntry58_ref w__70 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__71 :: TLBEntry) . 
   (write_reg TLBEntry59_ref w__71 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__72 :: TLBEntry) . 
   (write_reg TLBEntry60_ref w__72 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__73 :: TLBEntry) . 
   (write_reg TLBEntry61_ref w__73 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__74 :: TLBEntry) . 
   (write_reg TLBEntry62_ref w__74 \<then>
   undefined_TLBEntry () ) \<bind> ((\<lambda> (w__75 :: TLBEntry) . 
   (write_reg TLBEntry63_ref w__75 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__76 ::  32 Word.word) . 
   (write_reg CP0Compare_ref w__76 \<then>
   undefined_CauseReg () ) \<bind> ((\<lambda> (w__77 :: CauseReg) . 
   (write_reg CP0Cause_ref w__77 \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__78 ::  1 Word.word) . 
   (write_reg CP0LLBit_ref w__78 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__79 ::  64 Word.word) . 
   (write_reg CP0LLAddr_ref w__79 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__80 ::  64 Word.word) . 
   (write_reg CP0BadVAddr_ref w__80 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__81 ::  32 Word.word) . 
   (write_reg CurrentInstrBits_ref w__81 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__82 ::  32 Word.word) . 
   (write_reg LastInstrBits_ref w__82 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__83 ::  32 Word.word) . 
   (write_reg CP0BadInstr_ref w__83 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__84 ::  32 Word.word) . 
   (write_reg CP0BadInstrP_ref w__84 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__85 ::  32 Word.word) . 
   (write_reg CP0Count_ref w__85 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__86 ::  32 Word.word) . 
   (write_reg CP0HWREna_ref w__86 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__87 ::  64 Word.word) . 
   (write_reg CP0UserLocal_ref w__87 \<then>
   (undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M)) \<bind> ((\<lambda> (w__88 ::  3 Word.word) . 
   (write_reg CP0ConfigK0_ref w__88 \<then>
   undefined_StatusReg () ) \<bind> ((\<lambda> (w__89 :: StatusReg) . 
   (write_reg CP0Status_ref w__89 \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__90 ::  1 Word.word) . 
   (write_reg NextInBranchDelay_ref w__90 \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__91 ::  1 Word.word) . 
   (write_reg InBranchDelay_ref w__91 \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__92 ::  1 Word.word) . 
   (write_reg BranchPending_ref w__92 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__93 ::  64 Word.word) . 
   (write_reg DelayedPC_ref w__93 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__94 ::  64 Word.word) . 
   (write_reg HI_ref w__94 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__95 ::  64 Word.word) . 
   (write_reg LO_ref w__95 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__96 ::  64 Word.word) . 
   (undefined_vector (( 32 :: int)::ii) w__96  :: ( ( 64 Word.word)list) M) \<bind> ((\<lambda> (w__97 :: ( 64 Word.word) list) . 
   (write_reg GPR_ref w__97 \<then>
   (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> ((\<lambda> (w__98 ::  8 Word.word) . 
   (write_reg UART_WDATA_ref w__98 \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__99 ::  1 Word.word) . 
   (write_reg UART_WRITTEN_ref w__99 \<then>
   (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> ((\<lambda> (w__100 ::  8 Word.word) . 
   (write_reg UART_RDATA_ref w__100 \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (w__101 ::  1 Word.word) . 
   (write_reg UART_RVALID_ref w__101 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__102 :: Capability) . 
   (write_reg PCC_ref w__102 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__103 :: Capability) . 
   (write_reg NextPCC_ref w__103 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__104 :: Capability) . 
   (write_reg DelayedPCC_ref w__104 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__105 :: Capability) . 
   (write_reg DDC_ref w__105 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__106 :: Capability) . 
   (write_reg C01_ref w__106 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__107 :: Capability) . 
   (write_reg C02_ref w__107 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__108 :: Capability) . 
   (write_reg C03_ref w__108 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__109 :: Capability) . 
   (write_reg C04_ref w__109 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__110 :: Capability) . 
   (write_reg C05_ref w__110 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__111 :: Capability) . 
   (write_reg C06_ref w__111 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__112 :: Capability) . 
   (write_reg C07_ref w__112 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__113 :: Capability) . 
   (write_reg C08_ref w__113 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__114 :: Capability) . 
   (write_reg C09_ref w__114 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__115 :: Capability) . 
   (write_reg C10_ref w__115 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__116 :: Capability) . 
   (write_reg C11_ref w__116 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__117 :: Capability) . 
   (write_reg C12_ref w__117 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__118 :: Capability) . 
   (write_reg C13_ref w__118 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__119 :: Capability) . 
   (write_reg C14_ref w__119 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__120 :: Capability) . 
   (write_reg C15_ref w__120 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__121 :: Capability) . 
   (write_reg C16_ref w__121 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__122 :: Capability) . 
   (write_reg C17_ref w__122 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__123 :: Capability) . 
   (write_reg C18_ref w__123 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__124 :: Capability) . 
   (write_reg C19_ref w__124 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__125 :: Capability) . 
   (write_reg C20_ref w__125 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__126 :: Capability) . 
   (write_reg C21_ref w__126 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__127 :: Capability) . 
   (write_reg C22_ref w__127 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__128 :: Capability) . 
   (write_reg C23_ref w__128 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__129 :: Capability) . 
   (write_reg C24_ref w__129 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__130 :: Capability) . 
   (write_reg C25_ref w__130 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__131 :: Capability) . 
   (write_reg C26_ref w__131 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__132 :: Capability) . 
   (write_reg C27_ref w__132 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__133 :: Capability) . 
   (write_reg C28_ref w__133 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__134 :: Capability) . 
   (write_reg C29_ref w__134 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__135 :: Capability) . 
   (write_reg C30_ref w__135 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__136 :: Capability) . 
   (write_reg C31_ref w__136 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__137 :: Capability) . 
   (write_reg CULR_ref w__137 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__138 :: Capability) . 
   (write_reg CPLR_ref w__138 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__139 :: Capability) . 
   (write_reg KR1C_ref w__139 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__140 :: Capability) . 
   (write_reg KR2C_ref w__140 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__141 :: Capability) . 
   (write_reg KCC_ref w__141 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__142 :: Capability) . 
   (write_reg KDC_ref w__142 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__143 :: Capability) . 
   (write_reg EPCC_ref w__143 \<then>
   undefined_Capability () ) \<bind> ((\<lambda> (w__144 :: Capability) . 
   (write_reg ErrorEPCC_ref w__144 \<then>
   undefined_CapCauseReg () ) \<bind> ((\<lambda> (w__145 :: CapCauseReg) . 
   (write_reg CapCause_ref w__145 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__146 ::  64 Word.word) . 
   write_reg CID_ref w__146)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\<close>


definition initial_CauseReg  :: \<open> CauseReg \<close>  where 
     \<open> initial_CauseReg = ( (| CauseReg_bits = (( 0x00000000 ::  32 Word.word)) |) )\<close>


definition initial_TLBEntryLoReg  :: \<open> TLBEntryLoReg \<close>  where 
     \<open> initial_TLBEntryLoReg = (
  (| TLBEntryLoReg_bits = (( 0x0000000000000000 ::  64 Word.word)) |) )\<close>


definition initial_TLBEntryHiReg  :: \<open> TLBEntryHiReg \<close>  where 
     \<open> initial_TLBEntryHiReg = (
  (| TLBEntryHiReg_bits = (( 0x0000000000000000 ::  64 Word.word)) |) )\<close>


definition initial_ContextReg  :: \<open> ContextReg \<close>  where 
     \<open> initial_ContextReg = ( (| ContextReg_bits = (( 0x0000000000000000 ::  64 Word.word)) |) )\<close>


definition initial_XContextReg  :: \<open> XContextReg \<close>  where 
     \<open> initial_XContextReg = ( (| XContextReg_bits = (( 0x0000000000000000 ::  64 Word.word)) |) )\<close>


definition initial_TLBEntry  :: \<open> TLBEntry \<close>  where 
     \<open> initial_TLBEntry = (
  (| TLBEntry_bits =
       (( 0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 ::  119 Word.word)) |) )\<close>


definition initial_StatusReg  :: \<open> StatusReg \<close>  where 
     \<open> initial_StatusReg = ( (| StatusReg_bits = (( 0x00000000 ::  32 Word.word)) |) )\<close>


definition initial_Capability  :: \<open> Capability \<close>  where 
     \<open> initial_Capability = (
  (| Capability_tag = False, 
     Capability_uperms = (( 0x0 ::  4 Word.word)), 
     Capability_permit_set_CID = False, 
     Capability_access_system_regs = False, 
     Capability_permit_unseal = False, 
     Capability_permit_ccall = False, 
     Capability_permit_seal = False, 
     Capability_permit_store_local_cap = False, 
     Capability_permit_store_cap = False, 
     Capability_permit_load_cap = False, 
     Capability_permit_store = False, 
     Capability_permit_load = False, 
     Capability_permit_execute = False, 
     Capability_global = False, 
     Capability_reserved = (( 0b000 ::  3 Word.word)), 
     Capability_internal_e = False, 
     Capability_E = (( 0b000000 ::  6 Word.word)), 
     Capability_sealed = False, 
     Capability_B = (( 0b00000000000000 ::  14 Word.word)), 
     Capability_T = (( 0b00000000000000 ::  14 Word.word)), 
     Capability_otype = (( 0b000000000000000000 ::  18 Word.word)), 
     Capability_address = (( 0x0000000000000000 ::  64 Word.word)) |) )\<close>


definition initial_CapCauseReg  :: \<open> CapCauseReg \<close>  where 
     \<open> initial_CapCauseReg = ( (| CapCauseReg_bits = (( 0x0000 ::  16 Word.word)) |) )\<close>


definition initial_regstate  :: \<open> regstate \<close>  where 
     \<open> initial_regstate = (
  (| CID = (( 0x0000000000000000 ::  64 Word.word)), 
     CapCause = initial_CapCauseReg, 
     ErrorEPCC = initial_Capability, 
     EPCC = initial_Capability, 
     KDC = initial_Capability, 
     KCC = initial_Capability, 
     KR2C = initial_Capability, 
     KR1C = initial_Capability, 
     CPLR = initial_Capability, 
     CULR = initial_Capability, 
     C31 = initial_Capability, 
     C30 = initial_Capability, 
     C29 = initial_Capability, 
     C28 = initial_Capability, 
     C27 = initial_Capability, 
     C26 = initial_Capability, 
     C25 = initial_Capability, 
     C24 = initial_Capability, 
     C23 = initial_Capability, 
     C22 = initial_Capability, 
     C21 = initial_Capability, 
     C20 = initial_Capability, 
     C19 = initial_Capability, 
     C18 = initial_Capability, 
     C17 = initial_Capability, 
     C16 = initial_Capability, 
     C15 = initial_Capability, 
     C14 = initial_Capability, 
     C13 = initial_Capability, 
     C12 = initial_Capability, 
     C11 = initial_Capability, 
     C10 = initial_Capability, 
     C09 = initial_Capability, 
     C08 = initial_Capability, 
     C07 = initial_Capability, 
     C06 = initial_Capability, 
     C05 = initial_Capability, 
     C04 = initial_Capability, 
     C03 = initial_Capability, 
     C02 = initial_Capability, 
     C01 = initial_Capability, 
     DDC = initial_Capability, 
     DelayedPCC = initial_Capability, 
     NextPCC = initial_Capability, 
     PCC = initial_Capability, 
     UART_RVALID = (( 0b0 ::  1 Word.word)), 
     UART_RDATA = (( 0x00 ::  8 Word.word)), 
     UART_WRITTEN = (( 0b0 ::  1 Word.word)), 
     UART_WDATA = (( 0x00 ::  8 Word.word)), 
     GPR =
       ([( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word),
         ( 0x0000000000000000 ::  64 Word.word),( 0x0000000000000000 ::  64 Word.word)]), 
     LO = (( 0x0000000000000000 ::  64 Word.word)), 
     HI = (( 0x0000000000000000 ::  64 Word.word)), 
     DelayedPC = (( 0x0000000000000000 ::  64 Word.word)), 
     BranchPending = (( 0b0 ::  1 Word.word)), 
     InBranchDelay = (( 0b0 ::  1 Word.word)), 
     NextInBranchDelay = (( 0b0 ::  1 Word.word)), 
     CP0Status = initial_StatusReg, 
     CP0ConfigK0 = (( 0b000 ::  3 Word.word)), 
     CP0UserLocal = (( 0x0000000000000000 ::  64 Word.word)), 
     CP0HWREna = (( 0x00000000 ::  32 Word.word)), 
     CP0Count = (( 0x00000000 ::  32 Word.word)), 
     CP0BadInstrP = (( 0x00000000 ::  32 Word.word)), 
     CP0BadInstr = (( 0x00000000 ::  32 Word.word)), 
     LastInstrBits = (( 0x00000000 ::  32 Word.word)), 
     CurrentInstrBits = (( 0x00000000 ::  32 Word.word)), 
     CP0BadVAddr = (( 0x0000000000000000 ::  64 Word.word)), 
     CP0LLAddr = (( 0x0000000000000000 ::  64 Word.word)), 
     CP0LLBit = (( 0b0 ::  1 Word.word)), 
     CP0Cause = initial_CauseReg, 
     CP0Compare = (( 0x00000000 ::  32 Word.word)), 
     TLBEntry63 = initial_TLBEntry, 
     TLBEntry62 = initial_TLBEntry, 
     TLBEntry61 = initial_TLBEntry, 
     TLBEntry60 = initial_TLBEntry, 
     TLBEntry59 = initial_TLBEntry, 
     TLBEntry58 = initial_TLBEntry, 
     TLBEntry57 = initial_TLBEntry, 
     TLBEntry56 = initial_TLBEntry, 
     TLBEntry55 = initial_TLBEntry, 
     TLBEntry54 = initial_TLBEntry, 
     TLBEntry53 = initial_TLBEntry, 
     TLBEntry52 = initial_TLBEntry, 
     TLBEntry51 = initial_TLBEntry, 
     TLBEntry50 = initial_TLBEntry, 
     TLBEntry49 = initial_TLBEntry, 
     TLBEntry48 = initial_TLBEntry, 
     TLBEntry47 = initial_TLBEntry, 
     TLBEntry46 = initial_TLBEntry, 
     TLBEntry45 = initial_TLBEntry, 
     TLBEntry44 = initial_TLBEntry, 
     TLBEntry43 = initial_TLBEntry, 
     TLBEntry42 = initial_TLBEntry, 
     TLBEntry41 = initial_TLBEntry, 
     TLBEntry40 = initial_TLBEntry, 
     TLBEntry39 = initial_TLBEntry, 
     TLBEntry38 = initial_TLBEntry, 
     TLBEntry37 = initial_TLBEntry, 
     TLBEntry36 = initial_TLBEntry, 
     TLBEntry35 = initial_TLBEntry, 
     TLBEntry34 = initial_TLBEntry, 
     TLBEntry33 = initial_TLBEntry, 
     TLBEntry32 = initial_TLBEntry, 
     TLBEntry31 = initial_TLBEntry, 
     TLBEntry30 = initial_TLBEntry, 
     TLBEntry29 = initial_TLBEntry, 
     TLBEntry28 = initial_TLBEntry, 
     TLBEntry27 = initial_TLBEntry, 
     TLBEntry26 = initial_TLBEntry, 
     TLBEntry25 = initial_TLBEntry, 
     TLBEntry24 = initial_TLBEntry, 
     TLBEntry23 = initial_TLBEntry, 
     TLBEntry22 = initial_TLBEntry, 
     TLBEntry21 = initial_TLBEntry, 
     TLBEntry20 = initial_TLBEntry, 
     TLBEntry19 = initial_TLBEntry, 
     TLBEntry18 = initial_TLBEntry, 
     TLBEntry17 = initial_TLBEntry, 
     TLBEntry16 = initial_TLBEntry, 
     TLBEntry15 = initial_TLBEntry, 
     TLBEntry14 = initial_TLBEntry, 
     TLBEntry13 = initial_TLBEntry, 
     TLBEntry12 = initial_TLBEntry, 
     TLBEntry11 = initial_TLBEntry, 
     TLBEntry10 = initial_TLBEntry, 
     TLBEntry09 = initial_TLBEntry, 
     TLBEntry08 = initial_TLBEntry, 
     TLBEntry07 = initial_TLBEntry, 
     TLBEntry06 = initial_TLBEntry, 
     TLBEntry05 = initial_TLBEntry, 
     TLBEntry04 = initial_TLBEntry, 
     TLBEntry03 = initial_TLBEntry, 
     TLBEntry02 = initial_TLBEntry, 
     TLBEntry01 = initial_TLBEntry, 
     TLBEntry00 = initial_TLBEntry, 
     TLBXContext = initial_XContextReg, 
     TLBEntryHi = initial_TLBEntryHiReg, 
     TLBWired = (( 0b000000 ::  6 Word.word)), 
     TLBPageMask = (( 0x0000 ::  16 Word.word)), 
     TLBContext = initial_ContextReg, 
     TLBEntryLo1 = initial_TLBEntryLoReg, 
     TLBEntryLo0 = initial_TLBEntryLoReg, 
     TLBRandom = (( 0b000000 ::  6 Word.word)), 
     TLBIndex = (( 0b000000 ::  6 Word.word)), 
     TLBProbe = (( 0b0 ::  1 Word.word)), 
     NextPC = (( 0x0000000000000000 ::  64 Word.word)), 
     PC = (( 0x0000000000000000 ::  64 Word.word)) |) )\<close>



end
